{"meta":{"title":"「Stay hungry，stay foolish.」","subtitle":null,"description":"爱技术，爱分享","author":"Light Lin","url":"http://www.brightlam.top","root":"/"},"pages":[{"title":"","date":"2018-04-24T15:24:07.812Z","updated":"2018-04-24T15:18:54.371Z","comments":true,"path":"404.html","permalink":"http://www.brightlam.top/404.html","excerpt":"","text":""},{"title":"aboutme","date":"2018-04-18T14:42:29.000Z","updated":"2018-04-18T14:42:29.062Z","comments":true,"path":"aboutme/index.html","permalink":"http://www.brightlam.top/aboutme/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-22T15:29:13.000Z","updated":"2019-03-22T15:30:12.787Z","comments":false,"path":"categories/index.html","permalink":"http://www.brightlam.top/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2018-04-24T15:16:46.000Z","updated":"2018-04-24T15:16:46.198Z","comments":true,"path":"archives/index.html","permalink":"http://www.brightlam.top/archives/index.html","excerpt":"","text":""},{"title":"works","date":"2018-04-22T06:29:31.000Z","updated":"2018-04-22T06:29:31.127Z","comments":true,"path":"works/index.html","permalink":"http://www.brightlam.top/works/index.html","excerpt":"","text":""},{"title":"essays","date":"2018-04-22T06:29:06.000Z","updated":"2018-04-22T06:29:06.845Z","comments":true,"path":"essays/index.html","permalink":"http://www.brightlam.top/essays/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-22T15:34:12.000Z","updated":"2019-03-22T15:35:21.941Z","comments":false,"path":"tags/index.html","permalink":"http://www.brightlam.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"原生 JS 实现滚动监听","slug":"原生-JS-实现滚动监听","date":"2019-05-15T10:50:48.000Z","updated":"2019-05-15T11:04:53.594Z","comments":true,"path":"2019/05/15/原生-JS-实现滚动监听/","link":"","permalink":"http://www.brightlam.top/2019/05/15/原生-JS-实现滚动监听/","excerpt":"","text":"本文的内容是 JS 滚动监听导航栏更新背景色标识。 之前在 bootstrap 文档上看到这样一个效果，如下 因为 bootstrap 是引用了 jQuery 库的，非常容易上手，也能方便地用在各个项目中，但不折腾的前端，跟咸鱼有什么区别。于是就想着不用这些库，自己用 JS 实现以下这个效果，所以就折腾了下。 滚动监听原理首先了解一下滚动监听的原理，当鼠标滚轮滚动或页面滚动条滑动时，每到一块内容区域，其上方对应的导航栏状态也将更新，那就需要知道每块内容区域相对于顶部的距离，将这个距离跟滚动条滑行的距离做比较，根据比较的结果来决定是否更新导航栏状态标。所以整个大致思路就是：监听页面的 scroll 事件，然后获取当前页面滚动条纵坐标的位置，假设为 posNav；在获取内容区域，这里假设分为内容1，内容2，内容3，获取这些内容块相对于视口顶部的距离，假设是 height ，随着滚动条的滑动，如果 posNav &gt; height1，那么第一个导航标签更新；如果 posNav &gt; height2 ，那么第二个导航更新，…，依次遍历直至底部，在这个过程中，还要注意当其中一个加上了背景色之后，跟它同级的所有元素都要移除掉这个背景色。 瞄点定位除了根据内容区域滚动更新之外，这里还涉及到一个定位的问题，即点击导航栏，就定位到这个导航所对应的内容区域，这也是很多单页面常有的做法。实现这个最简单、粗暴的方法就是使用瞄点定位，给每个导航 a 标签的 href 属性写上 #id 的格式，然后给对应的内容区域加上 id名称 ，由于 id 是唯一标识，因此点击导航就可直接定位，简单，无兼容问题，非常好的一个实现技巧。 实现在开始写 js 之前，先准备一个简单的静态页面，默认给第一个导航加上 active 属性，也就是有背景色的效果。 有了页面后，先获取所有导航 li 标签，存在数组里，等会用它更新导航栏。1var lis = [...document.querySelectorAll(&apos;.nav &gt; ul &gt; li&apos;)]; … 是一个展开运算符，querySelectorAll 选取所有 class 为 nav 下面的 ul 的 li 标签元素的集合，展开运算符将它们都存在数组 lis 里。接着获取内容块区域相对于页面顶部的距离，同样将它们存在数组里。1var divs = [...document.querySelectorAll(&apos;.mainPage&apos;)]; 获取到后，用一个 for 循环遍历获取每个 div 的距离顶部的值，使用 getBoundingClientRect() 方法，它返回元素的大小及其相对于视口的位置，我们主要使用 top 属性获取顶部距离。1234var divHeights = [];for (var i = 0; i &lt; divs.length; i++) &#123; // 循环每个 div 的距离 top 的值存放至数组 divHeights.push(divs[i].getBoundingClientRect().top);&#125; 现在所有该有的元素及其数值都有了，可以开始写监听事件了。这里吐个槽，别看上面寥寥几句话就完成了这些属性及其元素的获取，真正在做的时候，我花了不少世间查询这些方法及属性，像 getBoundingClientRect() 、document.doucmentElement.scrollTop 等属性的用法，主要是一直使用现成的框架，导致太依赖框架的那些简便封装好的方法而忽视了原来方法，所以建议各位用框架久了记得回过来看看每个方法对应的作用以及在原生 js 的实现。好了，监听页面滚动事件把它写在一个函数里，定义如下1234567891011121314function updateNav() &#123; var scop = document.documentElement.scrollTop; var k; for (var i = 0; i &lt; divHeights.length; i++) &#123; if (scop &gt; divHeights[i] - 50) &#123; k = i; &#125; &#125; lis[k].classList.add(&apos;current&apos;); for (var i = 0; i &lt; lis.length; i++) &#123; if (i == k) continue; else lis[i].classList.remove(&apos;current&apos;); &#125;&#125; 最后一句代码调用函数即可1window.addEventListener(&apos;scroll&apos;, updateNav); 至此，所以代码都完成了，来看看最终浏览器的效果吧： 感谢阅读，想要获取完整源代码，请点击 这里 （完）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"JavaScript 学习之路- JS 小测验","slug":"JavaScript-学习之路-JS-小测验","date":"2019-05-01T09:56:38.000Z","updated":"2019-05-01T09:58:23.055Z","comments":true,"path":"2019/05/01/JavaScript-学习之路-JS-小测验/","link":"","permalink":"http://www.brightlam.top/2019/05/01/JavaScript-学习之路-JS-小测验/","excerpt":"","text":"在学习 JS 的过程中，很多知识往往看一遍就过去了，然后自以为掌握了，其实再次碰到不一定能答得出来，看到一些有趣的东西还是要动手实践一下，而且时不时复习一下，非常有利于加深记忆。今天是五一，假日期间，好好休息玩耍，也别学什么新东西了，你可以看看以下这些问题以及相关知识点来看看自己掌握了多少，温故知新。 问题不多，耐心看完。最下方有答案，先别急着翻，自己先想想。 问题 JS 格式化，用逗号分隔千分位数字 运行 [1, 2, 2].fill(3, 1, 3) 会输出什么 ~~3.5 的结果是什么 如何判断一个数组的长度是奇数还是偶数 JSON.parse 和 JSON.stringify 的作用 typeof null为什么等于 &quot;object&quot;，它的判断原理是什么 如何判断一个元素是否为数组 &lt;&lt; 和 &gt;&gt; 运算符 function add(){} 和 var add = function（）{} 解析时的区别 执行以下代码，输出是什么？为什么？1234567var arr=[1,2,3,4,5];for(var i=0;i&lt;arr.length;i++) &#123; arr[i]=function()&#123; alert(i) &#125;&#125;arr[3](); 参考答案如有错误，请帮忙指正。 JS 格式化，用逗号分隔千分位数字 两种方法，一种是使用 tolocaleString()12var a = 1999;a.toLocaleString(); // &quot;1,999&quot; 另外一种是正则表达式123var re = /(?!^)(?=(\\d&#123;3&#125;)+$)/g;var a = &quot;12345678&quot;;a.replace(re, &apos;,&apos;); // &quot;12,345,678&quot; 运行 [1, 2, 2].fill(3, 1, 3) 会输出什么? 答案是 [1,3,3] fill 方法接受三个参数：num，start，end 。num 是你要填充的数字，start 是填充的起始位置，end 是终止位置。fill(3,1,3) 表示从索引 1 开始到索引 3 之间的元素填充为 3 ~~3.5 的结果是什么？答案是 3 对于非数字，~~ 的结果为0，有个例外是 ~~ true 结果为 1对于大于 0 的数，~~ 相当于是Math.floor对于小于 0 的数，~~ 相当于是Math.ceil 如何判断一个数组的长度是奇数还是偶数？答案是len &amp; 1，len 为数组长度，奇数结果为true 只要 “&amp;&amp;” 前面是false，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 前面的值;只要 “||” 前面为 false,不管 “||” 后面是 true 还是 false，都返回 “||” 后面的值。 JSON.parse 和 JSON.stringify 的作用？ JSON.parse 将一个 json 转化为 JavaScript Object string 类型JSON.stringify 将一个 string 转化为 json 类型 typeof null为什么等于 &quot;object&quot;，它的判断原理是什么 js 底层存储变量采用二进制，会在变量的机器码的低位 1-3 位存储其类型信息000：对象010：浮点数100：字符串110：布尔1：整数null：全0undefined：-2^30所以 typeof null 为显示为 object 对象。 如何判断一个元素是否为数组？ 假设待判断对象为 arr ，有四种方法，一是1Object.prototype.toString.call(arr) == &apos;[object Array]&apos; 或者是1arr instanceof Array 又或是1Array.isArray(arr) 第四种方法可以用1arr.__proto__.constructor == Array &lt;&lt; 和 &gt;&gt; 运算符相关操作？ 左移 &lt;&lt; 将一个数的二进制表示向左移动 n 位，右边用0填充。右移 &gt;&gt; 将一个数的二进制表示向右移 n 位，舍弃被移出的位。简单点说，a &gt;&gt; n 相当于用 a 去除以 2 的 n 次方，所以 8 &gt;&gt; 1 结果为 4;而 a &lt;&lt; n 相当于用 a 去乘以 2 的 n 次方，所以 2 &lt;&lt; 5 结果为 64 function add() {} 和 var add = function (){} 解析时的区别 前者是执行前就会被解析（执行前就会读取函数名），而后者是执行过程中解析。所以 function add() {} 在执行里面的代码前就会读取函数名 add , 而 var add = function (){} 则是执行时逐步解析。 执行以下代码，输出是什么？为什么？1234567var arr=[1,2,3,4,5];for(var i=0;i&lt;arr.length;i++) &#123; arr[i]=function()&#123; alert(i) &#125;&#125;arr[3](); 答案是输出 i 的值为 5 。这个是与闭包有关的经常看到的问题，不管运行函数时传入的 i 是什么，最终输出的都是 for 循环结束时的 i 的值，也就是数组的长度，因为匿名函数里的这句 alert(i) 执行的时候需要找到 i 变量，里面没有，那就只好去父级里找，而父级里的 i 在 for 循环，所以最终给到它的是循环的终止条件，也就是 i = 5 。解决方法也很简单，要么把 for() 里面的 var 换成 let ，形成块级作用域；要么使用闭包，匿名函数里在返回一个匿名函数，并且传入 i 立刻执行。 (完)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"图片懒加载的几种方法","slug":"图片懒加载的几种方法","date":"2019-04-05T04:03:17.000Z","updated":"2019-04-05T05:46:29.330Z","comments":true,"path":"2019/04/05/图片懒加载的几种方法/","link":"","permalink":"http://www.brightlam.top/2019/04/05/图片懒加载的几种方法/","excerpt":"","text":"在一些图片比较多的网站会用到 图片懒加载 技术，这项技术可以延迟加载图像，只当图片出现在我们看到的视图中才加载，它的好处是大大提高用户体验，节省不必要的资源浪费以及网站的性能提升等。下面介绍几种图片懒加载的方法，分别是监听 scroll、resize 事件，使用 Intersection Observer API 以及 Chrome70 自带的懒加载设置。任何技术都是为解决问题服务的。在开始之前，还是要了解清楚「是什么」以及「为什么」。 什么是懒加载当一个网站的图片数量较多时，直接加载可能会有很大的开销，不利于性能，这时可以将所有的图片换成轻量的占位图，不加载图片。而当用户真正滚动到图片出现时，再迅速将占位图片换成真正我们想展示的图片，这整个过程就是懒加载。 为什么要懒加载当你打开一个网站时，浏览器会做许多工作，这其中包括下载各种可能用到的资源，然后渲染呈现在你面前，假设你的网站有大量的图片，那么加载的过程是很耗时的，尤其像那些新闻资讯类需要大量图片的网站，可想而知，网站的初始加载时间会很长，再加上网络等其它影响，用户体验会很差，相信你经常遇到过一个网站卡在某个地方，一直在加载，这种体验很不好。我们都希望一输入网址，页面立马就呈现在眼前。 既然想要页面立马呈现在面前，那势必要减少浏览器的负荷，优化代码，减少一些不必要的请求和不必要资源的加载，因为你打开网站的时候，浏览器会把所有可能的资源都下载好，而实际上有些资源你并不需要用到，这就造成了浪费。所以有必要在一些资源上做下优化，提高网站加载速度。 滚动事件监听前面说到要等图片出现在视口时才加载，那么肯定要监控浏览器的 scroll 事件，并且要计算图片与浏览器窗口的距离来选择替换图片的 src 地址。代码如下：123456789HTML&lt;div&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/600&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/700&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/800&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/900&quot; alt=&quot;&quot;&gt;&lt;/div&gt;// 引入 lodash 库&lt;script src=&quot;https://cdn.bootcss.com/lodash.js/4.17.12-pre/lodash.core.min.js&quot;&gt;&lt;/script&gt; 12345678CSSdiv &#123; margin-top: 350px;&#125;.lazy-load &#123; width: 200px; height: 150px;&#125; 12345678910111213JSlet lazyImages = [...document.querySelectorAll(&apos;.lazy-load&apos;)]let inAdvance = 300function lazyLoad() &#123; lazyImages.forEach(image =&gt; &#123; if (image.offsetTop &lt; window.innerHeight + window.pageYOffset + inAdvance) &#123; image.src = image.dataset.src; // 替换真实图片的 URL &#125; &#125;)&#125;lazyLoad();window.addEventListener(&apos;scroll&apos;, _.throttle(lazyLoad, 50))window.addEventListener(&apos;resize&apos;, _.throttle(lazyLoad, 50)) 这其中有几个属性，首先是 data-src，它是自定义属性，可以在 js 里通过 dataset 获得它的属性值；还有 offsetTop ,innerHeight 以及 pageYOffset 属性，你可以通过 MDN 文档查询他们的定义和用法；最后是 _.throttle 函数，它是一个节流函数，引用自 lodash 库，因为监听 scroll 滚动以及 resize 窗口改变事件会不断地触发，过于频繁，所以使用节流函数让其每隔一段时间执行，节省开销。 Intersection Observer API现在，有一个 Intersection observer 接口可以方便我们操作，它可以异步观察目标元素与祖先元素或顶层文件的交集变化。简单的说，以前我们需要自己去写滚动监听事件函数，现在，这个 API 可以帮助我们，我们只需要统一写一个 观察函数 ，每当想观察的元素进入视口，也就是我们看见它时，就执行相应的操作。看看以下 js 代码：123456789101112&lt;style&gt; // css 部分 .lazy-load &#123; width: 400px; height: 300px; &#125;&lt;/style&gt;&lt;div&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/600&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/700&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/800&quot; alt=&quot;&quot;&gt; &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/900&quot; alt=&quot;&quot;&gt;&lt;/div&gt; 123456789101112131415161718192021document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123; let lazyImages = [...document.querySelectorAll(&apos;.lazy-load&apos;)]; if (&quot;IntersectionObserver&quot; in window) &#123; // 创建一个观察函数，以便待会调用 let lazyImageObserver = new IntersectionObserver(function(entries, observer) &#123; entries.forEach(function(entry) &#123; if (entry.isIntersecting) &#123; let lazyImage = entry.target; lazyImage.src = lazyImage.dataset.src; // 替换 src URL lazyImageObserver.unobserve(lazyImage); // 解除观察 &#125; &#125;); &#125;); // 对所有需要懒加载的图片进行 “暗中观察” lazyImages.forEach(function(lazyImage) &#123; lazyImageObserver.observe(lazyImage); &#125;); &#125;else&#123; alert(&apos;您的浏览器不支持 IntersectionObserver&apos;); &#125;&#125;); 可以看到，里面监听了 DOMContentLoaded 事件，当初始的 HTML 文档被完全加载和解析完成之后，这个事件就被触发，在页面初始之后获取到所有图片元素，然后进行观察。 那既然这个 API 这么好，又简便易用，有没什么缺点呢？相信你看了上面的代码就能知晓，对，浏览器兼容问题！！ can I use 可以看到，还是有很多泛红，只有 Chrome 支持的最好，从 58 以上版本就完全支持了，Firefox 也不错。如果你的项目不需要考虑兼容的话，可以尝试使用下它，看看效果。 Chrome 浏览器自带这个方法厉害了，没有前面两种方法那么复杂，它是 Chrome 自带的原生 lazyload 属性，只需要一个开关。 chrome://flags/#enable-lazy-image-loading 复制它到 Chrome 浏览器的地址栏，然后找到如下选项，将其设置为「Enabled」。 然后在 HTML 标签里开启：1&lt;img src=&quot;https://source.unsplash.com/random/600&quot; alt=&quot;&quot; lazyload=&quot;on&quot;&gt; 不需要多余的代码，不需要 JS ，简直强大。 比较三者秉承着尝试捣鼓新技术的原则，应该优先使用 Intersection Observer ,随着越来越多的浏览器支持会更广泛地应用；但如果要考虑浏览器的兼容问题，那就要使用平常的 scroll,resize 事件监听了，配合 offsetTop 、innerHeight 以及 pageYOffset 几个属性实现。至于最简单粗暴的那个方法，很明显只能在特定的 Chrome 70 以上版本中使用，有很大的局限性，不过现在使用 Chrome 的人非常的多，所以也是有用处的。综合来看，应该将 Intersection Observer 和 scroll,resize 结合起来使用，这可能是最优也最兼容的方案。 参考资料[1] MDN 文档：https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API[2] 延迟加载图像和视频：https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/[3] Lazy load images：https://medium.com/@filipvitas/lazy-load-images-with-zero-javascript-2c5bcb691274","categories":[],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://www.brightlam.top/tags/Chrome/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"JavaScript 学习之路-原型和原型链","slug":"JavaScript-学习之路-原型和原型链","date":"2019-03-24T10:28:30.000Z","updated":"2019-03-24T10:32:33.430Z","comments":true,"path":"2019/03/24/JavaScript-学习之路-原型和原型链/","link":"","permalink":"http://www.brightlam.top/2019/03/24/JavaScript-学习之路-原型和原型链/","excerpt":"","text":"面向对象语言(Object-Oriented) 都有类的概念，通常用 class 关键字来定义。在最新的 ES6 标准里，也加入了类的使用，这意味着，js 也能像其它 OO 语言那样很方便地实现继承了。但是，js 的 class 其实只是个语法糖，它依然是通过原型链来实现继承的。 在理解原型链之前，首先要理解一句话，构造函数、原型和实例三者的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 理解 prototype、proto 和 constructor上面这句话对应着几个属性：prototype ，__proto__ 和 constructor 。 每个函数在被创建的时候，都会获得一个 prototype 属性，这个 prototype 属性会包含一个指针，叫做 constrcuctor ，这个 constructor 的值是构造函数的名称。所以对应了上面那句话：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针 。我们通过 Chrome 控制台来验证一下： Chrome 可以看到，我们定义了一个函数，函数名为 f ，f 的原型 prototype 里的 constructor 最终是等于它的构造函数名称的，那么这个 constructor 属性究竟是用来干嘛的？在查阅了网上相关资料后，我发现它是 JavaScript 语言设计的历史遗留物，它的值是可以手动变更的，但我们习惯于让它的值指向构造函数。 看上面的图仔细看会发现函数的 prototype 里还有一个 __proto__ 属性。这个属性是每个对象都会有的隐式属性。那在 JS 这门语言里，万物皆对象。你在 console 里输入 typeof f 会输出 function ,但 function 也是对象。不信你在输入 Function instanceof Object 看看结果。这个 __proto__ 对于实现继承有非常重要的作用，它始终指向对象的构造函数的原型。 这个属性对于我们理清两个对象之间的关系有很大的作用。 当我们 new 一个对象的时候，实际上就是生成了该对象的实例，这个实例对象会获得一个 __proto__ 属性，链接到它的构造函数原型。这样下来就好理解了，前面我们定义的 function f(){} 实际上 function 只是一个语法糖，为了好看而已，它的内部是做了一个 new Function() 的实现，Function 可以理解为所有函数的老大，我们平常使用关键字定义的函数内部都是去 new Function 实现的。 那既然函数 f 是 Function 的实例，那它肯定会获得一个 __proto__ 属性，这个属性是指向它的构造函数 Function 的原型 prototype 的。眼见为实，我们来验证下： image 对于开头提到的构造函数、原型和实例三者的关系，我想你应该有了概念了。为加深理解，我把它画成了图，如下： image 原型链在理解了原型之后，我们来看下原型链。让一个原型去继承另一个原型的属性和方法，就组成了原型链。就像前面的 finstance 是函数 f 的实例，f 又是 Function 的实例，… 就这样一层一层下来，就组成了原型链。我们来看一段代码：123456789101112function Dad()&#123; this.name = &apos;xiaoming&apos;;&#125;Dad.prototype.getName = function()&#123; return this.name;&#125;function Son()&#123; this.age = 18;&#125;Son.prototype = new Dad();var baby = new Son();console.log(baby.getName()); // xiaoming 上面这个就是继承的一种最简单的实现方式了，我们来看下它的原型链，首先 Dad 是父类，它有自己的属性 name，它的原型里定义了一个 getName 的方法。接着有一个子类 Son 继承 Dad ,它也有自己的属性 age，我们通过设置 Son.prototype = new Dad(); 来实现原型继承，这样子类 Son 可以访问到父类 Dad 的属性和方法，所以子类的实例 baby 可以获取到 name 属性和 getName() 方法。 我们通过一张图来看下它的原型链： image 总结__proto__ 属性通过将对象和原型之间联系起来来组成原型链；理解原型链，先要理解 prototype 、constructor 和 proto 这几个概念，理清构造函数、原型和实例三者的关系，结合实际效果来验证。JS 不像其它 OO 语言那样，它是通过原型链来实现继承的。这部分内容比较晦涩比较绕，耐心地多看多实践，不懂的网上查阅资料，也许就有所理解。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"JS实现一个倒计时","slug":"JS实现一个倒计时","date":"2019-03-16T09:51:39.000Z","updated":"2019-03-16T09:52:44.360Z","comments":true,"path":"2019/03/16/JS实现一个倒计时/","link":"","permalink":"http://www.brightlam.top/2019/03/16/JS实现一个倒计时/","excerpt":"","text":"你看到这篇文章时，倒计时应该已经结束了。 又到了金三银四季节，每年这个时候大家都在拼命刷题准备各大公司的招聘，这个时候我们需要对一些常见的面试题有所了解，比如今天要说的就是我在网上看到的，要你手写一个 js 倒计时效果，手写代码是什么感觉？速度 70 迈，心情真是嗨，本想好好秀一下的，谁知刚落笔就 … … 告辞！不过，多写代码确实可以保持手感，虽然刚开始会一直支支吾吾写不出，不过越写越顺手，越能发现自己的知识盲点，查漏补缺。 原理既然是倒计时，肯定是要涉及到时间日期的操作了。js 里可以用 new Date() 来创建各种格式的时间日期。要能够倒计时，我们需要设置一个起始时间以及一个终止时间，计算出这两段时间的差，然后通过循环调用，每隔 1 秒刷新一次就实现了。假设我们以当前电脑的时间作为起始时间，然后定死一个终止时间，由于起始时间一直在递增，而终止时间不变，那么通过递归后就是一个倒计时了。整体思路不难理解，不过真正实现其代码来还是有诸多需要注意的。 实战知道了大致实现思路后，你可以试着开始手写代码。我们定义一个函数，名为 countDown 。首先获取当前时间，现在是北京时间 2019 年 3 月 16 日，16 时 57 分，倒计时 1 小时，那么终止时间是 2019 年 3 月 16 日，17 时 57 分 。12345function countDown()&#123; var nowtime = new Date(); var endtime = new Date(&quot;2019/03/16,17:57:00&quot;); var lefttime = parseInt((endtime.getTime() - nowtime.getTime()) / 1000);&#125; lefttime 保存着两个时间的差值，getTime() 方法获取到时间戳，由于它是以 ms 为单位的，我们需要精确到秒就可以，所以除以 1000 就是以 s 为单位。接着，我们可以将这个时间分别计算为 天，时，分，秒 了。代码如下1234var d = parseInt(lefttime / (24*60*60))var h = parseInt(lefttime / (60 * 60) % 24);var m = parseInt(lefttime / 60 % 60);var s = parseInt(lefttime % 60); 1 天 24 小时，1 小时 60 分钟，1 分钟 60 秒，稍微转换就能计算出上面几个变量的值。到了这里，有个小细节需要注意，如果是 10 以下的数我们要进行补零！。于是我们在写一个补零函数，名为 addZero .123function addZero()&#123; return i &lt; 10 ? &quot;0&quot; + i: i + &quot;&quot;;&#125; 好了，接下来对上面求得的 d,h,m,s 进行补零。1234d = addZero(d)h = addZero(h);m = addZero(m);s = addZero(s); 最后我们只需要利用 setTimeout 循环调用，每隔 1 s 刷新就可以了。1setTimeout(showtime, 1000); OK! 一个倒计时函数大功告成。为了把它显示到浏览器页面上，我们需要在加点 HTML 代码：12html&lt;p class=&quot;count&quot;&gt;&lt;/p&gt; 然后在 js 里加上：123456jsdocument.querySelector(&quot;.count&quot;).innerHTML = `活动倒计时 $&#123;d&#125;天 $&#123;h&#125; 时 $&#123;m&#125; 分 $&#123;s&#125; 秒`;if (lefttime &lt;= 0) &#123; document.querySelector(&quot;.count&quot;).innerHTML = &quot;活动已结束&quot;; return;&#125; 这里的 if 判断当倒计时为 0 的时候，就显示 活动已结束 , 并且把函数 return 掉。 最终效果由于上传 GIF 动图时出现了点小问题，你可以自己 run 下代码并到浏览器查看效果，这样记忆更深哦~ 完整代码123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;p class=&quot;count&quot;&gt;&lt;/p&gt; &lt;script&gt; window.onload = function () &#123; countDown(); function addZero(i) &#123; return i &lt; 10 ? &quot;0&quot; + i: i + &quot;&quot;; &#125; function countDown() &#123; var nowtime = new Date(); var endtime = new Date(&quot;2019/03/16,17:57:00&quot;); var lefttime = parseInt((endtime.getTime() - nowtime.getTime()) / 1000); var d = parseInt(lefttime / (24*60*60)) var h = parseInt(lefttime / (60 * 60) % 24); var m = parseInt(lefttime / 60 % 60); var s = parseInt(lefttime % 60); d = addZero(d) h = addZero(h); m = addZero(m); s = addZero(s); document.querySelector(&quot;.count&quot;).innerHTML = `活动倒计时 $&#123;d&#125;天 $&#123;h&#125; 时 $&#123;m&#125; 分 $&#123;s&#125; 秒`; if (lefttime &lt;= 0) &#123; document.querySelector(&quot;.count&quot;).innerHTML = &quot;活动已结束&quot;; return; &#125; setTimeout(countDown, 1000); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 总结知识需要通过实践来验证，先学好必备的基础知识，然后找些 demo 来练习巩固，在练习的过程中也许会发现自己以前忽视的一些小问题，也就起到了查漏补缺的作用。在 coding 中寻找快乐！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"一个移动端 H5 项目总结","slug":"一个移动端-H5-项目总结","date":"2019-02-27T13:30:50.000Z","updated":"2019-04-19T16:20:51.019Z","comments":true,"path":"2019/02/27/一个移动端-H5-项目总结/","link":"","permalink":"http://www.brightlam.top/2019/02/27/一个移动端-H5-项目总结/","excerpt":"","text":"两个月前做过几个移动端的 H5 页面，一些看似简单的东西一旦动手做起来总是会出现许多各式各样的问题，所以把这些问题记录下来，自己没事翻一翻，而且没准以后别人也遇到类似的问题，就可以供别人做参考，或者有个思路去解决。 position: fixed 定位失效需求里要求把导航栏固定在顶部，这个也很简单，当然就是一个position: fiexed 的事，然而到 Chrome 上调成手机模式一看，emm , 手指一滑导航栏也跟着走了，可能很多程序员都有过这样的错觉，写代码写的美滋滋，一到浏览器一看，理想与现实的差距啊！出现这种情况，那说明 position: fiexed 没起到作用，首先检查了下是不是这行代码拼写出了问题，发现没有问题；接着进入浏览器控制台用光标指向了这个元素，查看它对应的 css 样式，发现并没有出现 position: fiexed ; 于是，去 google 了一下，看了许多关于这个问题的解释，发现这么一句话：父级元素如果有transform属性，会导致子元素的fixed失效。解决是父元素去掉 transform 属性或者父元素加 display：inline; 按照这个去修改了相应的代码，发现还是没效果！！！好吧，最后，把那一个模块的代码全删了重新写，并且按上面说的确保父元素没有 transform 之类的属性，终于有了导航栏固定顶部的效果。 几点启示： 写代码要细心在细心，注意规范，否则写到后面很容易陷入混乱，一下子看不出哪里出了问题，又不知从哪调试起。 用好 google 或百度等搜索引擎 一个良好的心态有助于你在调试代码时更容易发现问题 手机端手指滑动轮播效果简单的图片轮播用 js 或 jq 即可实现，需要注意的是在移动端，轮播图需要配合手指滑动，如何能让手指滑动的时候图片跟着切换？去网上 search 了一下，最终采用了一个叫做 hammer.js 的移动端手势插件，其在线 cdn 是 https://cdn.bootcss.com/hammer.js/2.0.8/hammer.min.js , 直接用script 标签在线引进项目文件即可。然后需要在你自己的 js 文件里做如下设置：123456789101112$(function()&#123; var myElement= document.getElementById(&apos;轮播 div 的 id 名称&apos;); // 实例化 var hm = new Hammer(myElement); // 监听 swipeleft 和 swiperight 事件，使手指向左向右滑动切换 hm.on(&quot;swipeleft&quot;,function()&#123; $(&apos;# id 名称&apos;).carousel(&apos;next&apos;); &#125;) hm.on(&quot;swiperight&quot;,function()&#123; $(&apos;# id 名称&apos;).carousel(&apos;prev&apos;); &#125;)&#125;); 这样，在手机端你就可以通过手指滑动来实现图片轮播了。 布局错位通常一个移动端的 H5 页面都有一些常见的布局，比如一行显示两个，连续几行铺排下去，又或是左边图片右边文字这样几行的布局。这些用 flex 布局或者用 bootstrap 的栅格布局一下子就搞定。问题出现在用了 bootstrap 的栅格布局后，刚开始挺好，等回过头看的时候发现布局乱了，原先一行显示两张图片，突然有一张被挤了下来。这无非就几种情况，要么某一个 div 的宽度过大撑起来，将旁边的挤了下来；要么就是 padding 或 margin 等边距问题，仔细排查下应该就能发现问题。再者，如果是电商，有分页功能，某一页出现了问题调好了，另外一页又变乱了，这时候就应该从全局去看整个模块的代码去分析了，在使用 bootstrap 的 UI 组件时可以读下相关的文字说明，结合实际情况分析改进，就可以避免一些冲突。 label 标签模拟单选、复选框为了让按钮看起来更美观，提升用户体验，现在通常不直接用 input 标签的单选、复选按钮，而是用 label 标签结合 for 属性来模拟。具体代码如下：12345HTML代码&lt;div class=&quot;test&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;serach-moible&quot;&gt; &lt;label for=&quot;serach-moible&quot;&gt;苹果&lt;/label&gt;&lt;/div&gt; 1234567891011121314151617181920212223CSS 代码.test input&#123; opacity: 0; &#125;label&#123; display: block; font-size: 14px; line-height: 14px;&#125;input[type=checkbox]+label::before&#123; content: &apos;&apos;; background: transparent; border: 1px solid #000; box-shadow: inset 0 0 0 2px #fff; cursor: pointer; display: inline-block; width: 12px; height: 12px; margin-right: 12px; position: relative; top: 2px;&#125;input[type=checkbox]:checked+label::before&#123; background: #000;&#125; 代码运行起来是什么样子，你可以自己跑一下看看。模拟的过程就是先将原先的 input 标签隐藏，把按钮的样式添加在 label 标签上，当你点击 label 时，实际上就是选中了 input 单选按钮，为了这样，你必须要把 input 标签的 id 的值跟 label 标签的 for 属性值保持一致，这样就能通过操作 label 来操作按钮。 总结不管学什么知识，实践是检验效果的唯一标准，多动手多实践，哪怕在简单的东西也要亲自去敲一遍代码才能有所了解，养成良好的编码习惯，有问题借助搜索引擎，不要死盯在一个点上，保持好心态继续做下去，可能哪个瞬间就把问题解决了。 本文完。","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://www.brightlam.top/tags/移动端/"}]},{"title":"JavaScript 学习之路-语法篇(下)","slug":"JavaScript-学习之路-语法篇-下","date":"2019-01-11T09:04:38.000Z","updated":"2019-01-11T09:05:26.556Z","comments":true,"path":"2019/01/11/JavaScript-学习之路-语法篇-下/","link":"","permalink":"http://www.brightlam.top/2019/01/11/JavaScript-学习之路-语法篇-下/","excerpt":"","text":"这段时间一直在期末复习，这几天考完试末，轻松了许多，终于放假啦。 上篇文章（很久了）说的是 JavaScript 的操作符，有相等操作符、条件操作符、赋值操作符等等，这篇文章写的是语法篇的最后两个内容：语句 和 函数 。 语句语句由一个或多个词组成，可以完成某些任务和操作。 if 语句最常用也很熟悉的语句了，它的语法如下：12345if (condition) &#123; block1&#125; else &#123; block2&#125; 其中 condition 会被转换成一个布尔值来确定执行那一块代码，例如如果 condition 为 true，则执行 block1 的代码，否则执行 block2 。如果想要更省事一点，也可以直接用三目运算符来替代 if 语句，例如下面的代码跟上述的 if 语句是一样的，1condition ? block1 : block2 ; do-while 语句一种循环语句，它会至少先执行循环体内的代码一次，然后在根据条件判断是否继续循环，语法如下：123do &#123; code&#125; while (condition); while 语句看看它的语法，比较下跟 do-while 的区别：123while (condition) &#123; code&#125; 可以看到，while 循环语句是上来就开始判断 condition 是否为 true ，是的话才会执行代码，否则不会执行；而前面的 do-while 循环是会至少执行一次代码再来判断条件，这就是区别。 for 语句依然是循环语句，而且也是经常使用的循环语句。它的语法如下：123for ( init; expression; loop-expression) &#123; code&#125; 怎么使用它呢？下面的代码会输出 1 到 10 之间的数：123for (var i = 1; i&lt;=10; i++) &#123; console.log(i);&#125; 其实 while 循环能做到的，for 循环也同样能做到，上面的如果用 while 循环是这样：12345var i = 1;while (i &lt;= 10) &#123; console.log(i); i++;&#125; 既然这样，那还要 for 循环干嘛呢？for 循环可以做到根据已知条件来确定循环次数，比如你要打印某个数 10 次，那用 for 循环，中间 i &lt; 10 直接写就好了；但如果事先并不知道要循环多少次，条件也不是很清楚，那么用 while 循环先执行着也是不错，如果这段代码要先被执行一次，那就用 do-while 好了。 for-in 语句是一种迭代语句，可以用来枚举对象的属性，非常实用的语句。语法如下：123for (var propName in window) &#123; document.write(propName);&#125; 执行这段代码你将看到浏览器 window 对象的所有可枚举属性。 label 语句label 语句可以在代码中添加标签，以便将来使用，语法如下：1labelName: code 通常会与 for 等循环语句配合使用，由 break 或 continue 语句来引用。 break 和 continue 语句break 语句可以让代码停止执行，用在 for 语句中会立即退出循环；而 continue 语句也是让代码停止执行，但它不会退出循环，而是从循环的顶部继续执行，也就是在执行下一次循环。123456for (var i = 1; i &lt;= 10; i++) &#123; if ( i % 5 == 0) &#123; console.log(i); break; &#125;&#125; 上面的代码找出 10 以内能被 5 整除的数，找到了就输出，而且找到了就不找了，立刻停止退出循环，最后输出的结果是 5 。而如果使用 continue 替代 break 呢？123456for (var i = 1; i &lt;= 10; i++) &#123; if ( i % 5 == 0) &#123; console.log(i); continue; &#125;&#125; 答案显而易见，会输出 5 以及 10 。因为找到了一个 5 之外，continue 的意思是不用再执行下面的代码了，从顶部开始下一次循环再找。 with 语句with 语句可以简化代码量，以一个特定的对象来开头，减少重复书写它的次数，例如下面的代码：123var qs = location.search;var hostName = location.hostname;var url = location.href; 每次都需要用到 location 这个对象，我们可以把它关联起来，用 with 语句改写：12345with (location) &#123; var qs = search; var hostName = hostname; var url = href;&#125; 这样就不必时刻写 location 字段了，需要注意的是，该语句在 严格模式 下是报错不能用的。 switch 语句最后一个是 switch 语句，它是为了解决 if 语句分支过多过长的问题，例如下面这段冗长的 if 语句代码：12345678910111213if ( i == 100) &#123; alert(&apos;恭喜你考了满分&apos;);&#125; else if ( i == 90) &#123; alert(&apos;优秀&apos;);&#125; else if (i == 80) &#123; alert(&apos;很不错&apos;);&#125; else if (i == 70) &#123; alert(&apos;勉强还行&apos;);&#125; else if (i == 60) &#123; alert(&apos;在挂科的边缘疯狂试探&apos;);&#125; else &#123; alert(&apos;骚年，补考见&apos;);&#125; switch 语句为了优化上述代码，写成这个样子：12345678910111213141516171819switch (i) &#123; case 100: alert(&apos;恭喜你考了满分&apos;); break; case 90: alert(&apos;优秀&apos;); break; case 80: alert(&apos;很不错&apos;); break; case 70: alert(&apos;勉强还行&apos;); break; case 60: alert(&apos;在挂科的边缘疯狂试探&apos;); break; default: alert(&apos;骚年，补考见&apos;);&#125; switch 语句的好处是能根据条件 i 的值，来决定是到那一段 case 代码中去执行，并且执行完后就 break 掉，而不执行接下来的其它 case ，这样条例清晰、一一对应，而 default 就是上面所有 case 都不管用了，那就默认执行它里面的内容。 上面这九大语句，基本就是一门编程语言中常用到的语句了，基本上其它编程语句也都是这么几种，只不过语法稍微有所差别，写法不同而已，只要熟悉了上述这几种语句，在其他语言中同样适用，毕竟语言是互通的。 函数函数也是每门编程语言都会有的语法概念。有没有相过，如果一个页面里面充斥着大量的语句，这些语句实现着各种功能，有些还经常是重复的，你其实多写了几遍。这时候，你可以考虑把这些语句集合起来，封装成一个函数。函数就是封装了任意多条语句，每次需要用的时候就调用它，通过什么标识来区别函数呢？函数名，js 中函数使用 function 关键字来声明，后面紧接的就是函数名，在接着就是圆括号，里面存放的是函数的参数，用 ，隔开，最后就是函数的主体代码了。123function funName(arg1,arg2,arg3) &#123; code&#125; 上面就是 js 定义一个函数的格式。函数可以有一个 return 语句，表示该函数返回结果，如果使用了 return 语句，则后面的代码一概不会被执行，比如下面这样：1234function sum(a,b) &#123; return a + b; console.log(&apos;hello world&apos;);&#125; 输入两个参数值 a 和 b 调用 sum 函数，可以计算 a + b 的结果，但后面那句 hello world 是不会被执行了，因为 return 语句就是最终语句了，函数遇到 return 后就会立即停止退出。另外，还有一个 arguments 类数组对象一直存放着函数的参数，使用 arguments 可以获取函数的参数信息，比如上面的 sum 函数，以下代码：12345function sum(a,b) &#123; return a + b; console.log(&apos;hello world&apos;); console.log(arguments.length);&#125; 当你 sum(10,20) 调用函数后，最后那句代码会输出 2，因为你输入了 10、20 两个参数，长度为 2 ，前面说了，arguments 存放的是参数的信息，它是一个类似数组的东西，所以你可以用 arguments[0] 表示第一个参数，也就是 10；用 arguments[1] 表示第二个参数，也就是 20 。 由于 js 的函数参数实际上是一个数组，所以不传值或者少传多传都不会报错，这点可以说是非常宽松的，相比其他语言来说。你可以随意输入多个参数，只不过会显示 undefined 。 js 的函数没有重载这一概念，如果定义两个名字相同函数，则后者覆盖前者。但由于有 arguments 数组的存在，可以通过使用 if 语句判断传入的 arguments 参数来相应执行不同的代码，也算是模拟重载。 (全文完)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"python 学习笔记(二)","slug":"python-学习笔记-二","date":"2019-01-08T09:30:40.000Z","updated":"2019-01-08T09:31:48.879Z","comments":true,"path":"2019/01/08/python-学习笔记-二/","link":"","permalink":"http://www.brightlam.top/2019/01/08/python-学习笔记-二/","excerpt":"","text":"两点之间的距离公式 12math.sqrt(f)f = (x1 - y1) ** 2 + (x2 - y2) ** 2 两个字符串连接，用格式化 &#39;%s%s&#39;%(a,b) 列表的函数 123最大函数 max(list)最小函数 min(list)计数函数 count(list) 判断一个整数是否回文 123456def isHuiWen(num): a = reversed(list(num)) if(list(a) == list(num)): return True else: return False 把一个列表中的数转换成字符串输出 1&apos; &apos;.join(&apos;%s&apos; %id for id in arr) 用列表表达式输入数据 1l = [int(i) for i in input().split()] // 此时可以在控制台输入一行以空格分割的整数 列表切片 123456l = [1,5,8,7,9,8,7,6,2];l[:] // 复制列表l[0:3] // 取前三个数l[::3] // 所有的数每 3 个取一个l[:6:2] // 前 6 个数每 2 个取一个l[2:6] // 取第 3 个到第 6 个之间的数(不包括 6) 十进制转换为二进制 123x = 10bin(x).replace(&apos;0b&apos;,&apos;&apos;)bin(x)[2:] 二进制转换为十进制 12y = 1100int(y,base=2) 二进制补 0 操作（16位） 12345for i in range(1,16): if len(sx)&lt;16: sx=str(0)+sx if len(sy)&lt;16: sy=str(0)+sy 集合的差集 1234x = list(set(A).difference(set(B)) // 属于 A 不属于 B 的元素x.sort(key = A.index) // 按 A 集合的元素顺序intersection() // 该方法返回集合的交集union() // 该方法返回集合的并集 大小写字母的 ASCII 符 1234print([chr(i) for i in range(65,91)]) // 输出 26 个大写字母print([chr(i) for i in range(97,123)]) // 输出 26 个小写字母ord(&apos;a&apos;) // 输出 97，将字母转换为 ASCII 符chr(97) // 输出 a ，将 ASCII 符转换为字母 title(): 返回首字母大写的字符串 12s = &apos;glad to meet you&apos;print(s.title()) // Glad To Meet You 列表的元素删除 123list = [1,2,3,9,7,6]list.pop(2) // 删除第 3 个数list.remove(6) // 删除值为 6 的元素 while k in arr 和 if k in arr 1一个会循环所有值为 k 的元素；后者只找到第一个值为 k 的元素 sys 模块 1234import sysfor line in sys.stdin: ...上述语句可以从 pycharm 控制台不断读取 input 输入，直到按 Ctrl + D 停止 函数 zip() :将对象中对应的元素打包成元组 123a = [1,2,3]b = [4,5,6]zip(a,b) // [(1,4),(2,5),(3,6)] 遍历矩阵输出矩阵的每一个数 1234s_mtx = [] // 这是一个矩阵// 按照顺序输出每一行中的每一个数for c in range(3): print(s_mtx[0][c], s_mtx[1][c], s_mtx[2][c], end = &apos; &apos;) 求绝对值函数 fabs() 和 abs() 12fabs() 是在 math 模块中定义的，需要导入；而 abs() 函数是内置函数；fabs() 只适用于 float 和 integer 类型，而 abs() 也可以适用于复数 EOFError 报错解决方法 1234try: ...except EOFError: break operator.itemgetter 模块：可以获取对象的某些维数据 1234567from operator import itemgettera = [1,2,3]fetch = itemgetter(1)fetch(a) // 取出第二个数，即为 2fetch2 = itemgetter(2,1)fetch2(a) // 取出位置为 2 和 1 的数并交换位置，即为 3,2// 可以作为 key 传递给 sorted() 函数排序 reverse() 和 reversed() 12reverse() 方法用于列表，可以反转一个列表的顺序reversed() 方法是一个反转迭代器，其参数可以是列表、字符串或者 range 读取一个文件, 假设文件名为 file.txt 12345with open(&apos;file.txt&apos;) as js: for line in js: // 对文件内容中的每一行进行操作 ... // 也可以将所有内容读取出来，存放到 content 里 content = js.read() 将结果写入一个文件，假设文件名为 result.txt，结果是一个列表 arr 123with open(&apos;result.txt&apos;,&apos;w&apos;) as jg: for r in arr: jg.write(r)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.brightlam.top/tags/python/"}]},{"title":"JavaScript 学习之路-语法篇(中)","slug":"JavaScript-学习之路-语法篇-中","date":"2018-12-08T08:16:46.000Z","updated":"2018-12-08T08:17:46.446Z","comments":true,"path":"2018/12/08/JavaScript-学习之路-语法篇-中/","link":"","permalink":"http://www.brightlam.top/2018/12/08/JavaScript-学习之路-语法篇-中/","excerpt":"","text":"上篇文章分享了 JavaScript 的基本语法、严格模式的启用，还有变量、五大基本数据类型以及所定义的一些关键字保留字等。在这篇文章里，你可以了解到 JavaScript 中的各类操作符，这些操作符有些很熟悉，一直在用，有些可能平时不太注意，但也会多少用到。 花式操作符操作符，顾名思义，就是对数据进行操作。JavaScript 能参与运算的操作符很多，有一元操作符、位操作符、乘性操作符等等，接下来一一介绍下这些操作符，很多都是挺熟悉经常在用的。 一元操作符最基本的就是一元操作符，意思是只能操作一个数值。我们最常见到的就是 ++ 和 -- 了，它可以对一个数进行递增或递减。看下面的例子：12var num = 1;++num; // 2 也可写成 num = num + 1 是一样的效果，相应地，-- 操作符就是 --num 或 num = num - 1 。这里特别要注意的是两个操作符的放置位置：如果在变量前面，则先自增/自减再去执行语句操作，而如果在后面，则先执行语句，完了在自增/自减。来看下面的例子：12345var a = 10;var b = 2;var c = --a + b // 11，a 先减去1在加 bvar d = a-- + b // 11, 由于上条语句 --a 使得 a 变成 9 ，在加 b 等于 11console.log(a) // 此时 a 已经是 8 仔细体会下上面语句的执行结果，就能明白 ++ 和 -- 在变量的不同位置其效果是不一样的。 除此之外，还有一元操作符 + 和 - ,普通的加减都知道的了。这里需要注意的是这两个符号可以用来转换数据类型。看例子：123456789101112var a = false;var b = 1;var c = &#123; valueOf: function() &#123; return -1; &#125;&#125;+a // 0+b // 1-b // -1+c // -1-c // 1 这种隐式转换在写代码时经常用到。 位操作符~ 表示按位非，它会对一个数的二进制进行操作，返回它的反码，最终得到的结果就是原数值的负值减 1。所以 ~25 的结果就是 -26，那为什么不直接对 25 取负值然后在减 1 不就好了？也是可以的，但是用 ~ 操作符是在计算机底层进行二进制操作，所以速度更快，追求性能的话首选。 &amp; 表示按位与，同样是二进制操作。只有当两个数位同时为 1 时才返回 1，其余都都返回 0 。例如求 25 &amp; 3，先把 25 和 3 分别以二进制表示，我们知道二进制只有 0 和 1 两个表示，将它们对应的位进行运算，同时为 1 则返回 1，否则都是 0 ，最后将得到的二进制数重新翻译成十进制就得到结果了。 | 表示按位或，与 &amp; 类似的二进制操作，不过这次是只有当两个位数同时为 0 才返回 0，其余都会返回 1。所以求 25 | 3，你不妨写几句代码，运行下看看是什么结果，上次说了，用 toString(n) 方法可以返回一个数的 n 进制表示。 ^ 按位异或，与 | 的不同在于，只有当两个数位同时为 1 或 同时为 0 时会返回 0，其余都返回 1 。 &lt;&lt; 左移操作符，将一个数向左移动得到的结果，移动后的空位会以 0 来填充。例如求 2 &lt;&lt; 5 ，2 的二进制是 10，向左移动 5 为，就相当于在后面补 5 个 0，得到 10 00000 转换成十进制就是 64，所以 2 &lt;&lt; 5 就是 64。 &gt;&gt; 右移运算符，将一个数向右移动得到的结果，移动后的空位会以符号位来填充。例如将上面的 64 &gt;&gt; 5 就相当于让 10 00000 向右移动五位，就是 10 ，左边空出来的位以符号位 0 填充，可以忽略，所以得到的结果是 2 。 &gt;&gt;&gt; 无符号右移，跟 &gt;&gt; 一样，只不过它移动后的空位会以0来填充，所以右移后的数值会非常大，具体可以自己去用代码验证下。 布尔操作符布尔符应该很熟悉了，有 3 个，分别是非!，逻辑与&amp;&amp; 和逻辑或||。 ! 取反符，将一个数值转换为布尔值，在取反。所以!true 等于 false，!0 等于 true 等等。这个符号经常用在 if 等语句中。 &amp;&amp; 逻辑与，当且仅当两个值都为 true 时才返回 true，其余都返回 false 。经常用在 if 语句的条件判断中，也就是两个条件都要满足时才予以执行。它是短路操作符，也就是说，如果第一个值是 false 了，那么第二个值无论是什么，都不会再去求它，结果已经是返回 false 了。 || 逻辑或，也是短路操作符，当且仅当两个值都为 false 时才返回 false，其余情况都会返回 true。这个操作符大有用处，在定义变量的时候，经常会用到下面这条语句：1var str = result || &apos;&apos;; 这条语句的意思是优先把这个 result 的值赋给 str，如果找不到它，那就默认赋个空字符串给它，这样就避免了值为 undefined 或 null，从而避免遇到执行错误。 乘性操作符这个同样很熟悉，三个乘性操作符分别为 *，/ 以及 % 。关于乘和除，平常用的够多了，就跟数学的乘除一样，需要注意的就是一些特殊情况，如 NaN 值，infinity 值以及非数值如字符串，这些参与乘除运算会出现什么样的结果，你可以动手去试下，印象会更深。 % 对一个数进行求模。举个例子，21 % 5 会得到 1，为什么呢？21 除以 5 不能整除，只能得到商 4，最后余数为 1，所以记住 % 操作符就是去取余数。那请问 2 % 5 会得到多少？你可以去试下。 加性操作符就两个符号，+ 和 - 。跟数学的加减一样，但比较有意思的是涉及到非数值类型，如字符串，看看下面的代码12var result = 5 + &apos;5&apos;;console.log(result); // &apos;55&apos; 是的，你没看错，5 去加字符串的 5 ，最终得到的是 55 ，这个 55 是字符串的 55 ，也就是说，解释器先将第一个数值转换成了字符串，然后在与第二个字符串想 +，最终得到的是一个拼接的字符串，所以是 &#39;55&#39; 。 而对于减法符号 -，就不一样了，前面提到的将数值转换成字符串在进行加，而如果一个数值去跟一个字符串数值相减，结果不会是字符串，而是一个正常的数值，例如 5 - &#39;5&#39; 会得到 0，解释器将后面的字符串转成了数值，然后进行相减。所以，- 操作符用处很大，它可以进行隐式转换，即将一个字符串转成数值，不必去调用方法，只需一个符合就行。 关系操作符关系操作符有 &lt; 和 &gt; 以及 &gt;= ，&lt;= 。它们的用处是比较两个字符串或数字之间的大小，对于字符串而言，比较是按照字符串编码值来，所以会出现 &quot;Brick&quot; &lt; &quot;apple&quot;，为什么会这样呢？因为 ASCII 编码中大写字母 A 是从数字 65 开始计的，而小写字母 a 从 91 开始，因为「B」的编码数值小于「a」，所以&quot;Brick&quot; &lt; &quot;apple&quot;，解决方法是使用 toLowerCase() 转换大小写在比较；对于数值而言，同样会出现如 &quot;23&quot; &lt; &quot;3&quot; 这样子，因为 2 &lt; 3 而导致的，解决方法是转换为基本数据类型中的 Number 类型进行比较。 相等操作符分为相等 == 和全等 === 两个操作符。前者会自动转换数据类型进行比较，例如 &quot;5&quot; == 5 返回结果为 true，因为字符串会被转换为数值然后参与比较；而如果是 &quot;5&quot; === 5 就是 false 了，=== 不会进行类型的转换，该怎么比较就怎么比较，这也是我们想要的结果，所以比较推荐使用全等符。 条件操作符compare? result1:result2;俗称三目运算符，意思是执行这个 compare 语句，如果为 true 的话返回 result1 ，否则返回 result2。相信你已经猜到了，它可以适时替代掉 if - else 语句，有相同的效果。 赋值操作符分别是 = 和 += ，用来赋值的符号，后者 += 在用的时候例如 x += 1，与 x = x + 1 是一样的，设计这个符号就是为了简化操作，没什么特别的地方。 逗号操作符逗号操作符可以用来声明多个变量，比如连续声明四五个变量：12345var x = 0, y = 0, z = 0, num = 0, count = 0; 很方便地声明变量而不用写多条语句。特别注意的是，假如你同时给一个变量赋了多个值，最终保留最后一个，所以 var num = (5,4,2,3,0) ,最终 num 的值就是 0 。 未完待续… … 参考资料 《JavaScript 高级程序设计》 [美] Nicholas C.Zakas 著","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"JavaScript 学习之路-语法篇(上)","slug":"JavaScript-学习之路-语法篇-上","date":"2018-12-01T09:44:00.000Z","updated":"2018-12-01T09:44:58.824Z","comments":true,"path":"2018/12/01/JavaScript-学习之路-语法篇-上/","link":"","permalink":"http://www.brightlam.top/2018/12/01/JavaScript-学习之路-语法篇-上/","excerpt":"","text":"上篇文章介绍了 JavaScript 的基本概念和发展概况，这篇文章将开始讲 JavaScript 的一些基本语法概念。 前言学一门编程语言，首先无非就是了解它的基本语法，例如变量、标识符、关键字、数据类型以及函数等等，然后应用这些东西去写出你相要的程序，当然程序也分很多种，就像只输出一句hello world也是一个程序对吧。那么这些在 JavaScript 里是如何规定和体现的呢？ 语法(不基于 ES6)JavaScript 是区分大小写的，所以 May 和 may 是两个不同的变量名称。当使用变量时，一般驼峰式的命名写法，例如定义一个打招呼的变量是这样 var sayHello = &#39;hello world;&#39; ，当然并没有强制规定要这样写。这里的 sayHello 称作 标识符 ，标识符的第一个字符必须是字母、下划线或者 $ ,这意味着你不能命名一个变量诸如 12say 或者 ^hello 等等，另外也不能用一些关键字作为标识符，否则都会报错。所以，养成一个良好的命名习惯很有必要，多用一些英文字符命名，实在不会英文可以用拼音代替，并且尽量避开一些关键字和保留字。关于关键字和保留字下面会提到。 当你写了 var sayHello = &quot;hello world&quot;; 时，实际上就写了一条语句 。语句是我们能看懂的编程代码，它会被编译成计算机能识别的二进制代码，浏览器去解释执行这些代码就会有效果出来，比如上面那句在加上一条打印输出语句console.log(sayHello); 就能在控制台输出你经常看到的 hello world 了。当你想注释掉语句怎么办？JS 里的注释跟大多语言类似，单行注释采用 //，多行注释用 /* 这里是需要注释的内容 */ 就可以实现。 严格模式ES5 新引入了严格模式这一概念，在严格模式里，很多内容都作出了完整规范的限制，比如你像前面一样声明一个 sayHello 变量时，如果前面没有 var 关键字，那运行就会报错，为何这样呢？因为浏览器不懂它到底是干嘛的，你在前面加上 var ，浏览器会明白它是一个变量，加上 const 关键字，浏览器会懂它是一个不可变的常量，所以你什么都不说，让别人去猜，它肯定就不鸟你了，这解释纯属瞎猜瞎扯，可以听听，切莫当真。想要启用严格模式，只需在你的 js 文件里加上下面这句代码：1&quot;use strict&quot;; 浏览器就能严格的目光来看待所有内容了，这个模式是被建议采用的，这样可以避免一些不必要的错误发生，可以先了解下。 关键字和保留字这类单词通常具有某种用途，比如前面说到的 var 和 const 分别是用来定义变量和常量的，所以不能用他们做标识符，以免不必要的冲突。常用的关键字有以下这些：1234break do instanceof typeof case else new varcatch finally return void continue for switch whiledebugger function this with default if throw deletein try 而保留字，顾名思义，就是保留着，将来可能也会被用作关键字，因此最好也不要用它们。ECMA-262 第 3 版定义的保留字有：1234abstract enum int short boolean export interface static byteextends long super char final native synchronized class float package throws const goto private transient debugger implements protectedvolatile double import public 这些关键字和保留字不用时时刻刻去记住它，多熟悉下，用到的时候去查查其实也不浪费多少时间，像这些就肯定不能用作变量名称来命名了，看着都别扭。 变量JavaScript 的变量相比 java，c 等语言来说是相对轻松的。你可以随意定义变量的内容和类型，不用像 java 那般去区别是整型还是浮点型还是字符串类型等。像声明一个数组：123456var arr = [1,&apos;hello&apos;,undefined,&apos;15&apos;,8];console.log(arr); // [1, &quot;hello&quot;, undefined, &quot;15&quot;, 8]var str = &quot;hello world&quot;;str = 100;console.log(str); // 100 是可以的，简直就是大杂烩啊有没有，各种类型都可以放上去，可以说语法是很松散的。第二个例子中先是给 str 赋了一个字符串型，然后又把它改成了数字类型，仍然正常输出了。 数据类型上面提到的「字符串」、「数字」等就是所谓的 数据类型 。像 java 有八大基本数据类型，在 JavaScript 里，有五大基本数据类型：undefined，null，Boolean，Number ，String .这些基本数据类型可以用 typeof 操作符来检测。下面看看例子：1234567typeof &apos;hello world&apos; // stringtypeof 20 // numbertypeof null // objecttypeof &quot;hello&quot; // stringtypeof true // booleantypeof 2.3 // numbertypeof undefined // undefined 从上面的测试中我们可以总结出，JavaScript 字符串不分单双引号；数字不分浮点型或者整型，全部为 number 型；对 null 检测类型为 object 对象；对 undefined 检测为 undefined 。 undefined 通常是一个变量声明了但没有赋值，那么它的值就是 undefined，所以你对代码 var str 进行 typeof 就会得到 undefined 。 null 跟 undefined 有着千丝万缕的关系，比较奇妙的就是运行 undefined == null 时会返回 true 。通常认为他们两个是相等的，但如果是全等符 === 就会返回 false 了。前面为什么对 null 应用 typeof 会返回 object 呢？因为 JavaScript 解释器认为 null 是一个空的对象的引用，觉得它是个对象，只是被置为空了。 Boolean 应该很熟悉了，有两个值 true 或 false ，这两个值是区分大小写的，所以你不能把 true 写成 True ，这是隔壁 python 的写法。很多基本类型都可以转换成布尔值，例如非空字符串会转成 true，非零数字会转 true，而空字符串和 0、NaN 等都等同于 false 。除此之外，还有对象 object 也会转 true ，相应的 null 对象则是 false 。 Number 类型应用广泛，有整数和浮点数等等。需要特别记住的是 JavaScript 中浮点数的最高精度是 17 位小数，但在进行算术运算时往往精度会不如预期，所以你会看到 0.1 + 0.2 == 0.3 是 false ，这也是面试中经常会问到的点，0.1 和 0.2 相加是不等于 0.3 的！另外值得注意的是 NaN，它表示的是应该返回数值但却没有返回，通常在其他语言中发生这样都会直接报错，导致程序停止运行，而 JS 不会，它会返回 NaN，让程序继续运行。比如你弄数值弄着弄着搞出个字符串类型，这不是搞笑么，所以返回个 NaN，你自己体会。 String 类型同样经常遇到，声明字符串可以单引号也可以双引号，它采用的是 Unicode 字符编码。字符串有个 length 属性，可以返回长度。还有想要连接两个字符串的话，可以用 + 连接。例如下面这样12var s = &apos;hello&apos;;console.log(s + &apos; world&apos;); // hello world 它还有个常用的 toString() 方法，可以将其他值转换为字符串，这里典型应用就是可以输出数值的二进制表示等等。1234var num = 10;console.log(num.toString()); // &quot;10&quot;console.log(num.toString(2)); // 1010console.log(num.toString(16)); // a 可以看到，在 toString() 传入一个相应的数字就能转换成几进制的值。默认是转换成十进制的。 未完待续… …","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"JavaScript 学习之路-起步","slug":"JavaScript-学习之路-起步","date":"2018-11-25T10:18:01.000Z","updated":"2018-11-25T11:55:23.938Z","comments":true,"path":"2018/11/25/JavaScript-学习之路-起步/","link":"","permalink":"http://www.brightlam.top/2018/11/25/JavaScript-学习之路-起步/","excerpt":"","text":"这是一篇讲 JavaScript 基础的文章，接下来会更新这个系列文章。 JavaScript 诞生于 1995 年，至今已经有 20 几年了，在最新的 JavaScript 2018 年度报告 中，许多人依旧认为这门语言正在朝着好的方向去发展，从最开始的默默无闻到如今的未来可期，JavaScript 作为前端开发者的一门学习语言，一定会被更多爱好编程的人喜欢。如果想了解和学习 JavaScript，请往下看。 ECMAScript在了解 JavaScript 前，首先要了解 ECMAScript ，它是由 ECMA-262 定义的一门语言。它规定了一些基本的语法、变量、语句、操作符以及对象等等内容，而 JavaScript 去实现了它，也就是说，JavaScript 去实现了 ECMAScript，我们经常说 JS 的新版本，实际上是 ECMAScript 的新版本，最被人经常用的是第五个版本(ES5) 还有ES6，它包含了许多新知识新特性。简而言之，JavaScript 的概念更广，它包含了 ECMAScript ，除此之外还有文档对象模型 (DOM) 和浏览器对象模型 (BOM) 。 两种使用方式不同于其它编程语言，JavaScript 内嵌于浏览器中，许多主流浏览器都支持 JavaScript。打开 Chrome 浏览器，按 F12 或鼠标右键选择审查元素，就可以看到控制台，在控制台上就可以书写 JS 代码，例如你可以在控制台输入console.log(&#39;hello world!&#39;);就可以看到下方出现了一句熟悉hello world!。 这是写 JS 代码最快速便捷的方式，但一般我们都是在编辑器中完整地完成整个项目，关于编辑器各人有各人的爱好，稍后会列出常用的几个编写 JS 代码的编辑器。 来到了编辑器中，我们新建一个后缀名为 .html 的文件，在里面写有关 JS 的代码，如果你连 HTML 都不认识，可以到 w3school 去在线学习基础的 HTML 知识。不出所料，一个基本的 html 文件的头应该是下面这样的：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 这里是内容代码 --&gt;&lt;/body&gt;&lt;/html&gt; JavaScript 使用 标签来嵌套代码，所有的 JS 相关的代码都放在里面，而 标签可以放在 中，也可放在 中，最好放在后者，因为浏览器解析时是从上至下解析这段代码，放在 中很容易因为解析慢而导致下方 中的内容未渲染出来，从而影响用户体验。 有几个常用的属性，最常看到的就是 type 和 src 了，type 属性顾名思义，指定了属性含义，常用值是text/javascript，让人知道这里面写的都是 JavaScript 类型的标签代码；src 属性也是经常看见的，指定了一个外部的 href 链接，JavaScript 有两种引入方式，一种是直接在 标签里面写代码，另外一种就是创建一个后缀名为 .js 的文件，然后通过 src 链接进来使用。 标签有一个 defer 属性，这个属性的作用是告诉浏览器等所有内容都解析完后再来执行这个脚本，也就是起到一个延迟执行脚本的作用。 标签还有一个 async 属性，适用于外部引入的 .js 文件，作用是告诉浏览器不比等它执行，可以异步先去加载其它内容。 以上几个属性的使用方式如下：123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;××.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; async src=&quot;××.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 这里是内容代码 --&gt;&lt;/body&gt;&lt;/html&gt; 文档模式 IE5.5 开始引入了文档模式这个概念，它会影响 css 内容的呈现，也会一定程度上影响到 JavaScript 的执行。文档模式只需要记住有混杂模式和标准模式两个，在混杂模式下，不同浏览器下执行的会有很大差异，因此不被人所推荐，一般都是用的标准模式，这个标准模式我们也很熟悉了，就是在 html 文件经常看到的1&lt;!DOCTYPE html&gt; 标签当遇到浏览器不支持 JavaScript 脚本或者脚本被禁用了怎么办？这时候可以用到 标签，它会在浏览器不支持 JS 脚本时候显示，而其他情况下不会有什么影响，所以为了用户体验，可以在代码里加上12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这里是内容代码 --&gt; &lt;noscript&gt; &lt;p&gt;您的浏览器不支持 JavaScript ，请升级。&lt;/p&gt; &lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt; 这样，当遇到不支持 JS 时，这段文字就会显示出来，提醒用户升级或更换浏览器。 编辑器最后，有许多可以编写 JavaScript 代码的软件。就我知道的有以下这些： WebStorm PhpStorm Sublime Text VS code Dreamweaver HBuilder 以上这几个软件基本都用过，现在在用 PhpStorm ，它跟 WebStorm 差不多，只不过多了对 php 文件的支持，很多人都是用的 WebStorm ，它代码提示等做得很好，页面看起来也还行，缺点应该是打开的时候挺慢，最重要的是，时不时地就过期需要去找注册码，当然，有条件的话还是付费支持正版的好，听说学生去申请可以有授权使用，不过太麻烦了懒得去弄。 欢迎批评指正！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"你可能不知道的两个CSS属性","slug":"你可能不知道的两个CSS属性","date":"2018-11-11T09:48:43.000Z","updated":"2018-11-11T12:24:18.795Z","comments":true,"path":"2018/11/11/你可能不知道的两个CSS属性/","link":"","permalink":"http://www.brightlam.top/2018/11/11/你可能不知道的两个CSS属性/","excerpt":"","text":"今天是双十一，不知道各位剁手了没有，每年的狂欢节全民都在烧钱，在这里也温馨提醒大家：赶紧准备好土，该吃土了！话说自从知道马云和他的淘宝后，我拥有了一辆车——购物车，也终于认识到自己最大的不足——余额不足，所以这个双十一什么都没有买，听说今年仅 2 分 05 秒交易额就破百亿，一不小心错失参与一个百亿大项目，真是遗憾啊！ 言归正传，这次要介绍的两个属性就是 css 中改变水平流向的direction属性和改变文本流的writing-mode属性，如果你没听过这两个属性，那正好学习下，没准以后会遇到它们。 direction这个属性的兼容性特别好，所有浏览器包括 IE 都支持它，w3school 对该属性的介绍是规定文本的方向 / 书写方向。简单讲就是让文字从左向右还是从右向左显示，所以它有以下两个属性值 direction: ltr | rtl ; 默认值是 ltr，也就是 left-to-right，表示文字从左至右显示，很形象好记。它可以让图片或者按钮不按原本顺序显示，例如下面的例子 代码如下:1234&lt;div dir=&quot;rtl&quot;&gt; &lt;img src=&quot;elephant.jpg&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;boy.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; 本来正常大象的图片 img 标签在男孩之前，但是因为我们设置了dir=&quot;rtl&quot;这是写在元素标签的缩写方法，也可以在 css 中写成direction: rtl，所以水平流向的顺序改变了，现在是从右往左，所以上面的图片显示男孩在大象图片的左边。通过这个例子现在知道 direction 的用处了，但是如果你把 div 里的内容换成文字，此时这个属性就不起作用了，你看不到什么反转的效果，这就需要介绍接下来的这个unicode-bidi属性 unicode-bidi: bidi-override; direction: rtl只能作用于图片或者按钮标签，而上面这个属性的作用就是对文字起作用的，多说无益，来看下实现效果。123&lt;div dir=&quot;rtl&quot;&gt; 我是 Light Lin，欢迎来到我的公众号&lt;/div&gt; 在浏览器的效果是这样 我们现在修改下代码12345678910&lt;head&gt; &lt;style&gt; div&#123; unicode-bidi: bidi-override; &#125; &lt;/style&gt;&lt;/head&gt;&lt;div dir=&quot;rtl&quot;&gt; 我是 Light Lin，欢迎来到我的公众号&lt;/div&gt; 运行出来后是这个效果 可以看到，有了unicode-bidi: bidi-override; 的作用，现在文字已经能改变水平流向了，关于该属性的更多详细信息可以去网上查阅。 writing-mode这个属性同样兼容性非常好，浏览器都支持它。MDN文档说它定义了文本水平或垂直排布以及在块级元素中文本的行进方向。它的主要取值有以下几个123456789// 关键字writing-mode: horizontal-tb;writing-mode: vertical-rl;writing-mode: vertical-lr;// 全局属性值writing-mode: inherit;writing-mode: initial;writing-mode: unset; horizontal-tb 默认值，表示了文本是水平方向（horizontal）的，从上至下堆叠（top-bottom）。vertical-rl 表示了文本是垂直方向的，从右往左堆叠。vertical-lr 表示了文本是垂直方向的，从左往右堆叠。看看下面的例子123&lt;div style=&quot;writing-mode: horizontal-tb&quot;&gt; 我是 Light Lin，欢迎&lt;br&gt;来到我的公众号和博客,&lt;br&gt;现在是默认显示&lt;/div&gt; 运行截图如下 现在改改代码，换下 css 值123&lt;div style=&quot;writing-mode: vertical-rl&quot;&gt; 我是 Light Lin，欢迎&lt;br&gt;来到我的公众号和博客,&lt;br&gt;现在是从右往左显示&lt;/div&gt; 效果变成了下面这样 在改下代码，看看又变了什么123&lt;div style=&quot;writing-mode: vertical-lr&quot;&gt; 我是 Light Lin，欢迎&lt;br&gt;来到我的公众号和博客,&lt;br&gt;现在是从左往右显示&lt;/div&gt; 通过上面这三个效果演示，应该就能理解writing-mode以及它的三个属性值的作用效果了，有没发现第二种从右往左实际上就是古诗词的排版方式？值得注意的是，在 IE 浏览器里有另外的一套写法，如下 writing-mode: lr-tb; // 相当于默认值 horizontal-tbwriting-mode: tb-rl; // 相当于 vertical-rl IE 浏览器里支持的不止上面这两个，多达 11 个，感兴趣的可以上网去查阅更多。 总结css 有很多很多属性值，writing-mode 和 direction 平常可能比较少见，但是我们学习东西就是要广泛涉猎，虽然现在对它们的实际应用知道得较少，但说不定以后的某天就用到并解决问题了呢，所以先好好认识下他们吧！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.brightlam.top/tags/CSS/"}]},{"title":"CSS @font face 的使用","slug":"CSS-font-face-的使用","date":"2018-11-04T11:15:17.000Z","updated":"2018-11-04T11:16:01.315Z","comments":true,"path":"2018/11/04/CSS-font-face-的使用/","link":"","permalink":"http://www.brightlam.top/2018/11/04/CSS-font-face-的使用/","excerpt":"","text":"在网页开发中，可以在 CSS 中设置font-family来指定对应的字体，通常我们都是用微软雅黑。有时，如果对电脑上有的字体都不满意怎么办？我们可以通过自定义字体，自己引入字体文件，来使用它。@font face就是做这种工作的，它可以让你在font-family的值上输入自己定义的字体名称，你甚至还能将「微软雅黑」这个名称替换成别的字体。 CSS字体家族在开始之前，简单介绍下 css 的字体家族，只要涉及到文字都离不开它们，它们分别是fonr-family，font-size，font-weight，font-style，font-variant以及font。 font-family 应该很熟悉，定义文字使用什么字体，常见的是微软雅黑，宋体以及英文字体 Arial。字体又分为衬线字体和无衬线字体，区别是两种字体的装饰和粗细不同，微软雅黑属于无衬线字体。为了各个浏览器的兼容性，尽量写成英文名称比较好，如 123font-family: &apos;Microsoft Yahei&apos;，sans-serif;font-family: &apos;simsun&apos;; // 宋体font-family: &apos;Arial&apos;; font-weight 定义文字的粗细程度，也就是字重。支持的属性值有很多，如下 12345678fonr-weight: normal;font-weight: bold; // 粗体font-weight: lighter; // 相对父级而言font-weight: bolder; // 相对父级而言/* font-weight 还支持数值，分为三档 */font-weight: 400 // 等同于 normal，在 400 之前的数值很轻，数值越小越轻越细font-weight: 700 // 等同 bold，500 和 600 两个数值介于之间font-weight: 900 // 最大值，字体最粗 这里有个很值得我们注意的点，就是我们经常在使用中发现无论设置 100、200、400 都没什么效果，好像只有 normal 和 bold 两个值有用，那是因为我们平常使用的字体通常是微软雅黑，它只有normal和bold两个值，所以你设置其它的数值没什么效果，实际上它是有用的。 font-size 这个很熟悉了，定义字体的大小，你想设置多少 px 都行，或者使用其它单位 em，rem，vh 等。 font-style 定义文字的样式。有如下属性值: 123font-style: normal; font-style: italic; // 文字使用其 font-family 对应的倾斜字体font-style: oblique; // 单纯地让文字倾斜 font-variant 一个用处不大的属性，有两个值normal和small-caps,设置font-variant: small-caps可以让字符跟小写字母一样大小，但样式是大写字母 font 上面这些样式的缩写，例如可以让文字大小和行高缩写为font: 24px/32px &#39;Microsoft Yahei&#39;@font face 语法实际上，@font face 这个名称已经很类似 css 的变量了，根据 MDN 文档，@font face 有以下几个主要属性： font-family: 引入字体文件的取值名称，可以是 ‘$’ 或空格，该名字将被用于 font 或 font-family 属性。 src: 字体文件地址，用 local() 表示当前系统内的字体，用 url() 表示外链的字体，通常后者用得较多 font-weight: 字重，这个属性的用处在于，比如你引入了同一个字体，但是设置了不同的 font-weight ，可以在不同的情况采用不同的字重 font-style: 和 font-weight 一样，当设置了不同的值，就可以决定在这个字体下是采用正常样式还是倾斜字体，因为 font-style: italic 让字体变斜体 unicode-range: 使用特定的 unicode 字体范围 实例HTML12&lt;p class=&quot;normal&quot;&gt;正常的微软雅黑文本&lt;/p&gt;&lt;p class=&quot;test&quot;&gt;这是一段自定义字体文本&lt;/p&gt; CSS12345678910@font-face &#123; font-family: &quot;myfont&quot;; src: url(&quot;http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf&quot;);&#125;.test&#123; font-family: &quot;myfont&quot;,serif;&#125;.normal&#123; font-family: &quot;Microsoft YaHei&quot;,sans-serif;&#125; 可以自己运行看看效果，两段文字的字体是不同的。 总结css 有关文字这块有许多属性，除上面提到的一些基本属性外，其实还有很多，例如letter-spacing控制字间距，white-space定义文字遇到空格如何换行，还有word-break，text-indent等等，这些属性平常见得不多，但是在一些情况下很有用。最后还有对@font face的认识。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.brightlam.top/tags/CSS/"}]},{"title":"css 实现元素水平垂直居中的几种方法","slug":"css-实现元素水平垂直居中的几种方法","date":"2018-10-28T09:38:56.000Z","updated":"2018-10-28T09:40:18.774Z","comments":true,"path":"2018/10/28/css-实现元素水平垂直居中的几种方法/","link":"","permalink":"http://www.brightlam.top/2018/10/28/css-实现元素水平垂直居中的几种方法/","excerpt":"","text":"在做网页的时候经常会需要让某一个元素水平垂直居中，而要实现水平垂直居中有很多种方法，不知道你们有没遇到这种情况：方法倒是知道，甚至还知道许多种，可一到真正用到的时候，却突然在努力地回想，这或许就是人们经常说的「脑子短路」，所以，这篇文章和大家一起来温故而知新，梳理一下常见的几种元素水平垂直居中的方法，以后突然短路了，就翻出来看一看，而且万一以后面试就问到了，那就更好不过了。 div 元素的水平垂直居中让一个 div 元素水平垂直居中，有很多种方法。 最先想到的就是使用绝对定位 + margin: auto的实现方式，这也是最靠谱的一种实现方式，兼容性还不错。为什么说它靠谱呢？因为它利用了 css 流体的特性，即页面的默认文档流是自上而下，自左向右。我们先来看下它的实现代码：HTML代码123&lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS代码1234567891011121314151617.dialog&#123; width: 500px; height: 500px; background-color: #cccccc; position: relative;&#125;.text&#123; width: 200px; height: 200px; background-color: #e8491d; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125; 效果如下 中间的色块已居中 此方法对父元素使用相对定位，然后子元素使用绝对定位，这样子元素将相对父元素进行定位，接着设置各个方向的 left/top/right/bottom 为 0，再设置 margin: auto ，然后就非常巧妙了：把它的各个定位值置为 0 后，剩下的空间交由 margin 去自动分配，由于流特性，它将均匀评分剩下的空间，于是便水平垂直地居中了。 上面这种方法推荐使用，除此之外还有其它方法，相信很多人也经常看到，这里也列举下，有些都差不多，只是属性的不同使用。 第二种是已知宽度，margin 负值的方法，代码如下：HTML代码123&lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS代码12345678910111213141516.dialog&#123; width: 500px; height: 500px; background-color: #cccccc; position: relative;&#125;.text&#123; width: 200px; height: 200px; background-color: #e8491d; position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -100px;&#125; 效果跟上面的是一样的，有种像把人往右和往下拽，然后有拉回来对准的感觉，可以试试。 第三种跟第一种差不多，只不过把 margin 换成了 transform 属性，代码如下：HTML代码123&lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS代码123456789101112131415.dialog&#123; width: 500px; height: 500px; background-color: #cccccc; position: relative;&#125;.text&#123; width: 200px; height: 200px; background-color: #e8491d; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);&#125; 效果依旧是一样的。有没发现代码很相似，只改了一句transform: translate(-50%,-50%);实际上这样就不用去知道已知元素的宽度了，直接用 transform 的 translate 来移动。 第四种是 flex 布局，关于 flex 布局之前的博客文章也有做过简单的介绍，这里就不再赘述，忘记了的戳这篇 CSS布局之 flex 布局 ，如何实现呢，代码如下：HTML代码123&lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS代码12345678910111213.dialog&#123; width: 500px; height: 500px; background-color: #cccccc; display: flex; justify-content: center; align-items: center;&#125;.text&#123; width: 200px; height: 200px; background-color: #e8491d;&#125; 效果同见最上面的那张图，这次的代码不一样了，不一样在哪里呢？flex 布局针对的是父元素，可以看到，在父元素的 div 中写的居中代码，子元素不需要写什么，躺着居中就可以了，不过个人觉得 flex 布局真正用到的时候不止是实现这么简单的布局，它可以实现用更简洁的代码实现更多常见的布局。 第五种是使用 table 布局，这种不推荐使用，主要上面有那么多种方法，没必要用到这种，具体原理是给父元素设置display:table，子元素设置display:table-cell，table-cell 相当于表格中的 ，再结合vertical-align: middle 即可。HTML代码12345&lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS代码123456789101112131415161718.dialog&#123; width: 500px; height: 500px; background-color: #cccccc; display: table;&#125;.text&#123; background-color: #e8491d; display: table-cell; text-align: center; vertical-align: middle;&#125;.son&#123; background-color: #d0d6d9; display: inline-block; width: 200px; height: 200px;&#125; 效果如下，这个效果跟上面那张有些许不一样，仔细瞧瞧代码跟背景色。 如图 内联文字的水平垂直居中上面介绍的几种方法大多更偏向布局之类的水平垂直居中，接下来介绍一种让文字水平居中的方法。我们都知道，让文字水平居中，只需要一行 text-align: center 就可以搞定，那垂直居中呢？我从网上找到了解决方法，可以试试下面这样。 HTML代码12345&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; 这个公众号是一个值得关注的号，不定期会分享一些有关前端类的文章，推荐大家关注，同时点赞转发分享到朋友圈，让更多的人看到。 &lt;/div&gt;&lt;/div&gt; CSS代码123456789101112131415.box&#123; width: 300px; line-height: 220px; background-color: #f4f4f4; margin: auto; font-family: &apos;Microsoft YaHei&apos;,sans-serif; font-size: 14px;&#125;.content&#123; display: inline-block; ine-height: 20px; margin: 0 20px; text-align: center; vertical-align: middle;&#125; 效果如下 总结实现垂直居中的方法有很多，每一种都有各自的实现路径，但是兼容性却是各不相同，感兴趣的可以自己去测试下兼容。如果你有耐心从头看到这里，已经是很不错了，不过，看完可以敲一遍代码过一遍，可能记忆会来得更深刻些，希望这篇文章对你有帮助！","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.brightlam.top/tags/CSS/"}]},{"title":"一些有趣的 CSS demo","slug":"一些有趣的-CSS-demo","date":"2018-10-21T07:43:57.000Z","updated":"2018-10-21T07:44:50.684Z","comments":true,"path":"2018/10/21/一些有趣的-CSS-demo/","link":"","permalink":"http://www.brightlam.top/2018/10/21/一些有趣的-CSS-demo/","excerpt":"","text":"CSS 世界博大精深，写过 css 的都知道，很多时候总是出现一些莫民奇妙的状况，你写的代码最后实现出来跟你预想的完全不同，特别是有时在那里悲催地找原因找了一下午，最后才发现是某个变量某个字符写错而导致，真 skr 惨。今天介绍几个有趣的 css 效果，是从书上看来的，有些可能你以前都没想到这么实现过，可以学习下作者的思路，对你以后写出更好的 css 代码会有帮助。 显示/收缩效果这个效果比较常用到，具体效果如下： gif动图 12345678910/* HTML 代码 */&lt;div class=&quot;demo&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;check&quot; style=&quot;display:none&quot;&gt; &lt;p&gt;HTC 计划在 10 月 22 日推出区块链智能手机&lt;/p&gt; &lt;div class=&quot;element&quot;&gt; &lt;p&gt;该公司一个有趣的发展方向就是决定推出名为 Exodus 的区块链智能手机 ... 该手机制造商在照片分享应用 Instagram 上为这个即将推出的区块链智能手机建造了一个新的页面&lt;/p&gt; &lt;/div&gt; &lt;label for=&quot;check&quot; class=&quot;check-in&quot;&gt;更多↓&lt;/label&gt; &lt;label for=&quot;check&quot; class=&quot;check-out&quot;&gt;收起↑&lt;/label&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526/* CSS 代码 */.demo&#123;width: 200px;padding-left:100px;padding-top: 10px;&#125;.element&#123; width: 200px; padding-top: 15px; max-height: 0; overflow: hidden; transition: max-height .25s;&#125;:checked ~ .element&#123; max-height: 666px;&#125;:checked ~ .check-out&#123; display: block;&#125;:checked ~ .check-in&#123; display: none;&#125;.check-in,.check-out&#123; color: blue; cursor: pointer; margin-top: 15px;&#125;.check-out&#123; display: none;&#125; 正在加载中动画在加载网页时经常会用到这个动画，为了缓解图片文字资源未加载时用来过渡，极大地增强了用户体验，效果大致如下： 正在加载中 12/* HTML 代码 */正在加载中&lt;dot&gt;...&lt;/dot&gt; 1234567891011121314151617181920212223/* CSS 代码 */dot&#123; display: inline-block; height: 1em; line-height: 1; text-align: left; vertical-align: -.25em; overflow: hidden;&#125;dot::before&#123; display: block; content: &apos;...\\A..\\A.&apos;; white-space: pre-wrap; animation: dot 2s infinite step-start both;&#125;@keyframes dot&#123; 33% &#123; transform: translateY(-2em); &#125; 66% &#123; transform: translateY(-1em); &#125;&#125; css 自行实现小图标在日常开发的过程中经常会用到小图标，除了可以去 阿里图标 下载之外，一些较简单的图标可以自己用 css 实现，方法是利用 border 和 background 属性，效果如下： 宽高扩大了 10 倍显示 123/* HTML 代码 */&lt;i class=&quot;icon-menu&quot;&gt;&lt;/i&gt;&lt;i class=&quot;icon-dot&quot;&gt;&lt;/i&gt; 1234567891011121314151617181920/* CSS 代码 */.icon-menu&#123; display: inline-block; width: 140px; height: 10px; padding: 35px 0; border-top: 10px solid; border-bottom: 10px solid; background-color: currentColor; background-clip: content-box; margin: 50px 0 0 100px;&#125;.icon-dot&#123; display: inline-block; width: 100px; height: 100px; padding: 10px; border: 10px solid; border-radius: 50%; background-color: currentColor; background-clip: content-box;&#125; border 实现边框很多时候会遇到需要有一个上传按钮，点击按钮后上传文件，如下面这样的效果： 按钮 此时可以用 a 标签来承载，在通过 border 属性来定义虚线框，利用伪元素来定位，使中间的 + 号能水平垂直居中。12/* HTML 代码 */&lt;a href class=&quot;add&quot; title=&quot;继续上传&quot;&gt;添加图片&lt;/a&gt; 12345678910111213141516171819202122232425262728293031/* css 代码 */.add&#123; display: inline-block; width: 76px; height: 76px; color: #ccc; border: 2px dashed; text-indent: -12em; transition: color .25s; position: relative; overflow: hidden; margin: 50px 100px;&#125;.add:before, .add:after&#123; content: &apos;&apos;; position: absolute; top: 50%; left: 50%;&#125;.add:hover&#123; color: #34538b;&#125;.add::before&#123; width: 20px; border-top: 4px solid; margin: -2px 0 0 -10px;&#125;.add::after&#123; height: 20px; border-left: 4px solid; margin: -10px 0 0 -2px;&#125; 纯 css 实现自适应的弹框弹框，也就是 dialog ，经常也是在网页中看到，例如有些网页点击登录注册时就会跳出一个弹框来显示登录注册页面，而下面的效果是使用 css 完成的，并且可以自适应，无论窗口的大小，始终能保持水平垂直居中，很好的一个实现方法。 水平垂直居中弹框 12345678/* HTML 代码 */&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;content&quot;&gt; 我是内容 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728/* css 代码 */.container&#123; position: fixed; top:0; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,.5); text-align: center; white-space: nowrap; z-index: 99;&#125;.container:after&#123; content: &apos;&apos;; display: inline-block; height: 100%; vertical-align: middle;&#125;.dialog&#123; background-color: #fff; display: inline-block; vertical-align: middle; border-radius: 6px; text-align: left; white-space: normal; width: 400px; height: 250px;&#125; 参考资料张鑫旭——《 css 世界》 PS：最近 Chrome 70 正式发布了，不得不说，谷歌这波更新的真快，不过我下载体验了一下，整体跟 69 版本没什么大的变化，至于新增的那些画中画、拖拽 API 什么的目前也没用得上什么，感兴趣的直接去 官网 下载最新的版本就好，目前只有桌面版，移动端版本的还要等些时间。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.brightlam.top/tags/CSS/"}]},{"title":"python 学习笔记（一）","slug":"python-学习笔记（一）","date":"2018-10-10T09:38:11.000Z","updated":"2018-10-10T09:38:59.306Z","comments":true,"path":"2018/10/10/python-学习笔记（一）/","link":"","permalink":"http://www.brightlam.top/2018/10/10/python-学习笔记（一）/","excerpt":"","text":"这学期的课程有需要学到 python，国庆利用几天时间刷了一下题，在刷的过程中遇到许多问题，都是一些零零碎碎的知识点，记录一下。 如何在控制台接收一个输入数据 123x = input()x = int(input()) // 输入的数必须为整数，同理还有 str()，float()x,y = map(int,input().split()) // 同时输入两个整数，用空格隔开 如何计算长度? 用 len() 函数，例如 12a = [&apos;string&apos;,5,1,&apos;hello&apos;]print(len(a)) // 4 三角函数，引入 math 模块 12import mathC = math.acos((a**2 + b**2 - c**2)/(2*a*b))*180/math.pi // 利用 acos 函数求三角形一边的对角 字符串打印输出格式 1print(&apos;%.2f&apos;%a) // 输出的 a 保留两位小数 for 循环书写格式 123arr = [1,2,3,4,5,6,7]for i in arr print(i,end=&quot;&quot;) // 1234567, end=&quot;&quot; 表示不换行 range 函数 1234# 创建一个整数列表，一般用在 for 循环中# 在 python 中，用 ‘#’ 注释range(0,5) # 0,1,2,3,4range(0,10,2) # 0,2,4,6,8 间隔为 2 打印一个右对齐直角三角形 1234567891011/* * *********/for i in range(0,5,2): for j in range(0,4-i): print(&quot; &quot;,end=&quot;&quot;) for k in range(0,1+i): print(&quot;*&quot;,end=&quot;&quot;) print(&quot;&quot;) 查找某个数，find() 和 index() 12str.index(&apos;a&apos;) # 查找字符串 str 是否存在 a,查到返回位置，否则抛出异常str.find(&apos;a&apos;) # 与 index 一样,不过查不到返回的是 -1 判断字母是大写，用 isupper();判断是否小写，用 islower() 求绝对值、自然对数以及平方根 1234import mathabs(x) # 求 x 的绝对值math.sqrt(x) # 对 x 进行开平方根math.log(4,2) # 以 2 为底 4 的对数，第二个参数为空则默认以 e 为底，返回的是浮点数 转义字符 \\ 12print(&quot;Please write letter &apos;A&apos;.&quot;) # Please write letter &apos;A&apos;.print(&quot;The path is \\&quot;D:\\study\\computer\\\\\\&quot;.&quot;) # The path is &quot;D:\\study\\computer\\&quot;. 用 strip() 去字符串空格，用 isalpha() 判断是否由字母组成，用 isdigit() 判断字符串是否都是数字 列表(相当于其它语言的数组) 123456arr = [5,8,7,2,4] # 定义列表 arrlist() # 将一组数转换为列表del l[2] # 删除列表中第三个数&apos; &apos;.join(列表名称) # 去除列表的 [] ,转为空格隔开的字符串append() # 在列表后添加元素arr = [x for x in arr if x != 2] # 把列表值等于 2 的删除 如果一个列表包含数字，不能直接转换为字符串，需要用 &#39;%s&#39; 格式转为字符串 列表的排序函数 sort() 和 sorted() 12345arr = [5,1,3,8,7,6]sorted(arr)arr.sort()print(arr)# [1, 3, 5, 6, 7, 8],区别：sort 是在原位排序列表，而 sorted 是产生一个新列表 算术运算符 1234+ - * / // 分别代表加、减、乘、除% 取模 // 例如 361 % 10 结果为 1// 整除,向下取整 例如 9 // 2 结果为 4, 302 // 100 为 3** n 次方 // 例如 a ** 2 表示 a 的平方","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://www.brightlam.top/tags/python/"}]},{"title":"时间复杂度、空间复杂度以及分析方法","slug":"时间复杂度、空间复杂度以及分析方法","date":"2018-10-02T09:40:18.000Z","updated":"2018-10-02T09:41:15.803Z","comments":true,"path":"2018/10/02/时间复杂度、空间复杂度以及分析方法/","link":"","permalink":"http://www.brightlam.top/2018/10/02/时间复杂度、空间复杂度以及分析方法/","excerpt":"","text":"在学习数据结构与算法的时候，总不免提到时间复杂度以及空间复杂度这两个概念，以及每次对所写代码进行的复杂度分析等，最近这段时间学习数据结构与算法时对这两个概念的理解比之前好些了，这篇文章记录下最基础的概念以及常见的时间/空间复杂度。 时间复杂度先说下时间复杂度：描述一个算法执行时间与数据规模的增长关系，通常用 T(n) = O(f(n)) 来表示，这里的 n 表示数据的规模，f(n) 每行代码执行的次数总和。这里重点在于增长关系这几个字，一个算法的时间复杂度，通常只需要考虑 n 的增长规模，这里的 n 指的是每段代码的执行次数，所以时间复杂度大多都只看循环、递归来分析，而与那些常数、系数等无关。举个例子：12345678function calc(n)&#123; var sum = 0; var i = 1; for (; i &lt; n; i++ )&#123; sum += i; &#125; return sum;&#125; 这段代码可以累加从 0 到 n 的和，我们这样对它进行分析：第 2、3 行代码需要执行一次，第 4、5 行需要执行 n 次，总的就是 2n 次，所以它的时间复杂度为 O(2n + 2)，但是因为系数、常数这些对 n 的增长规模没有影响，不需要考虑，可以忽略，如果是 n² 那就有影响了，都已经到平方阶了。所以这样看其时间复杂度为 O(n) 。类似于这样的代码不用分析，时间复杂度都是常量级的 O(1)，因为它并没有体现出 n 的增长规模关系，就算代码在多时间复杂度也是一样的，换句话说，一段代码里没有循环啊、递归等语句，通常时间复杂度都是 O(1) 。再下面在看下这段代码：123456789function(n)&#123; var sum = 0; for(var i = 1; i &lt;= n; i++)&#123; for(var j = 1; j &lt;= n; j++)&#123; sum += i*j; &#125; &#125; return sum;&#125; 像这种嵌套了两层 for 循环的代码，两行代码分别执行了 n 遍，并且是嵌套，时间复杂度就是 O(n²)。 分析小技巧 如果没有循环或递归，都是常量级的代码，时间复杂度就是 O(1) 只关注循环次数最多的一段代码，它的量级就可作为整段代码的时间复杂度 如果是 for 循环嵌套的代码，采用乘法计算其内外复杂度；如果是一个函数里有多段代码，则分析出每一段代码的时间复杂度，在将它们相加，最后去掉系数以及常数，取最大量级的作为整段代码的时间复杂度。例如，O(2n²+n+2) 则简化为 O(n²)空间复杂度类比时间复杂度，空间复杂度的概念在几个字上不一样，完整表述为:描述一个算法占用空间与数据规模的增长关系。如下代码：1234567function print(n)&#123; var i = 0; var arr = new Array(n); for(i;i&lt;n;i++)&#123; arr[i] = i * i; &#125;&#125; 同样的，第二行代码申请了存储空间 i，但它是常量阶的，跟数据的增长规模没有关系，所以不用理；第三行代码申请了一个容量为 n 的数组，剩下的代码都没有涉及到占用空间了，所以整段代码的空间复杂度为 O(n) 。常见的空间复杂度不多，就 O(1)、O(n)、O(n²) 这几个，其余对数阶的那些一般很少应用到。 常见的复杂度常见的复杂度从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n²)","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.brightlam.top/tags/数据结构与算法/"}]},{"title":"算法系列之插入排序","slug":"算法系列之插入排序","date":"2018-09-25T02:33:14.000Z","updated":"2018-09-25T02:34:24.097Z","comments":true,"path":"2018/09/25/算法系列之插入排序/","link":"","permalink":"http://www.brightlam.top/2018/09/25/算法系列之插入排序/","excerpt":"","text":"作为一个程序员，一些基本的排序算法是必须要掌握的。以前人们总觉得算法是后端程序员去学的，前端只需要专注于网页的美观以及 JS 的基本逻辑交互就行，然而，近几年随着前端行业的发展，前端越来越注重逻辑交互，如果你还像很久之前那样只知道用 HTML + CSS 去构建网页，那就落伍了。如今，前端程序员也需要对算法有一定的了解，不说别的，多掌握点东西总是好的。今天的文章介绍的是排序算法中的插入排序。 什么是排序维基百科中这样说明：一种能将一串数据依照特定排序方式进行排列的一种算法。生活中也有很多排序的例子：超市购物排队，学生成绩排序，班级座位排序等。排序可以分为内部排序还有外部排序。内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列；外部排序能够处理极大量数据的排序算法，通常需要结合外存储器（硬盘）使用。 各种排序归类 什么是插入排序插入排序的原理跟扑克牌差不多，打过扑克牌的都知道，我们拿到一副牌，会按照大小将这些牌进行排列，每拿一张牌，就将它与前面的牌进行比较，比那张牌大又比那张牌小，那么就在这个位置将其插入，然后继续拿其它的牌排列，将它们都插入到符合它们顺序的位置上，这就是插入排序的原理：每次将待排序的元素抽出来，与前面的元素进行比较，如果小于则交换位置，直到大于某个元素则排在这个元素之后，插入排序每次都需要由后向前对元素进行一一比较。 实现代码以下是插入排序的代码：123456789101112131415161718192021222324function insertSort(arr)&#123; if(Object.prototype.toString.call(arr).slice(8,-1) === &apos;Array&apos;)&#123; console.time(&apos;插入排序耗时: &apos;); for(var i=1;i&lt;arr.length;i++)&#123; var key = arr[i]; var j = i - 1; while(j&gt;=0 &amp;&amp; arr[j] &gt; key)&#123; arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = key; &#125; console.timeEnd(&apos;插入排序耗时: &apos;); return arr; &#125;else&#123; return &apos;this is not an Array&apos;; &#125;&#125;var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(insertSort(arr));// 插入排序耗时: : 0.255126953125ms// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] 第一行中的Object.prototype.toString.call(arr)返回的是[object Array]，然后我们通过 JS 中的slice()方法就可以判断传入的是不是一个数组，如果不是，则返回提示文字。代码中使用了一个临时变量 key 来存储需要比较的元素，通过后一个元素不断地与前一个元素进行比较，如果大了，就赋值交换，然后坐标 j– ；最后将 key 里存储的值放到正确的位置上。 时间和空间复杂度最好的情况：T(n) = O(n)最坏的情况：T(n) = O(n²)平均时间复杂度是：T(n) = O(n²)空间复杂度为：O(1) 引用 维基百科： https://zh.wikipedia.org/wiki/代码出处： https://blog.csdn.net/jizhen_tan/article/details/52555639","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.brightlam.top/tags/数据结构与算法/"}]},{"title":"算法系列之选择排序","slug":"算法系列之选择排序","date":"2018-09-12T16:40:57.000Z","updated":"2018-09-13T06:25:55.271Z","comments":true,"path":"2018/09/13/算法系列之选择排序/","link":"","permalink":"http://www.brightlam.top/2018/09/13/算法系列之选择排序/","excerpt":"","text":"作为一个程序员，一些基本的排序算法是必须要掌握的。以前人们总觉得算法是后端程序员去学的，前端只需要专注于网页的美观以及 JS 的基本逻辑交互就行，然而，近几年随着前端行业的发展，前端越来越注重逻辑交互，如果你还像很久之前那样只知道用 HTML + CSS 去构建网页，那就落伍了。如今，前端程序员也需要对算法有一定的了解，不说别的，多掌握点东西总是好的。今天的文章介绍的是排序算法中的选择排序。 什么是排序维基百科中这样说明：一种能将一串数据依照特定排序方式进行排列的一种算法。生活中也有很多排序的例子：超市购物排队，学生成绩排序，班级座位排序等。排序可以分为内部排序还有外部排序。内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列；外部排序能够处理极大量数据的排序算法，通常需要结合外存储器（硬盘）使用。 各种排序归类 什么是选择排序我的理解是选择排序在于 “选择” ，即先找到待排序数组中最小（也可以是最大）的数，然后把它排到数组的最前面，接着继续找最小（最大）的数，然后依次排在前面排好的数后面。举个例子可能方便理解一点，在读小学的时候，刚开学老师要排座位，老师的考虑是让高个子的同学坐后面，矮个子的坐前一点，这样看黑板就不会被挡了，于是老师把同学们排成一排，一眼望去，找到最矮的小明，叫他站到前面去，接着又在剩下的人中找到最矮的小方，让他排在小明后边，重复这样找下去，直到所有的同学都按照从矮到高的顺序排列好，就可以分配座位了。选择排序的过程大致如此。 实现代码以下是选择排序的代码：1234567891011121314151617181920212223function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time(&apos;选择排序耗时&apos;); for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd(&apos;选择排序耗时&apos;); return arr;&#125;var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));// 选择排序耗时: 0.327880859375ms// 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 代码中使用了一个临时变量 temp 来交换两个数，用 minIndex 来表示找到的最小的数的索引，当后面一个数比这个最小的数还要小时，那么将这个数的小标赋给 minIndex ，然后将它跟前面的数交换位置，这样的话，每次循环，我们就会找到最小的一个数，然后将它与当前遍历到的数互换，等遍历完的时候，基本上就排好啦。 时间和空间复杂度最好的情况：T(n) = O(n²)最坏的情况：T(n) = O(n²)平均时间复杂度是：T(n) = O(n²)空间复杂度为：O(1) 引用 维基百科： https://zh.wikipedia.org/wiki/代码出处： https://blog.csdn.net/jizhen_tan/article/details/52555639","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.brightlam.top/tags/数据结构与算法/"}]},{"title":"算法系列之冒泡排序","slug":"算法系列之冒泡排序","date":"2018-09-10T08:48:38.000Z","updated":"2018-09-10T08:51:31.131Z","comments":true,"path":"2018/09/10/算法系列之冒泡排序/","link":"","permalink":"http://www.brightlam.top/2018/09/10/算法系列之冒泡排序/","excerpt":"","text":"作为一个程序员，一些基本的排序算法是必须要掌握的。以前人们总觉得算法是后端程序员去学的，前端只需要专注于网页的美观以及 JS 的基本逻辑交互就行，然而，近几年随着前端行业的发展，前端越来越注重逻辑交互，如果你还像很久之前那样只知道用 HTML + CSS 去构建网页，那就落伍了。如今，前端程序员也需要对算法有一定的了解，不说别的，多掌握点东西总是好的。这篇文章记录下很常见的一种排序算法——冒泡排序，文章不会太长，方便你快速看完。 什么是排序维基百科中这样说明：一种能将一串数据依照特定排序方式进行排列的一种算法。生活中也有很多排序的例子：超市购物排队，学生成绩排序，班级座位排序等。排序可以分为内部排序还有外部排序。内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列；外部排序能够处理极大量数据的排序算法，通常需要结合外存储器（硬盘）使用。下图是排序的分类，下面的冒泡排序就属于交换排序的一种。 各种排序归类 什么是冒泡排序顾名思义，冒泡排序就是比较一个待排序的数组中相邻的两个数，如果一个数大于它后面的数，那就将它们交换，这样较大的数就被“冒泡”到后面了，所以第一次冒泡排序后，第一个数肯定是数组中最大的数，接着数组中较大的数会不断排到后面去，这就是冒泡排序。 实现代码下面是冒泡排序的代码，由于比较的是相邻两个数，所以只需比较到倒数第二个元素，最后一个元素例外，因此i = arr.length - 1.12345678910111213141516171819202122function bubbleSort(arr)&#123; console.time(&apos;冒泡排序耗时: &apos;); var i = arr.length - 1; while(i&gt;0)&#123; var pos = 0; // 标记每次排序的位置，这样只需循环到这里，后面的数已排好 for(var j=0;j&lt;i;j++)&#123; if(arr[j] &gt; arr[j+1])&#123; pos = j; var temp = arr[j]; // 交换两个数 arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; i = pos; // 准备下一次排序 &#125; console.timeEnd(&apos;冒泡排序耗时: &apos;); return arr;&#125;var arr=[9,2,38,4,16,36,22,68,46,1,42,48];console.log(bubbleSort(arr)); // 冒泡排序耗时: : 0.27294921875ms // 1, 2, 4, 9, 16, 22, 36, 38, 42, 46, 48, 68 也许上面的代码看着不是很懂，没关系，算法代码这种东西不是看一次就能懂的，大神忽略，多看几遍多学习，一定能有所收获。 时间和空间复杂度最好的情况：T(n) = O(n)最坏的情况：T(n) = O(n²)平均时间复杂度是：T(n) = O(n²)空间复杂度为：O(1) 最近在网上看到了一段代码，很有意思，代码如下：12345678.red&#123; color: red;&#125;.blue&#123; color: blue;&#125;&lt;div class=&quot;red blue&quot;&gt;&lt;/div&gt;&lt;div class=&quot;blue red&quot;&gt;&lt;/div&gt; 猜猜两个 div 各自的颜色，在心中有了自己的结果后可以去验证下看看自己想得对不对哦。欢迎关注下方的公众号，一起学习交流！","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.brightlam.top/tags/数据结构与算法/"}]},{"title":"Chrome 69 正式发布，新 UI 来了","slug":"Chrome-69-正式发布，新-UI-来了","date":"2018-09-06T01:08:58.000Z","updated":"2018-09-06T01:12:55.634Z","comments":true,"path":"2018/09/06/Chrome-69-正式发布，新-UI-来了/","link":"","permalink":"http://www.brightlam.top/2018/09/06/Chrome-69-正式发布，新-UI-来了/","excerpt":"","text":"最近，谷歌正式发布了旗下浏览器的最新版本，也就是 Chrome 69，这对程序员来说真是一个大好消息，要知道，很早之前的程序员都是用苦逼的 IE 系列浏览器，各种 bug 不说，偶尔还要兼容下低版本的例如绝望的 IE6，不过这都已经成为过去式了，因为近些年来的快速发展，Chrome 的市场份额越来越多，人们正在逐渐习惯使用谷歌或者火狐浏览器，现在 IE 估计只有一些政府部门还有国企在苦苦坚持使用，或许有时候用习惯了，为求稳定，就不想换了。 图片来自网络 Chrome 浏览器发布于 2008 年 9 月 2 日，至今已经 10 年了，所以这次的这个新版可以说非常有纪念意义，十周年版本，它带来了许多有用的新特性，网上关于 Chrome 新特性也说了很多，主要有以下几点： 启用新 UI，来自谷歌的 Material Design 风格，主要体现在圆角搜索框，新的图标以及全新排版的的标签栏。 默认启用画中画 API，弹出的视频窗口可以在页面上任意拖动，播放和暂停。 取消标记 HTTPS 的安全徽章，现在默认显示未标记的网站为安全，只有非 HTTPS 的才会有不安全标记 下一代视频解码器 AV1，相比 VP9，压缩效率提高 30% 在 window 平台，通过阻止第三方应用程序注入代码来减少浏览器崩溃 对于开发者来说，也同样有许多新特性： CSS Scroll Snap 允许你创建流畅、光滑的滚动体验。我看了下演示 demo，就是一个更流畅的横向幻灯控件 Display cutouts 可以使用屏幕的整个区域，包括显示屏切口后面的任何空间，有时称为凹口。这个主要是针对刘海屏的支持和优化。 Web Locks API 允许你异步获取锁，在执行工作时保持锁，然后解锁它。一些方便使用的 API 还有很多其他的新特性，感兴趣的可以去看介绍文档了解更多。现在网页版的已经更新了，想体验新版的可以去官网下载，也可以关注微信公众号「frondev」，在后台回复「Chrome」即可获取安装程序安装。不过遗憾的是，现在只更新了桌面版，Android 和 iOS 的需要在等待一段时间，相信也快了。 参考文章：https://www.oschina.net/news/99626/chrome-69-releasedhttps://developers.google.com/web/updates/2018/09/nic69（英文）","categories":[],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://www.brightlam.top/tags/Chrome/"}]},{"title":"CSS Grid布局","slug":"CSS-Grid布局","date":"2018-09-01T09:16:01.000Z","updated":"2018-09-01T09:19:06.853Z","comments":true,"path":"2018/09/01/CSS-Grid布局/","link":"","permalink":"http://www.brightlam.top/2018/09/01/CSS-Grid布局/","excerpt":"","text":"网格布局（CSS grid）是一种网页设计的新布局，目前许多主流浏览器已经支持了这一布局，对前端开发人员来说，是需要了解并学会使用的一种很方便快捷的布局。接下来我会用一段代码来展示 grid 布局的效果，然后在对代码中的每一个属性进行说明，希望读者能通过这篇文章对 CSS 的网格布局有一个大致的了解。12345678910&lt;div class=&quot;grid&quot;&gt; &lt;div class=&quot;title&quot;&gt;title&lt;/div&gt; &lt;div class=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;contentA&lt;/p&gt; &lt;p&gt;contentB&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&lt;/div&gt; 上面的 HTML 就是一段简单的 grid 布局，我们先看看它的运行效果，其中我加了一些其他样式 现在，让我们为它加上网格布局代码：12345678910111213141516171819202122232425.grid&#123; display:grid; grid-template-columns:1fr 600px 600px 1fr; grid-template-rows:1fr 1fr 1fr 1fr; grid-template-areas: &quot;. title title .&quot; &quot;. header header .&quot; &quot;. sidebar content .&quot; &quot;. footer footer .&quot;&#125;.title&#123; grid-area:title;&#125;.header&#123; grid-area:header;&#125;.sidebar&#123; grid-area:sidebar;&#125;.content&#123; grid-area:content;&#125;.footer&#123; grid-area:footer;&#125; 突然间代码有点多，一个一个解释下。首先在父元素 div 中设置display:grid;表示将其设置为网格布局；然后grid-template-columns属性是设置网格中列的尺寸大小及其占据空间，上面的参数是1fr 600px 600px 1fr表示左右各留 1fr 的距离，中间网格部分占据总共 1200px；接着grid-template-rows顾名思义就是行的意思，规定以几行来呈现布局，可以看到上面有四个参数，分别为1fr，所以整个布局总共有四行，每一行的高度为 1fr , fr 是一个单位，比 px 要大些。根据上面的描述可以看到目前的预览效果是这样： Chrome 浏览器 也许细心的你已经发现了，上面的代码还有两个属性grid-template-areas 和 grid-area,这两个属性官方文档里面解释了一大堆文字，我的简单理解是：规定网格布局中的区域，也就是每一行中放几个内容块。可以看到，我在 title、header、sidebar、content 和 footer 中都写上了一个属性：grid-area: 模块名,然后在grid-template-areas中把些模块名都写了上去，左右两边还多了两个.，这是为什么呢？ 浏览器中的效果 其实就是把网页分成了四列，左右两边的空白就对应上面的两个” . “，然后中间” title title “表示 title 这个 div 占了两列，而第三行中的” sidebar content “就是 sidebar 和 content 这两块各占一半平分，最后的 footer 也是占了两块的。最后，附上网格布局常用属性的官方定义，供读者参考理解 grid-template-columns：定义网格列的线名称和跟踪大小调整功能。grid-template-rows：该属性是基于网格行的维度，去定义网格线的名称和网格轨道的尺寸大小。grid-template-areas：属性是 grid areas 在CSS中的特定命名.grid areas：是一种对于 grid-row-start、grid-column-start、grid-row-end 和 grid-column-end 的简写，通过基线（line），跨度（span）或没有（自动）的网格放置在 grid row 中指定一个网格项的大小和位置，继而确定 grid area 的边界。grid-gap：指定行和列之间的间隙。 以上属性的定义来源于 MDN web ,谷歌翻译。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.brightlam.top/tags/CSS/"}]},{"title":"常用正则表达式整理","slug":"常用正则表达式整理","date":"2018-08-26T11:32:35.000Z","updated":"2018-08-26T11:33:34.911Z","comments":true,"path":"2018/08/26/常用正则表达式整理/","link":"","permalink":"http://www.brightlam.top/2018/08/26/常用正则表达式整理/","excerpt":"","text":"正则表达式是很多程序语言中都支持的字符串操作模式，它使用单个字串来描述、匹配一系列匹配某个句法规则的字符串。经常使用的两个方法是 test() 和 match() 。 字符规则\\d 可以匹配一个数字，例如\\d\\d可以匹配 ‘01’\\D 匹配一个非数字字符\\w 可以匹配一个字母、数字、下划线,例如\\w\\w可以匹配 ‘js’\\W 匹配非字母、数字、下划线. 可以匹配任意字符，例如js.可以匹配’js+’,’jsp’ 或 ‘js5’\\s 匹配任何空白字符，包括空格、制表符、换页符\\S 匹配任何非空白字符\\b 匹配一个单词边界，例如er\\b可以匹配 ‘never’ 中的 ‘er’\\B 匹配一个非单词边界，例如er\\B可以匹配 ‘verb’ 中的 ‘er’\\n 匹配一个换行符A|B 可以匹配 A 或 B，例如(J|j)ava 可以匹配 ‘Java’ 或 ‘java’/i 忽略大小写查找/g 全文查找出现的字符串/m 多行查找^ 匹配输入字符串的开始位置，例如^\\d则匹配的必须是数字开头$ 匹配输入字符串的结束位置，例如\\d$则表示必须由数字结尾* 匹配零次或多次，例如zo*能匹配 ‘z’ 以及 ‘zoo’+ 匹配一个表达式一次或多次，例如zo+能匹配 ‘zo’ 以及 ‘zoo’? 采用非贪婪匹配模式。贪婪模式就是尽可能多的匹配所符合的字符串，是默认模式{n} 匹配 n 次，例如\\d{3}可以匹配 ‘052’{n,} 至少匹配 n 次，例如o{2,} 不能匹配 Bob 中的 ‘o’{n,m} 至少匹配 n 次且至多匹配 m 次，例如o{1,3}可以匹配 ‘foooood’ 中的前三个 o 常用的正则表达式（来源于网络收集）1.手机号码1^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\\d&#123;8&#125;$ 2.电子邮件1^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 3.字母开头，允许5-16字节，允许字母数字下划线(一般用于账号)1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 4.密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)1^[a-zA-Z]\\w&#123;5,17&#125;$ 5.强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)1^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 6.国内电话号码，例如 021-878888221d&#123;3&#125;-d&#123;8&#125;|d&#123;4&#125;-d&#123;7&#125; 7.腾讯QQ号1[1-9][0-9]&#123;4,&#125; 8.邮政编码1[1-9]d&#123;5&#125;(?!d) 9.身份证号码(18位)1^((\\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$ 10.日期格式1^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 11.IP地址1((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 12.汉字1^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 13.域名1[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 14.url地址1[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ test() 和 match()match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。用法如下123var str=&quot;1 plus 2 equal 3&quot;;var result = str.match(/\\d+/g);console.log(result); // 1,2,3 test() 方法用于检测一个字符串是否匹配某个模式.输入参数为字符串，返回值为布尔值。用法如下1234var str = &quot;18962580014&quot;;var re = /^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\\d&#123;8&#125;$/; // 检测手机号码var result = re.test(str);console.log(result); // true","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.brightlam.top/tags/正则表达式/"}]},{"title":"面试必备！数组去重的 6 种方法","slug":"面试必备！数组去重的-6-种方法","date":"2018-08-22T11:45:46.000Z","updated":"2018-08-22T11:48:10.554Z","comments":true,"path":"2018/08/22/面试必备！数组去重的-6-种方法/","link":"","permalink":"http://www.brightlam.top/2018/08/22/面试必备！数组去重的-6-种方法/","excerpt":"","text":"在前端的面试或笔试中，经常会碰到让你写一段数组去重的代码，今天就带大家一起来学习数组去重的 6 个方法，所谓人无我有，人有我优。当别人掌握了一两种方法时，你就要努力掌握比别人更多的方法，这样就可以让自己更有竞争力些。 直接遍历法这种方法直接遍历数组，利用 JavaScript 的 indexOf 方法，新建一个新数组，用这个数组去判断旧数组中的每一个数是否等于-1,如果是，说明该数在新数组中不存在，则将其添加进新数组，遍历完后就能将数组去重并保存至新建的数组中。这里要解释一下Array.prototype.indexOf()方法，mozilla 给出该方法的作用是The indexOf() method returns the first index at which a given element can be found in the array, or -1 if it is not present.了解了它的含义后就可以开始写以下的函数：123456789101112function oSort1(arr)&#123; var newArr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(newArr.indexOf(arr[i]) === -1)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [1,1,5,9,null,5,undefined,undefined];console.log(oSort1(arr)); // 1, 5, 9, null, undefined reduce 函数使用数组的 reduce 方法在结合 indexOf 两个方法同样能去重。mozilla 官方对 reduce 的解释是 arr.reduce(callback[, initialValue]) 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。简单点讲就是对数组中的每一个数作用一个函数，这个回调函数就是第一个参数 callback ,第二个参数是传入的初始值，不传则使用数组中的第一个元素，注意在没有初始值的空数组上调用 reduce 将报错。1234567891011function oSort2(arr)&#123; return arr.reduce(function(prev,next)&#123; if(prev.indexOf(next) === -1)&#123; prev.push(next); &#125; return prev; &#125;, []);&#125;var arr = [1,1,5,9,null,5,undefined,undefined];console.log(oSort2(arr)); // 1, 5, 9, null, undefined 相邻比较这种方法利用数组的 sort() 函数，这个函数原本是对数组进行排序的，但在这里我们不用它进行排序，而只是让它将重复的元素聚拢起来，接着我们比较相邻的两个数，如果相等，则跳过；如果不相等，我们就将其添加进新数组里，这样得到的数组就是去重后的数组。12345678910111213function oSort3(arr)&#123; var newArr = [arr[0]]; arr.sort(); for(var i=1;i&lt;arr.length;i++)&#123; if(arr[i] !== arr[i-1])&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [1,1,5,9,null,5,undefined,undefined];console.log(oSort3(arr)); // 1, 5, 9, null, undefined 这里为了简便，直接将第一个元素添加进新数组，然后循环 i 从 1 开始，也就是从第二个数开始遍历直到结束。 下标指针遍历第四种方法是利用数组的下标指针，来确定是否是相同的元素，如果是的话，就让其指针递增跳过，然后不断把不重复的数组保存至新数组中。来看如下代码：123456789101112131415function oSort4()&#123; var newArr = []; for(var i=0;i&lt;arr.length;i++)&#123; for(var j=i+1;j&lt;arr.length;j++)&#123; if(arr[i] === arr[j])&#123; j = ++i; &#125; &#125; newArr.push(arr[i]); &#125; return newArr;&#125;var arr = [1,1,5,9,null,5,undefined,undefined];console.log(oSort4(arr)); // 1, 9, null, 5, undefined 上面的代码嵌套了两层循环，分别有 i 和 j 两指针，其中 j 总是比 i 大 1，通过判断数组中这个数与它后面的数是否相等，如果相等，则说明这个数重复了，我们便将指针 i 和 j 继续往后运行，然后用 j = ++i 保持 j 比 i 大 1。最后一直把不重复的指针 i 对应的元素添加进数组。 临时对象存储借用一个临时对象来存储数组元素，判断数组中的元素是否在对象中，如果不存在，就将该数添加进数组，并在临时对象中做标记。1234567891011121314function oSort5(arr)&#123; var newArr = []; var temp = &#123;&#125;; for(var i=0;i&lt;arr.length;i++)&#123; if(!temp[arr[i]])&#123; newArr.push(arr[i]); temp[arr[i]] = true; &#125; &#125; return newArr;&#125;var arr = [1,1,5,9,null,5,undefined,undefined];console.log(oSort5(arr)); // 1, 5, 9, null, undefined 简单粗暴法这种方法厉害了，只需要一句代码：123456function oSort6(arr)&#123; return Array.from(new Set(arr));&#125;var arr = [1,1,5,9,null,5,undefined,undefined];console.log(oSort6(arr)); // 1, 5, 9, null, undefined 利用 ES6 中的 Set 集合里元素唯一的特性，先将数组转换为集合，这样里面的元素就是唯一的了，再用 Array.from 方法将集合转回数组返回，是不是很方便有木有？附上 Array.from 方法的官方介绍: 从一个类似数组或可迭代对象中创建一个新的数组实例.以上就是 6 种数组去重的方法啦，如果您有什么意见或建议，欢迎一起学习交流！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"},{"name":"数组去重","slug":"数组去重","permalink":"http://www.brightlam.top/tags/数组去重/"}]},{"title":"数据结构之链表","slug":"数据结构之链表","date":"2018-08-21T02:20:42.000Z","updated":"2018-08-21T02:28:42.771Z","comments":true,"path":"2018/08/21/数据结构之链表/","link":"","permalink":"http://www.brightlam.top/2018/08/21/数据结构之链表/","excerpt":"","text":"链表是由一组节点组成的集合，每个节点使用一个对象的引用指向它的后继，指向另一个节点的引用就是链。在 JavaScript 中，数组也可以存储元素，但是数组说到底也是一个对象，与其他语言相比效率比较低，因此出现了链表，它可以更方便地代替数组来实现同样的数据存储与移动效果。 定义链表为了更形象地表示链表，我从网上找了一张表示图，如下 图片来自网络 每个链表都有一个头结点，头结点通常作为链表的接入点，它不参与链表的遍历，同样还会有一个尾元素，指向一个 null 结点。在 JavaScript 中，实现一个基于对象的链表，使用两个类，一个类用来表示所有的结点，另一个类用来表示一些链表的基本方法。 Node 类1234function Node(element) &#123; this.element = element; // 保存节点上的数据 this,next = null; // 保存指向下一个节点的链接&#125; LinkedList 类1234567function LList() &#123; this.head = new Node(&quot;head&quot;); this.find = find; this.insert = insert; this.remove = remove; this.display = display;&#125; 实现插入节点插入一个节点，首先要明确是在某个节点的前面或后面插入，假设在一个已知节点后面插入元素，则需要先找到该节点“后面”的节点，然后将新节点的 next 属性设置为“后面”节点的 next 属性对应的值，然后设置“后面” 的节点的 next 属性指向新节点。123456789101112131415// 定义一个 find 来找到 “后面” 的节点function find(item) &#123; var currNode = this.head; while(currNode.element != item) &#123; currNode = currNode.next; &#125; return currNode;&#125;function insert(newElement,item) &#123; var newNode = new Node(newElement); var current = this.find(item); newNode.next = current.next; current.next = newNode;&#125; 现在插入新节点的方法已经完成，我们紧接着定义一个方法用于展示链表中的元素1234567function display() &#123; var currNode = this.head; while(!(currNode.next == null)) &#123; console.log(currNode.next.element); currNode = currNode.next; &#125;&#125; 删除节点删除链表中的一个元素，我们首先要找到该元素所在的节点，然后找到它前面的节点，使其的 next 属性指向待删除节点的下一个节点，这样就可以把节点 remove 掉。123456789101112131415// 定义 findPrevious 方法寻找前面节点function findPrevious(item)&#123; var currNode = this,head; while(!(currNode.next == null) &amp;&amp; (currNode.next.element != item))&#123; currNode = currNode.next; &#125; return currNode;&#125;function remove(item) &#123; var prevNode = this.findPrevious(item); if(!(prevNode.next == null)) &#123; prevNode.next = prevNode.next.next; &#125;&#125; 这里的prevNode.next = prevNode.next.next;就是使前面的节点直接指向待删除节点后面的节点。 完整代码最后放上完整的代码，包含 Node 类、LList 类和测试代码；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function Node(element) &#123; this.element = element; this,next = null; &#125;function LList() &#123; this.head = new Node(&quot;head&quot;); this.find = find; this.insert = insert; this.remove = remove; this.display = display;&#125;function remove(item) &#123; var prevNode = this.findPrevious(item); if(!(prevNode.next == null)) &#123; prevNode.next = prevNode.next.next; &#125;&#125;function findPrevious(item)&#123; var currNode = this.head; while(!(currNode.next == null) &amp;&amp; (currNode.next.element != item))&#123; currNode = currNode.next; &#125; return currNode;&#125;function display() &#123; var currNode = this.head; while(!(currNode.next == null)) &#123; console.log(currNode.next.element); currNode = currNode.next; &#125;&#125;function find(item) &#123; var currNode = this.head; while(currNode.element != item) &#123; currNode = currNode.next; &#125; return currNode;&#125;function insert(newElement,item) &#123; var newNode = new Node(newElement); var current = this.find(item); newNode.next = current.next; current.next = newNode;&#125;var city = new LList();city.insert(&quot;Guangzhou&quot;,&quot;head&quot;);city.insert(&quot;Shenzhen&quot;,&quot;Guangzhou&quot;);city.insert(&quot;Shantou&quot;,&quot;Shenzhen&quot;);city.insert(&quot;Zhuhai&quot;,&quot;Shantou&quot;);city.display();city.remove(&quot;Shenzhen&quot;);city.display(); 参考资料：Data Structure and Algorithms Using JavaScript, Michael McMillan 著","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.brightlam.top/tags/数据结构与算法/"}]},{"title":"数据结构之栈和队列","slug":"数据结构之栈和队列","date":"2018-07-24T05:09:52.000Z","updated":"2018-07-24T05:15:43.973Z","comments":true,"path":"2018/07/24/数据结构之栈和队列/","link":"","permalink":"http://www.brightlam.top/2018/07/24/数据结构之栈和队列/","excerpt":"","text":"数据结构有许多种，上篇文章分享的是可以存储简单数据的列表，例如待办事项，购物清单等。今天要跟大家分享的是两种非常常见的也必须了解的数据结构——栈与队列。 栈的定义什么是栈呢？它是一种“后入先出”的数据结构，它跟列表一样，都是可以用来存储数据，但是却要比列表严格的多，栈的数据只能在栈顶添加或删除。举个例子，在麦当劳用餐时的那些盘子，捡餐员在拿盘子时，总是从一摞盘子的最上端拿（栈顶），然后放上食品在端给客人，而那些擦餐盘的人，也总是在最上面拿起餐盘擦拭后不断地叠放成一摞餐盘，这里的餐盘就可看成是栈，数据的添加或删除总是在最上端进行。下图展示了栈的构成以及简单的入栈与出栈过程。 图片来自网络 栈的主要操作方法栈的常用操作就是入栈和出栈，入栈用的是 push() 方法，出栈用的是 pop() 方法，还有一个方法是 peek() ，该方法可以返回栈顶的元素而不删除它，相应的 pop() 方法虽然也可以得到栈顶的元素，但会将它删除。 栈的实现在 JavaScript 中，通常使用数组来实现栈。下面我们定义一个名为 Stack 的构造函数用来表示栈。1234567function Stack() &#123; this.dataStore = []; this,top = 0; this.push = push; this.pop = pop; this.peek = peek;&#125; dataStore 是一个数组，用来存储栈中的元素，而变量 top 记录栈顶的位置，初始位置为 0，push 、pop 和 peek 分别对应三个方法，下面来实现这些方法。首先是 push() ,入栈。123function push() &#123; this.dataStore[this.top++] = element;&#125; 这里 top++ 很有意思，要知道 + 号在变量后和变量前是不同的，这里的逻辑是，当元素入栈后，变量 top 的值就对应当前入栈元素的位置，然后 top++ ，自增后的值就是下一个元素入栈时的位置了。接下来是出栈方法 pop() 。123function pop() &#123; return this.dataStore[--this.top];&#125; 前面说了，栈只能在最顶端添加、删除数据，所以我们必须要知道栈顶现在存放的是哪个数值才能将它删除，于是我们使用 top 来标记它的位置，现在出栈，只需要把指向栈顶的位置的节点数据拿掉就行了。最后一个方法是取栈顶元素的 peek() 方法,相信也不难理解，就把栈顶元素直接返回就行，注意栈顶元素的位置是第 top - 1 个位置。123function peek() &#123; return this.dataStore[this.top - 1];&#125; 除了上述的基本操作方法外，还有其它方法可以有作用。来看下面这两个方法123456function length() &#123; return this.top;&#125;function clear() &#123; this.top = 0;&#125; 上面的方法一个是可以获取栈内存储了多少个元素的 length() 方法， 另一个是 clear() ,听名字就知道是把一个栈清空，通过将 top 的值归零。 栈的完整代码栈的完整代码以及测试如下12345678910111213141516171819202122232425262728293031323334353637function Stack() &#123; this.dataStore = []; this,top = 0; this.push = push; this.pop = pop; this.peek = peek; this.length = length; this.clear = clear;&#125;function push() &#123; this.dataStore[this.top++] = element;&#125;function pop() &#123; return this.dataStore[--this.top];&#125;function peek() &#123; return this.dataStore[this.top - 1];&#125;function length() &#123; return this.top;&#125;function clear() &#123; this.top = 0;&#125;var s = new Stack();s.push(&quot;xiaoming&quot;);s.push(&quot;xiaohong&quot;);s.push(&quot;Mike&quot;);console.log(&quot;栈的长度为： &quot;+s.length());console.log(s.peek()); s.clear();console.log(&quot;当前长度为： &quot;+s.length()); 运行结果为： 栈的长度为： 3Mike当前长度为： 0 队列的定义队列是一种与栈截然不同的数据结构，栈的特点是后入先出，最后入栈的元素会优先处理而弹出，而队列的特点则是先入先出，最先进栈的也会最终先出栈，这有点类似于银行窗口前排队办业务的人群，排在最前面的先办理业务，后面来的就依次排队。 队列的主要操作方法与栈一样，队列也是用数组来实现，它的主要操作方法同样是入队（enqueue）,出队（dequeue）和读取队头的元素（peek）,读取队头元素同样不会删除元素，只返回。此外还有清空队列元素（clear）和获取队列元素个数（length）。 队列的实现首先定义一个 Queue 类用来表示队列。123456789function Queue() &#123; this.dataStore = []; // 存储队列元素 this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.back = back; this.toString = toString; this.empty = empty;&#125; 接下来实现入队方法 enqueue() ：123function enqueue(element) &#123; this.dataStore.push(element);&#125; 可以看到，用数组来实现队列非常简单，入队只需一个 push() 方法即可向队尾添加元素。123function dequeue() &#123; return this.dataStore.shift();&#125; shift 是数组的一个操作方法，可以将数组的第一个元素删除。123456function front() &#123; return this,dataStore[0];&#125;function back() &#123; return this.dataStore[this.dataStore.length - 1];&#125; 这两个分别是读取队列的第一个元素和最后一个元素，很简单，直接返回数组的第一个元素和最后一个元素即可。1234567function toString() &#123; var str = &quot;&quot;; for (var i = 0; i &lt; this.dataStore.length; i++) &#123; str += this.dataStore[i] + &quot;\\n&quot;; &#125; return str;&#125; 这个方法显示队列元素，类似控制台 console 输出元素。12345678function empty() &#123; if (this.dataStore.length == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125; 这是一个判空方法，每次使用队列前要判断是否为空才可进行下一步的操作。 队列完整代码及测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Queue() &#123; this.dataStore = []; // 存储队列元素 this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.back = back; this.toString = toString; this.empty = empty;&#125;function enqueue(element) &#123; this.dataStore.push(element);&#125;function dequeue() &#123; return this.dataStore.shift();&#125;function front() &#123; return this,dataStore[0];&#125;function back() &#123; return this.dataStore[this.dataStore.length - 1];&#125;function toString() &#123; var str = &quot;&quot;; for (var i = 0; i &lt; this.dataStore.length; i++) &#123; str += this.dataStore[i] + &quot;\\n&quot;; &#125; return str;&#125;function empty() &#123; if (this.dataStore.length == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;var q = new Queue();q.enqueue(&quot;Mike&quot;);q.enqueue(&quot;Hello&quot;);q.enqueue(&quot;hhhh&quot;);console.log(q.toString());q.dequeue();console.log(q.toString());console.log(&quot;队列的第一个元素是: &quot; + q.front());console.log(&quot;队列的最后一个元素是: &quot; + q.back()); 运行结果如下： MikeHellohhhhHellohhhh队列的第一个元素是: Hello队列的最后一个元素是: hhhh 以上，对数据结构中栈和队列的简单介绍，想看关于栈和队列的更多实例代码，戳这里 栈与队列实例代码","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.brightlam.top/tags/数据结构与算法/"}]},{"title":"数据结构之列表的定义","slug":"数据结构之列表的定义","date":"2018-07-15T09:47:12.000Z","updated":"2018-07-15T09:48:37.742Z","comments":true,"path":"2018/07/15/数据结构之列表的定义/","link":"","permalink":"http://www.brightlam.top/2018/07/15/数据结构之列表的定义/","excerpt":"","text":"列表是一种数据结构，在生活中也有广泛应用，例如待办事项清单、购物清单等都可以做成列表。在开发中，我们就可以把列表抽象成一个数据类型，将它写成一个可以循环使用并能用来解决问题的程序，这就是一个列表抽象类。 类的定义用 JavaScript 定义一个 List 类，代码如下：12345678910111213141516171819202122function List() &#123; this.listsize = 0; // 列表的元素个数 this.pos = 0; // 列表的当前位置 this.dataStore = []; // 保存列表元素的数组 this.clear = clear; // 清空列表元素 this.find = find; // 查找某一元素 this.toString = toString; // 显示列表元素 this.insert = insert; // 插入元素 this.append = append; // 添加元素 this.remove = remove; // 删除元素 this.front = front; // 将当前位置移动到第一个元素 this.end = end; // 将当前位置移动到最后一个元素 this.prev = prev; // 将当前位置后移一位 this.next = next; // 将当前位置前移一位 this.hasNext; // 判断后一位 this.hasPrev; // 判断前一位 this.length = length; // 列表的元素个数 this.currPos = currPos; // 返回列表的当前位置 this.moveTo = moveTo; // 将当前位置移动到指定位置 this.getElement = getElement; // 获取元素 this.contains = contains; // 判断元素是否存在列表&#125; 以上，基本把一个列表类的所有方法都列举出来了。下面针对每一个方法做一个具体的实现。 append:给列表添加元素当调用 append 方法后，就会给列表的下一个位置增加一个新的元素，这个位置就等于变量 listSize 的值：123function append(element) &#123; this.dataStore[this.listSize++] = element;&#125; listSize 表示列表的元素个数，所以添加后就要加 1. remove:删除元素它的实现思路是：首先在列表中查找到我们传入的这个需要删除的元素，然后删除它，最后让所有元素移动以填补删除元素的空白。为方便，先定义一个查找元素的 find 方法：12345678function find(element) &#123; for(var i=0;i&lt;this.dataStore.length;i++)&#123; if(this.dataStore[i] == element) &#123; return i; &#125; &#125; return -1;&#125; 这个方法类似于很多字符串或数组之类的查找方法，找到一个元素，就返回该元素在列表中的位置；否则返回 -1.接下来我们就可以写删除元素的 remove 方法.123456789function remove(element) &#123; var foundAt = this.find(element); if(foundAt &gt; -1) &#123; this.dataStore.splice(foundAt,1); --this.listSize; return true; &#125; return false;&#125; 还记得 splice 方法的使用吗？如果忘了，可以查看上一篇文章 数据结构之数组 里面有关于数组常用方法的介绍。 length:长度这个方法无需多说，直接上代码：123function length() &#123; return this.listSize;&#125; toString:把元素陈列出来这个方法就是输出列表中的元素：123function toString() &#123; return this.dataStore;&#125; 测试上面列了这么多方法，不妨来测试下，下面是简短的测试代码：1234567var names = new List();names.append(&quot;John&quot;);names.append(&quot;Mike&quot;);names.append(&quot;Amy&quot;);console.log(names.toString());names.remove(&quot;Amy&quot;);console.log(names.toString()); 执行结果为： John,Mike,AmyJohn,Mike insert:插入元素123456789function insert(element,after) &#123; var curr = this.find(after); if(curr &gt; -1) &#123; this.dataStore.splice(curr+1,0,element); ++this.listSize; return true; &#125; return false;&#125; insert 方法的实现思路是：首先找到一个元素 after ，你想要把元素插入在这个 after 元素之后，于是你得先找到这个 after 在列表里的位置，然后你就可以利用 splice 方法将你想插入的元素进行插入。插入成功返回 true，失败返回 false； clear：清空元素该方法相当于扫把，把所有列表里的东西都清理掉：12345function clear() &#123; delete this.dataStore; this.dataStore.length = 0; this.listSize = this.pos = 0;&#125; 可以看到，使用了 delete 操作符来删除数组 dataStore,接着在创建一个空数组，最后将属性值归零。 contains：判断给定值是否在列表中12345678function contains(element) &#123; for (var i = 0; i &lt; dataStore.length; i++) &#123; if(this.dataStore[i] == element) &#123; return true; &#125; &#125; return false;&#125; 遍历列表下面的这些方法可以在列表上移动元素1234567891011121314151617181920212223242526272829function front() &#123; this.pos = 0;&#125;function end() &#123; this.pos = this.listSize-1;&#125;function prev() &#123; --this.pos;&#125;function next() &#123; if(this.pos &lt; this.listSize) &#123; ++this.pos; &#125;&#125;function currPos() &#123; return this.pos;&#125;function moveTo(position) &#123; this.pos = position;&#125;function getElement() &#123; return this.dataStore[this.pos];&#125;function hasNext() &#123; return this.pos&lt;this.listSize;&#125;function hasPrev() &#123; return this.pos &gt;= 0;&#125; 参考资料：Data Structure and Algorithms Using JavaScript, Michael McMillan 著","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.brightlam.top/tags/数据结构与算法/"}]},{"title":"数据结构之数组","slug":"数据结构之数组","date":"2018-07-09T12:14:41.000Z","updated":"2018-07-09T12:17:04.579Z","comments":true,"path":"2018/07/09/数据结构之数组/","link":"","permalink":"http://www.brightlam.top/2018/07/09/数据结构之数组/","excerpt":"","text":"程序员可能都听说过：算法 + 数据结构 = 程序。今天就来了解下数据结构的其中一种——数组吧。数组的标准定义是：一个存储元素的线性集合。许多编程语言都有相应语法的数组，而在 JavaScript 中，数组其实是一种特殊的对象。 数组的创建与读写以下两种方式都可创建数组：1234567// 字面量方式,常用var num = [1,5,6,10];print(num.length); // 4// 构造函数方式var num = new Array(1,5,6,10);print(num.length); // 4 值得注意的是，JavaScript 中的数组数据可以是不同类型，它的语法相对宽松，例如可以指定不同类型数据var example = [1,&quot;Mike&quot;,true,null];另外，可以通过Array.isArray()来判断一个对象是否是数组，例如：12var num = [1,5,6,10];print(Array.isArray(num)); // true 如何读写数组呢？可以使用循环。1234var num = [1,5,6,10];for (var i = 0; i &lt; num.length; i++) &#123; console.log(num[i]+&quot; &quot;);&#125; 数组的深复制与浅复制当我们把数组赋给另外一个数组，然后改变其中一个数组的值，另一数组也会随之改变，这就是数组的浅复制。而深复制指的就是不改变原来的数组而去创建一个新的数组，这种情况是经常使用的，为了不破坏原数组。下面的代码展示了这两种复制1234567891011121314151617// 浅复制var num = [1,2,3,4,5];var newNum = num;num[0] = 10;console.log(newNum[0]); // 10// 深复制function copy (arr1,arr2) &#123; for(var i=0;i&lt;arr1.length;i++)&#123; arr2[i] = arr1[i]; &#125;&#125;var num = [1,5,6,7,9];var newNum = [];copy(num,newNum);num[0] = 10;console.log(newNum[0]); // 仍然为 1 存取函数JavaScript 提供了一组用来访问数组元素的函数，叫存取函数。最常用的存取函数就是 indexOf() 函数，该函数返回指定查找的值在目标值中是否存在，如果存在，返回该值在数组中的索引，不存在则返回 -1。12345var word = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];var result = word.indexOf(&quot;A&quot;);console.log(result); // 0var test = word.indexOf(&quot;F&quot;);console.log(test); // -1 除此之外，还有 join 和 toString 函数，concat 和 splice 函数。前两个函数可以将数组转化为字符串，后面两个函数可以通过已有的数组创建新数组，其中 concat 方法通过合并多个数组来形成新数组，而 splice 方法是截取一个数组的子集作为一个新数组。它们的使用示例如下1234567891011var arr = [&quot;Mike&quot;,&quot;John&quot;,&quot;Hexo&quot;];console.log(arr.join()); // Mike,John,Hexoconsole.log(arr.toString()); // Mike,John,Hexovar arr1 = [1,10,&quot;Mike&quot;];var arr2 = [8,7,6];var cat = arr1.concat(arr2);console.log(cat); // [1, 10, &quot;Mike&quot;, 8, 7, 6]var num = [1,2,3,4,5,6,7];var a = num.splice(3,2); // 3 表示索引，2 表示删除 2 个console.log(num); // [1, 2, 3, 6, 7] 可变函数不去引用数组中的某个元素，就能改变数组内容，这种函数称它为可变函数。 push() 和 unshift()、pop() 和 shift()push() 方法可以在数组末尾添加元素，而 unshift() 方法可以在数组开头添加元素；相对应的，pop 可以删除数组末尾的元素，而 shift 删除数组的第一个元素。123456789var nums = [9,58,15,16,23];nums.push(111);console.log(nums); // 9, 58, 15, 16, 23, 111nums.unshift(1);console.log(nums); // 1, 9, 58, 15, 16, 23, 111nums.pop();console.log(nums); // 1, 9, 58, 15, 16, 23nums.shift();console.log(nums); // 9, 58, 15, 16, 23 splice()、sort()、reverse()前面提到的 splice 不仅可以用来删除元素，还可以添加元素进数组。用 sort 可以为数组排序，reverse 将数组内的元素翻转。12345var num = [98,99,100,101];num.splice(1,0,89); // 1 表示索引，0 表示不删除元素，89 表示将 89 这个元素添加进数组console.log(num); // 98, 89, 99, 100, 101num.reverse();console.log(num); // 101, 100, 99, 89, 98 关于 sort 方法非常有意思，它只能对那些字符串类型的元素排列得比较准确，但如果是数字，结果就不那么令人满意了。看看例子.123456var str = [&quot;hello&quot;,&quot;client&quot;,&quot;zero&quot;];str.sort();console.log(str); // [&quot;client&quot;, &quot;hello&quot;, &quot;zero&quot;] 按照字母 a-z 排列准确var nums = [1,200,51,66,88];nums.sort();console.log(nums); // [1, 200, 51, 66, 88] 有趣的事情来了，因为 200 的 2 比 51 的 5 先，所以 200 排在 51 前头 那如何解决这种排序的错误呢？方法就是在调用 sort() 的时候传入一个函数，该函数可以比较出大小。123456function compare(num1,num2)&#123; return num1 - num2;&#125;var nums = [3,1,2,100,4,200];nums.sort(compare);console.log(nums); // 1, 2, 3, 4, 100, 200 可以看到，已经排序正确了，compare 函数就是利用了两数相减，如果结果为正，那么被减数大于减数，如果结果为 0，则两数相等，而如果结果为负，说明被减数小于减数。 迭代器方法迭代函数通过对数组中的元素逐个应用，来操作返回相应的值。 不返回新数组的 forEach() 、every()、some()、reduce()12345678910111213// 用 forEach 开方function square(num) &#123; console.log(num,num*num);&#125;var num = [1,2,3,4,5];num.forEach(square);console.log(num);/* 1 1 2 4 3 9 4 16 5 25*/ 12345678910111213/*every() 返回值为布尔类型，对于应用的所有元素，该函数返回 true，则该方法返回 true*/function isEven(num)&#123; return num % 2 == 0;&#125;var num = [2,4,6,8,10];var even = num.every(isEven);if(even)&#123; console.log(&quot;所有的数字都是偶数&quot;);&#125;else&#123; console.log(&quot;不是所有的数字都是偶数&quot;);&#125; 12345678910111213/*some() 与 every() 的不同就是只要有一个元素使改函数返回 true ，那么该方法就返回 true*/function isEven(num)&#123; return num % 2 == 0;&#125;var num = [1,2,3,4,5,6,7,8];var someEven = num.some(isEven);if(even)&#123; console.log(&quot;有些数字是偶数&quot;);&#125;else&#123; console.log(&quot;没有数字是偶数&quot;);&#125; 12345678910111213141516/*reduce() 有两个功能，一是可以对数组元素进行求和，二是将数组元素连接成字符串。*/fucntion add(num1,num2)&#123; return num1 + num2;&#125;var num = [1,2,3,4];var sum = num.reduce(add);console.log(sum); // 10function concat(str,i) &#123; return str + i;&#125;var words = [&quot;I am &quot;,&quot;a &quot;,&quot;coder &quot;];var re = words.reduce(concat);console.log(re); // I am a coder 返回新数组的 map() 和 filter()map 的作用与 forEach 是一样的，区别就是 map 函数返回的是一个新数组。123456function addFive(grade)&#123; return grade += 5;&#125;var grade = [77,82,88,95,90];var result = grade.map(addFive);console.log(result); // 82, 87, 93, 100, 95 而 filter 和 every 相似，区别在于当所有的元素使改函数为 true 时，它并不返回布尔类型，而是返回一个新数组。下面这个例子十分有趣，它随机产生10个 0 到 100 的数字作为分数，然后把大于 60 的及格分数筛选出来。123456789101112function passing(num)&#123; return num &gt;= 60;&#125;var grades = [];for(var i = 0;i &lt; 11;i++)&#123; grade[i] = Math.floor(Math.random() * 101);&#125;var pass = grades.filter(passing);console.log(&quot;随机产生的 10 个同学的分数为：&quot;);console.log(grades)；console.log(&quot;及格的分数有：&quot;);console.log(pass)； 上述代码的输出结果为 随机产生的 10 个同学的分数为：21, 4, 89, 45, 5, 51, 71, 7, 46, 53, 47及格的分数有：89, 71 二维数组JavaScript 可以通过在数组里在嵌套一个数组来形成二维数组。12var grades = [[88,86,82],[91,82,83],[77,72,79]];console.log(grades[1][2]); // 83 处理二维数组对于二维数组的处理可以分为两种，一种按列访问，一种是按行访问。按列访问，外层循环对应行，内层循环对应列。例如，上述的数组，每一行对应一个学生的成绩记录，可以通过相加所有成绩，然后除以科目数来得到该生的平均成绩。123456789101112var grades = [[88,86,82],[91,82,83],[77,72,79]];var total = 0;var average = 0.0;for(var row = 0;row&lt;grades.length;++row)&#123; for(var col = 0;col&lt;grades[row].length;++col)&#123; total += grades[row][col]; &#125; average = total/grades[row].length; console.log(&quot;student &quot;+parseInt(row+1)+&quot; average: &quot;+average.toFixed(2)); // toFixed 表示按照 2 位来保留小数 total = 0; average = 0.0;&#125; 上述代码的输出结果为 student 1 average: 85.33student 2 average: 85.33student 3 average: 76.00 对于按行访问，则外层循环对应列，内城循环对应行，例如还是上述数组，现在的数组表示一个学生各科的分数，我们来求其平均成绩123456789101112var grades = [[88,86,82],[91,82,83],[77,72,79]];var total = 0;var average = 0.0;for(var col = 0;col &lt;grades.length;++col )&#123; for(var row= 0;row&lt;grades[col ].length;++row)&#123; total += grades[row][col]; &#125; average = total/grades[col ].length; console.log(&quot;exam &quot;+parseInt(col +1)+&quot; average: &quot;+average.toFixed(2)); total = 0; average = 0.0;&#125; 输出结果为： exam 1 average: 85.33exam 2 average: 80.00exam 3 average: 81.33 其实只要调整 for 循环的顺序就可以控制是按行还是按列来输出，此外，JavaScript 还可以处理一些参差不齐的数组，比如一个二维数组中的数组，有的是两个元素，有的是四个元素，并不是都相同，在这种情况下，JavaScript 依然可以处理运行而不报错，这是因为不管多或少，都可以通过 length 属性来计算。 对象数组如果你有阅读到这里，你应该可以发现上面的所有例子里数据类型都是基本数据类型，不是数字就是字符串。对象数组，顾名思义，就是数组里面的元素可以是对象，这个与 java 的语法很相似，基本上所有的编程语言都是相通的。看看下面这个例子：1234567891011121314151617function point(x,y)&#123; this.x = x; this.y = y;&#125;function show(arr)&#123; for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i].x + &quot;, &quot;+arr[i].y); &#125;&#125;var p1 = new Point(1,2);var p2 = new Point(2,4);var p3 = new Point(8,1);var p4 = new Point(2,9);var point = [p1,p2,p3,p4];for(var i=0;i&lt;point.lengh;i++)&#123; console.log(&quot;Point &quot;+parseInt(i+1)+&quot;: &quot;+point[i].x+&quot;, &quot;+point[i].y);&#125; 上述程序的输出结果为： Point 1: 1, 2Point 2: 2, 4Point 3: 8, 1Point 4: 2, 9 也可以用之前的 puh() 等操作方法来操作对象数组1234567var p5 = new Point(11,13);point.push(p5);console.log(&quot;添加了 p5 后：&quot;);show(point); point.shift();console.log(&quot;删除第一个元素后：&quot;)show(point); 输出结果为： 添加了 p5 后：1,22,48,12,911,13删除第一个元素后：2,48,12,911,13 以上，关于 JavaScript 数组的全部总结，如果觉得有用，时常来走走看看哦！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"你真的了解闭包么","slug":"你真的了解闭包么","date":"2018-06-30T12:15:59.000Z","updated":"2018-06-30T12:52:57.074Z","comments":true,"path":"2018/06/30/你真的了解闭包么/","link":"","permalink":"http://www.brightlam.top/2018/06/30/你真的了解闭包么/","excerpt":"","text":"闭包是 JavaScript 的一个重要知识点，对于学前端的人来说是必须要理解的一个知识点，它其实已经时不时地被我们使用着，只不过我们“日用而不知”，本文带你一起来学习下闭包。 全局作用域与局部作用域在认识闭包之前，首先要了解下 JavaScript 的作用域概念。看看下面这段代码：12345var x = 2;function test() &#123; return x * x;&#125;test(); // 4 可以看到，在 JavaScript 的语法里，函数内部可以读取函数外部的变量，此时变量 x 就是 window 下的全局作用域。然而，函数内部定义的变量，外部是无法访问的：1234function test() &#123; var x = 2;&#125;alert(x); // error 这里的 x 就是局部作用域，只能在函数内部使用它，需要注意的是，在函数内部定义变量时，要使用 var 关键字，否则它实际上也是一个全局变量！ 计数器问题也许你已经发现了，全局变量可以在任意地方调用它，可是我们却不能从外部读取函数内部的变量。如果你还未发觉，那在看看下面这个例子。假设现在你想写一个计数器函数，你可能会这么写：12345678function count() &#123; var num = 0; return num += 1;&#125;var result = count();console.log(result); // 1console.log(result); // 1console.log(result); // 1 你看，当你写完之后兴致勃勃地执行它，原本以为会输出 1 2 3 ，结果全都是 1，你在纳闷的时候突然发现这里的 count 是一个局部作用域，每次调用函数的话它又被重新定义了，于是你想着这样改：12345678var num = 0;function count() &#123; return num += 1;&#125;count();count();count();console.log(num); // 3 这样计数器就可以了，结果是 3 了，但是你想，现在的 num 是全局变量了，这就意味着谁都可以修改 num 的值，那这个计数器现在还有意义么？所以，我们的需要对其进行优化。 闭包我们试着这样来实现，就是在函数里面在内嵌一个函数，这样，内层函数就能访问外层函数的变量，而变量也是被封装在外层函数里面，本身它也是属于局部变量，作用域也是局部的。1234567var count = (function () &#123; var num = 0; return function () &#123; return num += 1; &#125;&#125;)();count();count();count(); 上面这个就是闭包（closure），关于它的官方概念有很多文献可以参考，我的简单理解是函数里面在嵌套函数，内部函数可以访问外部函数的变量，外部函数的变量是私有属性，只能在函数作用域内使用，这就是形成了闭包。它的好处是解决了开头提到的函数内部定义的变量，外部无法访问的问题。另外，闭包还有一个特色就是，局部变量定义后会一直保存在内存中，并没有在函数被调用后就被垃圾回收。 额外思考题在查阅了相关资料后，从 W3C 看到了关于闭包的两道思考题，可以说很经典了，就留给大家思考吧！代码片段1（来自 W3Cschool ）12345678910var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); 代码片段2（来自 W3Cschool ）1234567891011var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"ES6 新特性总结","slug":"ES6-新特性总结","date":"2018-06-20T09:47:02.000Z","updated":"2018-06-20T10:09:13.989Z","comments":true,"path":"2018/06/20/ES6-新特性总结/","link":"","permalink":"http://www.brightlam.top/2018/06/20/ES6-新特性总结/","excerpt":"","text":"JavaScript 的标准 ECMAScript6 到目前为止已经得到广泛使用并被绝大数浏览器所支持，相比 ES5 ，ES6 增加了许多新特性，帮助开发者简化了许多操作，下面一起来看看这些新特性。 箭头函数ES6 新增了用 =&gt; 来表示函数，在这之前，定义一个加法函数是这样子的123function add (x,y) &#123; return x + y;&#125; 而现在，可以省去 function 关键字，直接这样子写1let add = (x,y) =&gt; return x + y; 注意，如果箭头后面只有一句语句的话，可以省略 {} let 与 const 关键字也许你注意到了，上面这个 let 又是什么意思？它就是 ES6 新增的、用来替代 var 的关键字，let 与 var 的功能相同，都是定义声明变量，不同的是，let 声明的变量有一个块级作用域的概念，就是只有在当前的代码块下才能使用定义的这个变量;而 const 则是声明常量。1234567&apos;use strict&apos;;const x = &apos;hello world&apos;;x = &apos;javascript&apos;; // Assignment to constant variable.for ( let i = 0; i &lt; 5; i++) &#123; console.log(i); // 0 1 2 3 4&#125;console.log(i); //错误，因为 i 只在它所在的代码块有效 字符串表示新的 ES6 提供了操作字符串的简单方法，在这之前，连接字符串通常用 + 来表示，例如12var a = &apos;hello world&apos;;console.log(&apos;我写的第一句代码是 &apos;+ a +&apos; !&apos;); ES6 提供了反引号 (英文状态下键盘 tab 键上方的符号键，！的左侧)来连接字符串，${variable}来表示变量。12let a = &apos;hello world&apos;;console.log(`我写的第一句代码是 $&#123;a&#125; !`); //注意空格，也是有作用的 类的支持ES6 新增了 class 关键字，有了类的概念，如果你熟悉 Java ，对类应该不陌生。创建一个类并实例化它也非常简单1234567891011121314151617181920212223class Student &#123; //构造函数 constructor(name,grade) &#123; this.name = name; this.grade = grade; &#125; myGrade () &#123; console.log(this.name+&apos;的成绩是 &apos;+this.grade); &#125;&#125;class Programmer extends Student &#123; //调用 super 继承父类参数 constructor(name,grade)&#123; super(name,grade); &#125; key ()&#123; console.log(&apos;I am a key man!&apos;); &#125;&#125;var xiaoming = new Student(&apos;xiaoming&apos;,86);var xiaohong = new Programmer()xiaoming.myGrade(); // xiaoming的成绩是 86xiaohong.key(); // I am a key man! 增强的对象现在，定义对象字面量更加简单，可以直接定义原型，写方法不用使用 function 关键字1234567891011var bird = &#123; fly() &#123; console.log(&apos;I can fly !&apos;); &#125;&#125;；var smallBird = &#123; _proto_: bird, //设置原型为 bird，可以继承其方法 sing() &#123; console.log(&apos;I can sing a song&apos;); &#125;&#125; for…of 循环相比 for…in ,ES6 新引入的 for…of 循环可以只循环集合本身的元素。123456789var fruit = [&apos;apple&apos;,&apos;orange&apos;,&apos;pear&apos;];// for...offor(var i of fruit) &#123; console.log(i); // apple orange pear&#125;// for...infor(var i in fruit) &#123; console.log(i); // 0 1 2&#125; 解构可以快速解析对应变量的对应参数,其中一个应用是可以快速交换变量1234567var [x,y,z] = [1,2,6];console.log(&apos;x=&apos;+x+&apos;,y=&apos;+y+&apos;,z=&apos;+z); // x=1,y=2,z=6//交换变量var x = 1;var y = 2;[x,y] = [y,x];console.log(x,y); // 2 1 关键字 argumentES6 引入了 rest 参数来获得除定义外的参数1234function foo(a,b,...rest) &#123; console.log(rest);&#125;foo(5,6,7,8,9,10,15); // (5) [7, 8, 9, 10, 15] generator(生成器)新引入的数据类型，与函数的使用类似，可以通过yield返回多次。通过function*定义，调用的时候不像普通函数那样调用，而是要通过对象的next()方法，执行到yield语句的时候，就返回一个对象{value: x,done: false},直到done: true时结束程序。12345678910111213141516function* odd(num) &#123; var n = 0; while(n &lt; num) &#123; if(n % 2 !=0)&#123; yield n; &#125; n++; &#125;&#125;var f = odd(10); //找 10 以内的奇数f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // &#123;value: 5, done: false&#125;f.next(); // &#123;value: 7, done: false&#125;f.next(); // &#123;value: 9, done: false&#125;f.next(); // &#123;value: undefined, done: true&#125; Iterable新的数据类型，Array、Map 和 Set 都属于 iterable 类型，iterable 内置的forEach方法可以更加方便地遍历数组。12var arr = [&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;];arr.forEach( i =&gt; console.log(i) ); // apple pear orange Promise 对象Promise 对象是为了解决回调函数代码冗杂问题，它支持链式操作，可在实现同样操作的情况下让代码更加得简洁123456789101112//声明一个 Promise 对象let promise = new Promise( (resolve,reject) =&gt; &#123; if(success)&#123; resolve(&apos;success&apos;); &#125;else&#123; reject(error); &#125;&#125; ).then( data =&gt; &#123; // then方法成功后的回调 console.log(data);&#125; ).catch( err =&gt; &#123; // catch方法统一捕获错误在进行处理 console.log(err);&#125; )","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"}]},{"title":"vue高仿饿了么APP总结(持续更新)","slug":"vue高仿饿了么APP总结(持续更新)","date":"2018-06-09T16:11:06.000Z","updated":"2018-06-13T14:12:48.228Z","comments":true,"path":"2018/06/10/vue高仿饿了么APP总结(持续更新)/","link":"","permalink":"http://www.brightlam.top/2018/06/10/vue高仿饿了么APP总结(持续更新)/","excerpt":"","text":"vue基础环境搭建使用 vue 脚手架 vue-cli 开启项目,npm 全局安装1npm install -g vue-cli 查看是否安装成功 vue listcd 进入到创建好的 sell (项目名称，可自取)目录下,执行 vue init webpack, 这样就创建好了一个完整项目所需的配置文件。webpack 是一个环境，它可以将各种资源打包，然后输出 js,css,渲染图片等。接着同样在主目录 sell 下执行 npm install 安装所需的依赖插件，同时建立 node_modules 目录，此目录存放所有需要用到的插件路由。如果没出现任何错误的话，执行 npm run dev ，打开浏览器输入 localhost:8080 就能进入到项目的页面了，这个页面是 vue 准备的起始页面。 准备工作流程：需求分析——项目资源准备——图标字体制作——项目目录设计——mock 数据 需求分析根据设计稿确定页面的主体结构，从内容上看，页面分为头部商家信息区以及中间的食品选择区还有最后的购物车。头部商家信息又包括左侧 logo 图片，右侧商家名称、配送信息、优惠信息，上中下排布；以及一个详细的商品信息浮窗。中间部分分为商品页、评论页和商品信息页，点击每一个标题能不刷新的切换相应的内容。底部的购物车能根据顾客所选的商品数计算价格并给予不同的信息提示。 项目资源准备导入一些设计师给的切图以及素材，方便随时查看制作。 图标字体制作进入图标制作网站 icomoon.io,点击制作按钮，选择素材图中的 SVG 图片，将其生成图标字体，点击右下角的 download 按钮下载这些图标。最后将 font 目录以及 style.css 文件拷贝到我们的项目目录下，就能使用这些图标字体了。 项目目录设计所有的代码都放在 src 目录下，其中 App.vue 是整个项目的入口文件，一般建立几个目录如 common，components 用来存放对应的文件，组件化模块的思想体现在 components 下建立各个模块的单独目录，在里面存放素材图片以及 .vue 文件，这样是为了方便就近维护。 mock数据这是很重要的一个环节，前端自己做页面，需要一些假的数据来模拟操作，后台数据存放在 data.json 中。vue2.0的话首先在 webpack.dev.conf.js 中，引入文件1234var appData = require(&apos;../data.json&apos;);var seller = appData.seller;var goods = appData.goods;var ratings = appData.ratings; 接着需要编写路由，vue2 的语法跟 vue1 不同，是这样子写路由的12345678910111213141516171819202122devServer: &#123; before(app)&#123; app.get(&apos;/api/seller&apos;,(req,res) =&gt; &#123; res.json(&#123; errno:0, data:seller &#125;) &#125;), app.get(&apos;/api/goods&apos;,(req,res) =&gt; &#123; res.json(&#123; errno:0, data:goods &#125;) &#125;), app.get(&apos;/api/ratings&apos;,(req,res) =&gt; &#123; res.json(&#123; errno:0, data:ratings &#125;) &#125;) &#125;,&#125; 页面骨架vue-router安装一个插件，现在 package.json 里配置依赖，然后执行 npm install 会自动安装好 vue-router ,如果失败报错了的话可以手动去 GitHub 下载，然后导入到项目目录下的 node_modules 下即可。 手机端 1px 像素实现在 PC 端开发可以通过 ifconfig( window 下为 ipconfig )查看 ip 地址,然后将 localhost 更换为你电脑上的 ip 地址，并且让你的手机和电脑在同一个局域网，这样就能在手机上实时预览界面。 由于 dpi 的问题，设置 1px 的 border 在电脑上看没问题，但是真正在手机上显示却是 2px 的粗线，为了解决这一问题，就需要写一个方法，在不同的 dpi 上适应不同的样式,这里使用的是 styl 语法1234567891011121314151617181920212223//统一写方法，方便重复调用border-1px($color) position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: &apos;&apos;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7);@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5); 六 head 组件请求后端数据-vue-resource先在 package.json 中吧 deploy 写好，然后在 main.js 中引入12import VueResource from &apos;vue-resource&apos;;Vue.use(VueResource); 接着在 App.vue 中加入如下代码1234567891011121314151617181920&lt;script type=&quot;text/ecmascript-6&quot;&gt; const ERR_OK = 0; export default &#123; data () &#123; return &#123; seller: &#123; avatar: &apos;http://static.galileo.xiaojukeji.com/static/tms/seller_avatar_256px.jpg&apos; &#125; &#125;; &#125;, created () &#123; this.$http.get(&apos;/api/seller&apos;).then((response) =&gt; &#123; response = response.body; if (response.errno === ERR_OK) &#123; this.seller = response.data; &#125; &#125;); &#125; &#125;;&lt;/script&gt; 此时数据已全部获取并且存储到 sell 数组中。 七 good 组件开发better-scroll 运用使用 better-scroll 库可以使组件上下滑动，无滚动条。1234567891011_initScroll() &#123; this.meunScroll = new BScroll(this.$refs.menuWrapper, &#123; click: true &#125;); this.foodsScroll = new BScroll(this.$refs.foodsWrapper, &#123; probeType: 3 &#125;); this.foodsScroll.on(&apos;scroll&apos;, (pos) =&gt; &#123; this.scrollY = Math.abs(Math.round(pos.y)); &#125;); &#125; 初始化，注意:为了在页面载时能够让 DOM 准确计算内容区滑动的高度，上面的方法要放在 vue 提供的 $nextTick() 中，确保下次 DOM 更新循环结束之后执行延迟回调。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.brightlam.top/tags/vue/"}]},{"title":"轻松实现响应式——CSS变量","slug":"轻松实现响应式——CSS变量","date":"2018-06-05T08:04:38.000Z","updated":"2018-06-20T10:07:29.049Z","comments":true,"path":"2018/06/05/轻松实现响应式——CSS变量/","link":"","permalink":"http://www.brightlam.top/2018/06/05/轻松实现响应式——CSS变量/","excerpt":"","text":"CSS 变量是 CSS 引入的一个新特性，目前绝大多数浏览器已经支持了，它可以帮助我们用更少的代码写出同样多的样式，大大提高了工作效率，本篇文章将教你如何使用 CSS 变量（css variable）。 变量声明使用 :root 来声明 css 变量，root 相当于根元素 html，例如声明一个背景颜色为红色的 red 变量,示例如下123:root&#123; --red: #f00;&#125; 如何应用这个变量呢？使用 var() 函数。123div&#123; background-color: var(--red);&#125; 这样，我们就给一个 div 盒子添加了一个属性，即设置它的背景颜色为红色。当然也可以同时定义多个变量，方便使用，注意：变量名对大小写敏感，nav-color 和 Nav-color 是完全不同的变量。123456:root&#123; --margin-top: 20px; --nav-color: #ff0; --Nav-color: #fff; --transition-duration: .5s;&#125; 全局变量与局部变量前面我们在 :root里声明的变量都属于全局变量，也就是可以在 html 包裹下的任一class，id 都可以使用它；除此之外也可以定义局部变量，例如我们在 class 为 left 的 div 下定义局部变量：1234.left&#123; --left-margin: 60px; --left-background-color: #333;&#125; 这个时候，–left-margin 和 –left-background-color 就只能在 .left 包含下的容器才能使用这两个属性，同样是使用margin:var(--left-margin);来书写。 JavaScript 操作变量JavaScript 可以操纵 css 变量，例如在 index.js 文件中有如下代码：1234var root = document.querySelector(&apos;:root&apos;); //获取根元素var rootStyle = getComputedStyle(root); //获取元素的 cssvar red = rootStyle.getPropertyValue(&apos;--left-margin&apos;); //获取 css 的样式值 60pxroot.style.setProperty(&apos;--left-margin&apos;,&apos;50px&apos;); //更改样式 响应式布局由于事先定义好了变量，只需引入就可以使用，这样的话当我们想要修改一个属性值，例如修改某个盒子的背景颜色，只需更改变量的值，就可以全局应用到所有元素中，利用这一特性可以做响应式布局。1234567891011121314:root&#123; --bg-color: #fff; --height: 1080px;&#125;body&#123; background-color: var(--bg-color); height: var(--height);&#125;@media all and (max-width:450px) &#123; :root&#123; --bg-color: #000; --height: auto; &#125;&#125; 上面的代码表示正常宽度下的 body 背景颜色为白色，高度为 1080 像素,而当宽度为 450px 大小的时候，此时 body 的背景颜色就变为了黑色，高度也变成自适应，只需要更改变量的值就可以实现响应，是不是很方便呢？ 最后，附上一张 css variables 的浏览器兼容图： 图片来自网络","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.brightlam.top/tags/CSS/"}]},{"title":"CSS布局之 flex 布局","slug":"CSS布局之-flex-布局","date":"2018-05-27T08:31:37.000Z","updated":"2018-05-28T15:59:05.218Z","comments":true,"path":"2018/05/27/CSS布局之-flex-布局/","link":"","permalink":"http://www.brightlam.top/2018/05/27/CSS布局之-flex-布局/","excerpt":"","text":"在学 CSS 的时候偶尔都会碰到 flex 布局，由于一直以来都使用传统的 display ，float ，以及 position 来实现基本的布局，因此对 flex 布局没有过多的了解。但对于一些特殊的布局，flex 布局会相对友好些。于是在网上查了资料学习后，也用这篇文章来记录下。 首先要了解下什么是 flex 布局，来看下 MDN web docs 对其的解释： Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。 当我们需要给容器设置 flex 布局时，只需添加如下代码：1234body&#123; display: -webkit-flex; /* webkit 内核的浏览器适配 */ display: flex;&#125; 了解 flex 布局，首先是两根轴线–主轴以及交叉轴，主轴有 flex-direction 定义，另一轴垂直于它。其次是下面这 6 个属性：123456- flex-direction- flex-wrap- flex-flow- justify-content- align-items- align-content flex-direction 有 4 个取值，row | row-reverse | column | column-reverserow | row-reverse 表示主轴沿着横排的方向也就是 inline 方向延伸，reverse 表示起点从右端开始，默认在左端column | column-reverse 表示主轴沿着竖排方向也就是 block 方向延伸，reverse 表示起点从下开始，默认在上 flex-wrap 定义如何换行，有 3 个取值 nowrap | wrap | wrap-reversenowrap 为不换行，wrap 为换行，wrap-reverse 也为换行，但是从下往上排 flex-flow flex-direction 与 flex-wrap 的简写，默认值为 row nowrap justify-content 定义在主轴上的对齐方式。有 5 个值 flex-start(左对齐) | flex-end(右对齐) | center(居中) | space-between(两端对齐) | space-around(两侧间距相等); align-items 定义在交叉轴上的对齐方式，有 5 个值 flex-start(起点对齐) | flex-end(终点对齐) | center(居中) | baseline(第一行文字的基线对齐) | stretch(默认值，占满容器高度) align-content 定义多根轴线在交叉轴的对齐方式，如果只有一根轴线，该属性不起作用，有 6 个值 flex-start：起点对齐。 flex-end：终点对齐。 center：与交叉轴的中点对齐。 space-between：轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 除此之外，还有其它一些属性值得了解。 order属性-优先级定义项目的排列顺序。数值越小，排列越靠前。 flex-grow-放大定义项目的放大比例，默认为 0 。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink-缩小定义项目的缩小比例，默认为 1。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 参考资料: flex布局的基本概念语法篇 - 阮一峰的网络日志","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.brightlam.top/tags/CSS/"}]},{"title":"JS学堂:小米商城右侧导航栏效果","slug":"JS学堂-小米商城右侧导航栏效果","date":"2018-05-18T15:03:01.000Z","updated":"2018-05-20T03:21:18.527Z","comments":true,"path":"2018/05/18/JS学堂-小米商城右侧导航栏效果/","link":"","permalink":"http://www.brightlam.top/2018/05/18/JS学堂-小米商城右侧导航栏效果/","excerpt":"","text":"侧边导航栏以及回到顶部已经越来越成为每个网站的必要功能之一，主要向网站的访客展示一些电话、客服QQ、邮箱或者其它信息，通常附带一个「回到顶部」的箭头。网上有很多关于这类效果的例子，姑且自己也总结一个出来，有需要的可以参考。不同的样式效果虽然不同，但原理都是差不多的，下面以小米商城的右侧栏为例 小米商城 用到的主要知识点： 1.css display 属性; 2.jQuery mouseenter 以及 mouseleave 属性 3.jQuery 动画 从上面的演示图可以看到，小米商城的右侧边栏是由五个带图标及文字的正方形盒子竖着排列的，每一个盒子的宽高都是相等的，分别有 1px 的描边。最后一个盒子「回到顶部」与上边四个有一定的间隙，默认是隐藏的，只有当鼠标滚动滚轮到一定高度后才显示出来。 了解了基本的布局后下面开始写 HTML 布局，在开始之前，先做一些准备工作，引入本次效果需要用到的 jQuery 文件，并且新建一个 demo.css 样式文件以及 demo.js 逻辑文件将其引入到新建好的 HTML 文件中 : 123&lt;link rel=\"stylesheet\" href=\"css/demo.css\" type=\"text/css\"&gt;&lt;script src=\"js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/demo.js\"&gt;&lt;/script&gt; 现在，创建一个 id 为 top 的 div 盒子，在里面创建一个 id 为 izl_rmenu，class 也为 izl_rmenu 的 div 标签，接着分别用 1 个 a 标签以及 4 个 div 标签代表侧边栏的五个盒子按钮，代码如下 :12345678910111213141516171819202122232425&lt;div id=\"top\"&gt; &lt;div id=\"izl_rmenu\" class=\"izl-rmenu\"&gt; &lt;a href=\"javascript:;\" class=\"btn btn-sao\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/cc0b8948a88a08f6f3b7cd826e09ace6.png\" alt=\"\" class=\"sao-before\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/1012b08b8f0268aab455c56027109a34.png\" alt=\"\" style=\"display: none\" class=\"sao-hover\"&gt; &lt;p&gt;扫一扫&lt;/p&gt; &lt;/a&gt; &lt;div class=\"btn btn-user\"&gt; &lt;img class=\"pic\" src=\"https://i8.mifile.cn/b2c-mimall-media/55cad219421bee03a801775e7309b920.png\" onclick=\"window.location.href='http://%77%77%77%2e%73%75%63%61%69%6a%69%61%79%75%61%6e%2e%63%6f%6d'\"&gt; &lt;p&gt;个人中心&lt;/p&gt; &lt;/div&gt; &lt;div class=\"btn btn-kefu\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/4f036ae4d45002b2a6fb6756cedebf02.png\" alt=\"\"&gt; &lt;p&gt;联系客服&lt;/p&gt; &lt;/div&gt; &lt;div class=\"btn btn-shop\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/d7db56d1d850113f016c95e289e36efa.png\" alt=\"\"&gt; &lt;p&gt;购物车&lt;/p&gt; &lt;/div&gt; &lt;div class=\"btn btn-top\"&gt; &lt;img src=\"//i1.mifile.cn/f/i/2018/home/totop.png\" alt=\"\"&gt; &lt;p&gt;回顶部&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 由于没有添加任何样式，现在的效果是这样子的 : 仿小米商城的侧边栏 现在我们给它添加一些 css 样式，在 demo.css 文件中添加12*&#123;margin:0;padding:0;list-style:none;border:none;text-decoration: none&#125;body&#123;height:2000px;font-family: 微软雅黑;background-color: #f5f5f5;&#125; 这样就重置了默认的 css 样式。接着我们给整个容器设置一个「固定定位」，好让它始终固定在页面的特定位置处，12345678.izl-rmenu&#123; position: fixed; left: 50%; margin-left: 532px; bottom: 10px; padding-bottom: 73px; z-index: 999;&#125; 然后，我们给每个按钮设置一些共同的样式，包括定义他们的宽高以及水平居中排布，特别注意的是，这里我使用了 display:table ，再结合 vertical-align 还有 text-align 两个属性来使它水平垂直居中，12345678910111213.izl-rmenu .btn&#123; width: 82px; height: 90px; margin-bottom:1px; cursor:pointer; position:relative; border: 1px solid #f5f5f5; color: #757575; display: table; vertical-align: center; text-align: center; background-color: #fff;&#125; 最后，分别给每个 img 标签也就是每个小图标设置宽度还有高度，给回到顶部这个容器添加一些样式，12345678910.izl-rmenu .btn img&#123; padding-top: 20px; width: 30px; height: 30px;&#125;.izl-rmenu .btn-top&#123; background-color: #fff; margin-top: 15px;&#125; 现在的效果如图， 仿小米商城的侧边栏 可以看到，目前的样式与小米商城里的样式已基本差不多了，但现在的效果都是静态的，鼠标滑过并没有什么特效，点击回到顶部也没任何反应，下面就来添加 js 来使它有交互效果样例效果中当鼠标滑过时会有图标及文字变色的效果，原理是在 HTML 中设置两张图片，一张是鼠标未经过时的图片，一张是鼠标滑过的时候变色的图片，这里我们用 JavaScript 的框架之一 jQuery 来制作动效。首先，在原先 HTML 布局中添加一张鼠标滑过时的 img ,并且分别设置它们的 class ，以便使用 jQuery 选择器来获取，依次在每个 class 为 btn 的容器下追加一个 img 标签 12345678910111213141516171819202122232425&lt;a href=\"javascript:;\" class=\"btn btn-sao\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/cc0b8948a88a08f6f3b7cd826e09ace6.png\" alt=\"\" class=\"sao-before\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/1012b08b8f0268aab455c56027109a34.png\" alt=\"\" style=\"display: none\" class=\"sao-hover\"&gt; &lt;p&gt;扫一扫&lt;/p&gt;&lt;/a&gt;&lt;div class=\"btn btn-user\"&gt; &lt;img class=\"user-before\" src=\"https://i8.mifile.cn/b2c-mimall-media/55cad219421bee03a801775e7309b920.png\" onclick=\"window.location.href='http://%77%77%77%2e%73%75%63%61%69%6a%69%61%79%75%61%6e%2e%63%6f%6d'\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/41f858550f42eb1770b97faf219ae215.png\" alt=\"\" style=\"display: none\" class=\"user-hover\"&gt; &lt;p&gt;个人中心&lt;/p&gt;&lt;/div&gt;&lt;div class=\"btn btn-kefu\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/4f036ae4d45002b2a6fb6756cedebf02.png\" alt=\"\" class=\"kefu-before\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/5e9f2b1b0da09ac3b3961378284ef2d4.png\" alt=\"\" style=\"display: none\" class=\"kefu-hover\"&gt; &lt;p&gt;联系客服&lt;/p&gt;&lt;/div&gt;&lt;div class=\"btn btn-shop\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/d7db56d1d850113f016c95e289e36efa.png\" alt=\"\" class=\"shop-before\"&gt; &lt;img src=\"https://i8.mifile.cn/b2c-mimall-media/692a6c3b0a93a24f74a29c0f9d68ec71.png\" alt=\"\" style=\"display: none\" class=\"shop-hover\"&gt; &lt;p&gt;购物车&lt;/p&gt;&lt;/div&gt;&lt;div class=\"btn btn-top\"&gt; &lt;img src=\"//i1.mifile.cn/f/i/2018/home/totop.png\" alt=\"\" class=\"top-before\"&gt; &lt;img src=\"//i1.mifile.cn/f/i/2018/home/totop_hover.png\" alt=\"\" style=\"display: none\" class=\"top-hover\"&gt; &lt;p&gt;回顶部&lt;/p&gt;&lt;/div&gt; 打开 demo.js 文件，添加如下代码 : 1234567891011121314151617181920212223242526272829303132$(document).ready(function ()&#123; /* 使用 jq 的 each() 方法遍历整个大的 div 容器，在用 find() 方法寻找当前容器下的子容器，mouseenter 和 mouseleave分别 为鼠标滑过和鼠标移出时的事件，css() 方法设置所选元素的样式，这里只列举了一个示例代码，要让五个容器都有鼠标滑过的效果， 只需复制黏贴代码，更改其 find 方法对应的 class 名称就能作用到所有容器上。 */ $('#izl_rmenu').each(function () &#123; $(this).find(\".btn-sao\").mouseenter(function () &#123; $(this).find(\".sao-before\").css('display','none'); $(this).find(\".sao-hover\").css(&#123; 'display':'table', 'position':'relative', 'left':'26px' &#125;); $(this).find('p').css(&#123; 'position':'relative', 'top':'4px', 'color':'#ff6700' &#125;); &#125;); $(this).find(\".btn-sao\").mouseleave(function () &#123; $(this).find(\".sao-before\").css('display',''); $(this).find(\".sao-hover\").css(&#123; 'display':'none' &#125;); $(this).find('p').css(&#123; 'position':'', 'top':'', 'color':'' &#125;); &#125;); &#125;);&#125;); 做完这个效果后，可以看到当鼠标滑动到「扫一扫」容器时，会显示一个二维码，原理是在父容器内设置一个 div ，里面存放二维码文字，默认为隐藏状态，当鼠标滑过的时候，就将其显示出来。下面来实现这个效果。 首先在 HTML 文件中 class 为 ‘btn btn-sao’ 的 a 标签中添加布局代码 123456 &lt;div class=\"pic\"&gt; &lt;div class=\"pic_content\"&gt; &lt;img class=\"pic_img\" src=\"https://i8.mifile.cn/b2c-mimall-media/2ecd36165b6c2a820a0488fa7a2c4942.png\" alt=\"\"&gt; &lt;span style=\"display: block\"&gt;微信扫一扫&lt;br&gt;一分钱拼团&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 添加 css ,设置样式并将其隐藏 : 12345678910111213141516171819.izl-rmenu .pic&#123; position: absolute; left: -136px; top: 0; height: 187px; display: none; &#125;.izl-rmenu .pic .pic_content&#123; float: left; height: 187px; background-color: #fff; border: 1px solid #f5f5f5;&#125;.izl-rmenu .pic .pic_content img&#123; width: 100px; height: 100px; border: none; margin: 5px 14px;&#125; 使用 jQuery ，在 $(this).find(“.btn-sao”).mouseenter(function () { … } 代码块中添加鼠标经过时显示二维码的代码 : 1$(this).find('.pic').fadeIn(); 在 $(this).find(“.btn-sao”).mouseleave(function () { … } 代码块中添加鼠标移出时隐藏的代码 : 1$(this).find('.pic').fadeOut(); 来看下当前页面的效果 : 现在还差最后一个「回到顶部」效果，这个使用 jQuery 也非常简单，只需在 $(‘#izl_rmenu’).each(function () { … } 代码块中添加如下代码 : 12345$(this).find(\".btn-top\").click(function()&#123; $(\"html, body\").animate(&#123; \"scroll-top\":0 &#125;,\"fast\");&#125;); 这样就能轻松实现回到顶部，但是一般的网站默认会吧「回到顶部」隐藏起来，只有当鼠标滚轮滚到一定高度后才显示按钮，这样的交互效果显然更符合用户需求。于是我们在将其优化一下，在全局 $(document).ready(function (){ … } 代码块里加上如下代码 : 1234567891011121314151617 var lastRmenuStatus=false; $(window).scroll(function()&#123; var _top=$(window).scrollTop(); if(_top&gt;200)&#123; $(\"#izl_rmenu\").data(\"expanded\",true); &#125;else&#123; $(\"#izl_rmenu\").data(\"expanded\",false); &#125; if($(\"#izl_rmenu\").data(\"expanded\")!=lastRmenuStatus)&#123; lastRmenuStatus=$(\"#izl_rmenu\").data(\"expanded\"); if(lastRmenuStatus)&#123; $(\"#izl_rmenu .btn-top\").slideDown(\"fast\"); &#125;else&#123; $(\"#izl_rmenu .btn-top\").slideUp(\"fast\"); &#125; &#125;&#125;); 别忘了在 HTML 标签里加上 display: none 属性来使页面加载时默认隐藏按钮 :1&lt;div class=\"btn btn-top\" style=\"display: none\"&gt; ... &lt;/div&gt; 好了，至此所有效果都有了，一个小米商城的右侧栏呈现在眼前 : 仿小米商城的侧边栏 查看源码请移步 GitHub :jQuery制作小米商城侧边栏效果喜欢就 star 一下吧。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://www.brightlam.top/tags/前端/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.brightlam.top/tags/jQuery/"}]},{"title":"PS婚纱抠图","slug":"PS婚纱抠图","date":"2018-05-09T08:45:44.000Z","updated":"2018-05-18T15:38:49.922Z","comments":true,"path":"2018/05/09/PS婚纱抠图/","link":"","permalink":"http://www.brightlam.top/2018/05/09/PS婚纱抠图/","excerpt":"","text":"不管你是否对 Photoshop 有深入的研究，现在抠图、修图已成为很多大学生的必备技能， 在这篇博客中，你将学习到抠图，将下面图 1 中的人以及婚纱抠出来，放到图 2 的风景图中， 图 1 图 2 首先在 Photoshop 中打开图 1 的婚纱照，再把图 2 的风景图置入，按住 Ctrl + T 自由变换图 2，将其缩放到与图 1 一样大小，然后鼠标按住背景图层，将其拖到下方有个「创建新图层」的角标拷贝图层，然后鼠标拖动拷贝图层到风景图层的上方，在拷贝一次背景图层，此时图层的分布及顺序如下 图 层 现在准备工作做好了，开始来将人物及婚纱抠出，我们先来扣婚纱，点击「背景拷贝 2」选中其中一个婚纱图层，执行图像-调整-去色命令，快捷键是 Ctrl + shift + U，我们想要并且只扣出婚纱，那就要拿到婚纱的选区，于是使用「快速选择工具」，细致地将婚纱部分给圈起来，在这个过程中可能会选到一些不必要的区域，所以在框选完后建立一个蒙版图层，用画笔工具，调节前景色与背景色，黑色去掉不想被框选的区域，白色框选增加的区域，这个过程要有耐心，最终成功地拿到了婚纱的选区 扣取婚纱 现在婚纱的选区已经成功拿到了，接下来我们点击「背景 拷贝」图层，开始来扣图片中的人物，去掉背景。同样使用「快速选择工具」将除人物以及婚纱之外的地方全部框选住，然后新建蒙版层，此时会发现人物不见了，替代显示的是风景，只需点击蒙版面板下的「反相」，此时背景已经去掉，我们想要的效果渐渐出来了，效果如下 扣取人物 现在我们发现，这个模特的头部以及脖子部分有缺失，还有就是婚纱部分还没有把它完全透明化，我们先鼠标选中「背景 拷贝」这个图层的蒙版图层，应用画笔，把前景色调成白色，在模特身上缺失的地方进行轻微涂抹，即可把扣掉的部分还原回来，你也可以看看其他地方是否也有残缺，使用画笔进行修复即可。 最后我们按住 Ctrl 键鼠标单击「背景 拷贝 2」图层，取到选区，在单击「背景 拷贝」的蒙版图层，注意是要蒙版图层才行，把背景色调为黑色，按 Ctrl + delete，此时婚纱选区已经填充掉了，但此时婚纱还是灰色的，显然不符合目前的场景，我们可以设置图层混合模式来得到我们想要的效果：按住 Ctrl + D 取消选区，然后点击「背景 拷贝 2」图层，将图层的混合模式设置为叠加，如图所示，当然你也可以根据自己的喜好设置其它的图层混合模式， 选择混合模式 大功告成！最终的效果图如下： 用到的素材图： 人物婚纱照：点我获取 风景图：点我获取 喜欢就随手分享一下吧！欢迎关注我的博客！","categories":[],"tags":[{"name":"PS","slug":"PS","permalink":"http://www.brightlam.top/tags/PS/"}]},{"title":"学会用PS制作相框","slug":"学会用PS制作相框","date":"2018-05-06T15:51:50.000Z","updated":"2018-05-08T16:40:46.389Z","comments":true,"path":"2018/05/06/学会用PS制作相框/","link":"","permalink":"http://www.brightlam.top/2018/05/06/学会用PS制作相框/","excerpt":"","text":"有时候拍了一张图片想分享到社交网络上，单单把整张图片放上去有些许单薄，这时可以尝试用 PS 制作一个相框，小小地美化一下，看起来也舒服些。首先选择你想制作相框的图片，打开 Photoshop ，把图片直接拖进就可以开始编辑。制作相框的简单步骤如下：第一步，双击右下角图层面板，此时会弹出一个「新建图层」的提示框，点击「确定」即可解锁背景图层，这里随便选取了以下图片： 效果图 第二步，使用「裁剪工具」，按住鼠标拉出和图片等宽高的虚线框，按住 ALT 键把右边线往外拉，此时图片左右两边都会有一个空白区域，双击完成 两边裁剪的效果 同理按住 ALT 键在最上面的点往上一拽，现在图片四周都出现了留白 四周裁剪后的效果 第三步，新建一个图层，将此图层拖至最底层，点击左侧工具栏的「渐变工具」，选择你喜欢的渐变颜色，然后呈对角线地往图片一拉，就填充了相框的颜色。 此时的效果 此时的图层面板是这样子的 第四步，键盘按住 Ctrl 键鼠标点击图层 0 的缩略图，此时选取了图片的选区，接着鼠标单击图层 1，按 Delete 键，这样才真正拿到了相框的选区 当然，这样看一个相框好像还差点意思，如果还想有更多的效果，我们可以双击图层 1 的空白处，调出图层样式面板， 添加「斜面和浮雕」以及「图案叠加」效果，这些效果并不是唯一的，视个人而定，你喜欢什么样的就调出你所想要的效果即可。 最终我们完成了这样一个相框的效果： 喜欢就自己动手尝试一下，用 Photoshop 尽情去制作出炫酷的相框吧！","categories":[],"tags":[{"name":"PS","slug":"PS","permalink":"http://www.brightlam.top/tags/PS/"}]},{"title":"js实现轮播图效果","slug":"js实现轮播图效果","date":"2018-04-30T02:12:21.000Z","updated":"2018-05-12T16:29:15.229Z","comments":true,"path":"2018/04/30/js实现轮播图效果/","link":"","permalink":"http://www.brightlam.top/2018/04/30/js实现轮播图效果/","excerpt":"","text":"现在很多网站都会用到轮播图效果，轮播图的应用会给你的网站增色不少，本文将一步步带你用原生JavaScript捣鼓出一个轮播图，如果有不正确的地方希望指出，一起交流讨论，先来看下轮播图用到的基本知识点:1.绝对定位与相对定位2.overflow: hidden;3.闭包 HTML布局12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;js轮播图效果&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"banner\"&gt; &lt;ul class=\"list\" style=\"left: -600px\"&gt; &lt;li&gt; &lt;img src=\"5.jpg\" alt=\"第五张\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"1.jpg\" alt=\"第一张\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"2.jpg\" alt=\"第二张\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"3.jpg\" alt=\"第三张\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"4.jpg\" alt=\"第四张\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"5.jpg\" alt=\"第五张\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"1.jpg\" alt=\"第一张\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"buttons\"&gt; &lt;span class=\"on\"&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href=\"javascript:;\" class=\"arrow\" id=\"prev\"&gt;&amp;lt;&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"arrow\" id=\"next\"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一共有 5 张图片参与轮播，但我们布局里却用了7张图片，这是为了实现无缝连接，即播放到第五张的时候，紧接着第一张。5个span标签即 5 个小圆点，用来指示当前为第几张图片。两个a标签用来进行上一张和下一张的点击。这里给ul设置 left: -600px; 是为了正确地显示第一张图片，而不是显示第五张。 CSS代码建立了基本的页面布局后，首先重置下css,如下:12345678910*&#123; margin: 0; padding: 0;&#125;li&#123; list-style: none;&#125;a&#123; text-decoration: none;&#125; 接着，我们给 id 为 banner 的容器设置宽度为 600px,高度为 400px,给它设置一个 overflow 为 hidden.这个属性可以将超出容器宽高的部分隐藏掉，原理是将 7 张图片放在同一行上，然后只保留一张，把其余的图片 hidden 掉，给父容器设置相对定位，在让 7 张图片相对于父容器进行绝对定位，于是便可以通过 style.left 属性来控制图片的更换了。1234567#banner&#123; width: 600px; height: 400px; position: relative; overflow: hidden; margin: 0 auto;&#125; 图片相对父容器绝对定位，z-index显示层级，这里为1。123456.list&#123; width: 4200px; height: 400px; position: absolute; z-index: 1;&#125; 使用浮动让7张图片排成一排：12345.list li img&#123; width: 600px; height: 400px; float: left;&#125; 接下来设置5个小圆点的样式，依然使用绝对定位将它们放在图片正下方并给第一个圆点设置一个 .on 类指示当前轮播图片12345678910111213141516171819.buttons&#123; position: absolute; bottom: 10px; right: 250px; z-index: 2; //这里为2，意味着层级比刚刚的图片容器1要高，所以圆点会覆盖在图片的上方&#125;.buttons span&#123; margin-left: 5px; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: \\#fff; color:white; cursor: pointer;&#125;.buttons .on&#123; background-color: \\#00acec;&#125; 最后就是前进与后退箭头了，依然如前面一样绝对定位，z-index为2123456789101112131415161718192021222324252627.arrow&#123; cursor: pointer; display: none; line-height: 38px; text-align: center; font-size: 36px; font-weight: bold; width: 40px; height: 40px; position: absolute; z-index: 2; top: 180px; text-decoration: none; color: #fff;&#125;.arrow:hover&#123; background: #ececec;&#125;#banner:hover .arrow&#123; display: block;&#125;#prev&#123; left: 10px;&#125;#next&#123; right: 10px;&#125; 至此，CSS样式已经添加完毕，来看下当前的静态效果: 效果图 JavaScript代码页面布局与样式设置好后，使用 js 来添加轮播逻辑:首先我们获取到 list 容器，通过控制它的left值来轮播图片，即每次点击触发一个 onclick 事件，将 list 的 left 值加/减上 600（1张图片的宽度），这里特别注意的是，当 left的值向右一直加到 -3600px 时，也就是此时播到我们用来无缝衔接的第 1 张图片，这个时候就要手动将 left 值更改为 -1200 ，也就是说，在点击则调回到第 1 张图片播放，这样每次播到最后一张图片的时候，它就会跳回到第 2 张图片，这样就能循环下去；同理，当点击向左的按钮时，left值不断地在往回退，一直到 left 为 0,此时已经到最左边的第一张了，我们把它的值重置到第倒数第二张图片那里，这样就又继续循环下去。123456789101112131415161718192021222324252627var list = document.querySelector('.list');var prev = document.getElementById('prev');var next = document.getElementById('next'); next.onclick = function()&#123; next_pic(); &#125;; prev.onclick = function()&#123; prev_pic(); &#125;; function next_pic()&#123; var newleft; if(list.style.left === '-3600px')&#123; newleft = -1200; &#125;else&#123; newleft = parseInt(list.style.left)-600; &#125; list.style.left = newleft + 'px'; &#125; function prev_pic()&#123; var newleft; if(list.style.left === '0px')&#123; newleft = -2400; &#125;else &#123; newleft = parseInt(list.style.left) + 600; &#125; list.style.left = newleft + 'px'; &#125; 看下效果: 效果图 现在图片已经可以手动点击播放了，我们希望能自动播放，只需添加下面这个函数:12345678var timer;function autoplay()&#123; clearInterval(timer); timer = setInterval(function()&#123; next_pic(); &#125;,2000);&#125;autoplay(); 现在它可以自动播放了，效果是这样子： 效果图 此时在给它添加一个函数，鼠标移上去的时候停止播放，当鼠标移出的时候就让它自动播放:123456var banner = document.getElementById('banner');function stop()&#123; clearInterval(timer);&#125;banner.onmouseover = stop;banner.onmouseout = autoplay; 做到现在，我们发现当图片轮播的时候，下方的小圆点没有跟着变，现在我们来改变它。实现原理是设置一个全局的变量 index,当点击右箭头时，在 next_pic 函数里让 index++；当点击左箭头时，在 prev_pic 函数里让 index–，然后设置当前 index 的圆点的 class 为 on,同样，当 index++ 到 5 时，要归为 0 从头开始；当 index– 到 0 时，归为 4 使其向左继续递减，代码如下：12345678var index = 0;var buttons = document.querySelector('.buttons').getElementsByTagName('span');function showButton()&#123; for(var i = 0;i&lt;buttons.length;i++)&#123; buttons[i].className = \"\"; &#125; buttons[index].className = \"on\";&#125; 在 next_pic() 函数里添加:12345index++;if(index &gt; 4)&#123; index = 0;&#125;showButton(); 在 prev_pic() 函数里添加:12345index--;if(index &lt; 0)&#123; index = 4;&#125;showButton(); 此时小圆点就可以跟着图片的改变而改变当前圆点的颜色了。最后一个功能就是，当点击小圆点时，相应的图片也要跟着变化，这里可以用闭包来实现,当点击小圆点时，通过比较当前圆点的 index 值与全局变量 index 来重新计算 left 值。1234567891011121314151617for (var i = 0;i&lt;buttons.length;i++)&#123; (function(i)&#123; buttons[i].onclick = function () &#123; var curr = index - i; if(index === 4 &amp;&amp; parseInt(list.style.left)!==-3000)&#123; curr = curr - 5; &#125; if(index === 0 &amp;&amp; parseInt(list.style.left)!== -600)&#123; curr = 5 + curr; &#125; list.style.left = (parseInt(list.style.left) + curr * 600)+\"px\"; index = i; showButton(); &#125; &#125;)(i); &#125; 最终就实现了一个轮播图的效果: 效果图 完整代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;js轮播图效果&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; li&#123; list-style: none; &#125; a&#123; text-decoration: none; &#125; #banner&#123; width: 600px; height: 400px; position: relative; overflow: hidden; margin: 0 auto; &#125; .list&#123; width: 4200px; height: 400px; position: absolute; z-index: 1; &#125; .list li img&#123; width: 600px; height: 400px; float: left; &#125; .buttons&#123; position: absolute; bottom: 10px; right: 250px; z-index: 2; &#125; .buttons span&#123; margin-left: 5px; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: #fff; color:white; cursor: pointer; &#125; .buttons .on&#123; background-color: #00acec; &#125; .arrow&#123; cursor: pointer; display: none; line-height: 38px; text-align: center; font-size: 36px; font-weight: bold; width: 40px; height: 40px; position: absolute; z-index: 2; top: 180px; text-decoration: none; color: #fff; &#125; .arrow:hover&#123; background: #ececec; &#125; #banner:hover .arrow&#123; display: block; &#125; #prev&#123; left: 10px; &#125; #next&#123; right: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"banner\"&gt; &lt;ul class=\"list\" style=\"left: -600px\"&gt; &lt;li&gt; &lt;img src=\"5.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"1.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"2.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"3.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"4.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"5.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=\"1.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"buttons\"&gt; &lt;span class=\"on\"&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href=\"javascript:;\" class=\"arrow\" id=\"prev\"&gt;&amp;lt;&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"arrow\" id=\"next\"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt; &lt;script&gt; 'use strict'; window.onload = function () &#123; var banner = document.getElementById('banner'); var list = document.querySelector('.list'); var prev = document.getElementById('prev'); var next = document.getElementById('next'); var buttons = document.querySelector('.buttons').getElementsByTagName('span'); var timer; var index = 0; next.onclick = function()&#123; next_pic(); &#125;; prev.onclick = function()&#123; prev_pic(); &#125;; function next_pic()&#123; var newleft; if(list.style.left === '-3600px')&#123; newleft = -1200; &#125;else&#123; newleft = parseInt(list.style.left)-600; &#125; list.style.left = newleft + 'px'; index++; if(index &gt; 4)&#123; index = 0; &#125; showButton(); &#125; function prev_pic()&#123; var newleft; if(list.style.left === '0px')&#123; newleft = -2400; &#125;else &#123; newleft = parseInt(list.style.left) + 600; &#125; list.style.left = newleft + 'px'; index--; if(index &lt; 0)&#123; index = 4; &#125; showButton(); &#125; function autoplay()&#123; clearInterval(timer); timer = setInterval(function()&#123; next_pic(); &#125;,2000); &#125; function stop()&#123; clearInterval(timer); &#125; autoplay(); banner.onmouseover = stop; banner.onmouseout = autoplay; function showButton()&#123; for(var i = 0;i&lt;buttons.length;i++)&#123; buttons[i].className = \"\"; &#125; buttons[index].className = \"on\"; &#125; for (var i = 0;i&lt;buttons.length;i++)&#123; (function(i)&#123; buttons[i].onclick = function () &#123; var curr = index - i; if(index === 4 &amp;&amp; parseInt(list.style.left)!==-3000)&#123; curr = curr - 5; &#125; //和使用prev和next相同，在最开始的照片5和最终的照片1在使用时会出现问题，导致符号和位数的出错，做相应地处理即可 if(index === 0 &amp;&amp; parseInt(list.style.left)!== -600)&#123; curr = 5 + curr; &#125; list.style.left = (parseInt(list.style.left) + curr * 600)+\"px\"; index = i; showButton(); &#125; &#125;)(i); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://www.brightlam.top/tags/前端/"}]},{"title":"js面向对象编程(三)","slug":"js面向对象编程-三","date":"2018-04-27T09:52:28.000Z","updated":"2018-05-12T16:29:03.421Z","comments":true,"path":"2018/04/27/js面向对象编程-三/","link":"","permalink":"http://www.brightlam.top/2018/04/27/js面向对象编程-三/","excerpt":"","text":"class继承之前讲到JavaScript中并没有类的概念，所以只能通过原型去实现类以及继承的效果，这样做代码实现量大，而且还要实现正确的原型链指向，比较麻烦。现在，最新的ES6开始引入了新的class关键字，终于可以像写Java的类那样写JavaScript的继承了！之前用函数实现类Student是这样的：123456function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert('hello,'+this.name+'!');&#125; 而现在有了class，我们可以这样子写：class Student { constructor(name){ this.name = name; } hello() { alert(‘helo,’+this.name+’!’); }}可以看到，有了class后，方便简洁了许多，代码量大大地减少。此时实例化一个对象也非常简单：12var xiaoming = new Student('小明');xiaoming.hello(); class继承现在实现一个类的继承也非常简单，通过extends关键字。12345678910class PrimaryStudent extends Student() &#123; constructor(name,grade)&#123; super(name); //通过super来调用父类的构造函数 this.grade = grade; &#125; myGrade() &#123; alert('I am at grade'+this.grade); &#125;&#125; PrimaryStudent类作为Student的子类，同样可以获取父类的hello方法，除此之外，它还定义了属于自己的myGrade方法。 总结：JavaScript面向对象是一个比较难理解的知识点，尤其是创建原型并且原型的继承十分地麻烦，虽说CS6标准里引入了class这关键字，然而并不是所有地主流浏览器都支持class书写，兼容其实不是特别好，但只要多看，多学习，多查资料，在结合实践，相信可以很好地掌握好面向对象编程的知识点。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://www.brightlam.top/tags/前端/"},{"name":"编程","slug":"编程","permalink":"http://www.brightlam.top/tags/编程/"}]},{"title":"js面向对象编程(二)","slug":"js面向对象编程-二","date":"2018-04-26T12:47:09.000Z","updated":"2018-05-12T16:26:41.014Z","comments":true,"path":"2018/04/26/js面向对象编程-二/","link":"","permalink":"http://www.brightlam.top/2018/04/26/js面向对象编程-二/","excerpt":"","text":"原型继承实际上，实现JavaScript的原型继承就如同Java的class中定义一个subclass一样，当我们定义了一个学生类Student，想要在定义一个子类去继承这个学生类，这就是原型继承，可是由于JavaScript没有class类型，所以其中的一个方法就是借助一个空的函数F来实现正确的原型链，确保其原型指向是正确的。这个空函数F定义如下：12345678910111213141516171819202122232425262728293031323334353637//子类的构造函数,在内部用call()调用希望“继承”的构造函数，并绑定this；function PrimaryStudent(props)&#123; Student.call(this,props); this.grade = props.grade || 1;&#125;//空函数Ffunction F() &#123;&#125;//把F的原型指向Student.prototypeF.prototype = Student.prototype;//把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();//把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;//定义属于这个PrimaryStudent自己的方法PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;;//创建xiaoming;var xiaoming = new PrimaryStudent(&#123; name:'小明', grade: 80&#125;);//验证原型xiaoming.__proto__===PrimaryStudent.prototype; //truexiaoming.__proto__.__proto__===Student.prototype; //true//验证继承关系xiaoming instanceof PrimaryStudent; //truexiaoming instanceof Student; //true 还可以写一个inherits()，将继承这个动作封装成函数，方便调用，简化代码123456function inherits (Child,Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 现在可以调用这个函数来实现继承了。1234567891011121314151617181920function Student(props) &#123; this.name = props.name || '';&#125;Student.prototype.hello = function () &#123; alert('hello,'+this.name+'!');&#125;function PrimaryStudent(props)&#123; Student.call(this,props); this.grade = grade || 1;&#125;//实现继承inherits(PrimaryStudent,Student);//定义PrimaryStudent自己的方法PrimaryStudent.prototype.getGrade = function () &#123; return this.grade;&#125;; PS：以上是个人学习js面向对象的一些不成熟不全面的总结，想了解更多关于js面向对象的知识,推荐廖雪峰的js面向对象教程以及阮一峰的网络日志","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://www.brightlam.top/tags/前端/"},{"name":"编程","slug":"编程","permalink":"http://www.brightlam.top/tags/编程/"}]},{"title":"js面向对象编程(一)","slug":"js面向对象编程-一","date":"2018-04-24T15:58:32.000Z","updated":"2018-11-23T13:24:21.749Z","comments":true,"path":"2018/04/24/js面向对象编程-一/","link":"","permalink":"http://www.brightlam.top/2018/04/24/js面向对象编程-一/","excerpt":"","text":"大多数编程语言如java，c#,其面向对象都有两个明确的基本概念，即类和实例。类是对象的类型模板，例如，用Worker来表示一个工人类，用Student来表示一个学生类，类不表示 任何具体的事物；实例是根据类创建的对象，例如要表示小明是一个学生，就可以在Student中创建‘小明’这样一个对象。然而在JavaScript的世界里，没有类的概念。 JavaScript通过原型（prototype）来实现面向对象编程。 假设现在有一个这样的对象： 12345678//创建一个名为Student的对象var Student = &#123; name: 'xiaoming', height: 172, eat: fucntion () &#123; console.log(this.name+'is eating..'); &#125;&#125;; 那么如何来创建一个‘小明’呢？JavaScript通过一个Object.create()方法来传入一个原型对象，并创建一个基于该原型的新对象。下面通过编写一个函数 来实践上面讲到的。 12345678//函数名为creatStudentfunction createStudent (name) &#123; var x = Object.create(Student); x.name = name; return x;&#125;var xiaoming = createStudent('小明');xiaoming.eat(); //小明现在拥有父类eat这个方法了，能\"吃\"了 当然，也可以不编写函数，直接在创建一个xiaoming的对象，然后通过xiaoming.proto = Student;同样可以实现，只不过不推荐采用这种方式，因为 万恶的低版本IE不兼容proto这个属性. 创建对象 JavaScript中每一个对象都会有一个原型，当我们用obj.xxx去调用一个对象的属性时，JavaScript引擎会先在当前对象上寻找，如果找不到就去到原型对象上寻找，如果还没找到， 就去到Object.prototype(最外层)找，最终还没找到就只能返回undefined了。 例如，创建一个Array数组，来看看它的原型链 12var arr = [1,2,3];arr---&gt;Array.prototype---&gt;Object.prototype---&gt;null 构造函数 除了使用{…}创建一个对象外，还可以使用构造函数来创建。下面定义一个构造函数 123456function Student(name) &#123; this.name = name; this.hello = function ()&#123; alert('hello,'this.name+'!'); &#125;&#125; 也许这个函数看起来跟普通函数没什么两样，JavaScript通过一个关键字new来实例化一个对象， 123var xiaoming = new Student('小明');xiaoming.name; //小明xiaoming.hello(); //hello,小明！ 试试如果不写new的话，上面的代码运行会如何! 此时新创建的xiaoming的原型链是： 1xiaoming--&gt;Student.prototype---&gt;Object.prototype---&gt;null 用new Student创建的对象还会从原型上获得一个constructor属性，它指向函数Student本身。 需要注意一个小问题，假设现在xiaoming,xiaohong来自对象Student.来看下面这段代码： 12345xiaoming.name; //小明xiaohong.name; //小红xiaoming.hello; //function: Student.hello()xiaohong.hello; //function: Student.hello()xioaming.hello === xiaohong.hello; //false xiaoming和xiaohong居然不是同一个函数！这就带来这样的问题，当我们创建很多对象的时候，就会产生很多不同的函数，虽然它们的名称和代码是相同的，这极大地浪费了内存， 所以我们需要让这些hello函数实际上只共享一个函数就行，也就是下面这段修改后的代码： 123456function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; //通过prototype来实现所有子对象共享父对象的函数 alert('hello,'+this.name+'!');&#125;; PS：以上是个人学习js面向对象的一些不成熟不全面的总结，想了解更多关于js面向对象的知识,推荐廖雪峰的js面向对象教程以及阮一峰的网络日志","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.brightlam.top/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://www.brightlam.top/tags/前端/"},{"name":"编程","slug":"编程","permalink":"http://www.brightlam.top/tags/编程/"}]}]}