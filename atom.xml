<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>「Stay hungry，stay foolish.」</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.brightlam.top/"/>
  <updated>2019-10-17T13:11:18.668Z</updated>
  <id>http://www.brightlam.top/</id>
  
  <author>
    <name>Light Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>由一道笔试题看动态规划</title>
    <link href="http://www.brightlam.top/2019/10/17/%E7%94%B1%E4%B8%80%E9%81%93%E7%AC%94%E8%AF%95%E9%A2%98%E7%9C%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://www.brightlam.top/2019/10/17/由一道笔试题看动态规划/</id>
    <published>2019-10-17T13:09:32.000Z</published>
    <updated>2019-10-17T13:11:18.668Z</updated>
    
    <content type="html"><![CDATA[<p>对于大多数学习编程的人来说，动态规划一直是一个难突破的点，我自己在学习过程中也是很困惑，各种书籍资料，视频都看过不少，基本的思想也都能理解，<strong>但一碰到题目的时候还是觉得无从下手</strong>。最近在做笔试题的时候突然有了一丢丢理解，这里记录下， 没准路过看到的人能加深理解或有所启发。</p><h4 id="逆向思维"><a href="#逆向思维" class="headerlink" title="逆向思维"></a>逆向思维</h4><p>题目如下：</p><blockquote><p>一个人在 m×n 的方格里行走，每次只能向右或向下，每个方格里的值是距离，求从起点走到终点的<strong>最短</strong>路径值。<br>示例：3 3<br>1 3 1<br>1 5 1<br>4 2 1<br>最终输出 7  ，从左上走到右下所花费的最短距离是 7</p></blockquote><p>第一眼看到题目的时候，就知道是动态规划类的题了，然而在做题时由于各（tai）种（cai）原（le）因还是没能做出来，尽管对这种类型的题目见得多了。有种我熟悉它它却不待见我的赶脚。等到结束之后回过头来想，想啊想啊想 … 半小时过去了，又想啊想，总算是把代码实现出来了。</p><p>按照正常思维来看的话，人站在起点处，向右或向下走到终点，那么最短距离就是每次比较向左或向下的路程，取最小的走，在加上自身需要的路程，这样一直走到终点就是最短的路径值。对照着题目验证下，那就是 1 -&gt; (向下) 1 -&gt; (向下) 4 -&gt; (向右) 2 -&gt; (向右) 1 到达终点，总距离是 9 ，发现这种走法是错的。正确的走法应该是 1 -&gt; 3 -&gt; 1 -&gt; 1 -&gt; 1 ,总距离是 7 最短。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/12142481-099a63df90d5895d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>此方法不行，那我们来考虑第二种解法。现在，不从起点来推算了，因为我们一眼看过去题目这个矩阵，就知道在这个输入下，最好的路径就是 1 -&gt; 1 -&gt; 1 -&gt; 3 -&gt; 1 这样走法，怎么得出来的呢？我们从矩阵最后一个数看，它是终点，那这个终点是如何过来的呢？ 发现它是由左边或者上边这个数字过来的，为什么会这样？因为题目说了，只能向右或向下走，所以终点的这个位置要么是上面位置向下走得来的，要么就是左边位置向右走到达的。所以我们从后往前推得出 1 -&gt; 1 -&gt; 1 -&gt; 3 -&gt; 1 这种最佳走法。如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/12142481-b10fa68ce46e2120.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>这就是传说中的<strong>动态规划</strong> , 在这道题里，我们定义的一个状态是 f(i, j) ，表示从起点走到坐标（i, j） 所经历的最短路径，由上面的推断可以发现，<strong>坐标 （i,j）的最短路径总是由 坐标(i-1, j) 和坐标 (i, j-1) 两个的最小值加上坐标 (i, j) 自身的值得来</strong>，<br>状态转移方程为 <code>f(i, j) = Math.min(f(i-1 ,j), f(i, j-1)) + values[i, j]</code> i, j 为二维数组的坐标，values 为数组对应坐标的初始值。原始数组 values 和 dp 数组的推算值如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/12142481-feeac6b8e7428c95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>有了上面的铺垫，我们就可以得出代码了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function solve(arr, m, n) &#123;</span><br><span class="line">    //定义一个二维数组 dp , dp[i][j]表示走到i,j这个点的最短路径</span><br><span class="line">    var dp = new Array(m);</span><br><span class="line">    for (var i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i] = [];</span><br><span class="line">        for (var j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化第一行和第一列的状态值</span><br><span class="line">    dp[0][0] = arr[0][0];</span><br><span class="line">    for (var i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp[0][i] = arr[0][i] + dp[0][i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][0] = arr[i][0] + dp[i - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line">    // 动态规划，计算每个点的最短路径值</span><br><span class="line">    for (var i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        for (var j = 1; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = arr[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们用一个二维数组dp , 来存储每个节点的最短路径值，这里要特别注意的是，需要对数组的第一行和第一列进行初始化，第一行的每个点只能由左边向右走过来，所以直接累加相应坐标的值；同理第一列的每个点只能由上面向下走得来，每个点由原来的值加上一个点的值即可。接下来从第 1 行，第1列开始，一直遍历到 m -1, n -1 ,把每个状态值填上，函数的返回值为走到终点的坐标也就是 dp[m-1][n-1] 。</p><h4 id="动态规划的思想"><a href="#动态规划的思想" class="headerlink" title="动态规划的思想"></a>动态规划的思想</h4><p>在学习动态规划的时候，学的一愣一愣的，什么最优子结构、无副作用、重复子问题等，看着这些理论似懂非懂。</p><p>什么是动态规划？我觉得动态规划就是逆向，由后往前地去推导这样的过程，就仿佛开了上帝视角一样，在已经知道结果的情况下，通过对各种情况的抉择，去倒推出原始的起点，然后定义一个合理的状态来解释。像上面的这道题目，问你一个人从左上角走到右下角的最短路程，那我们在看题的时候，可以全局地看到各个路径的距离值以及周围的路径分布，所以可以通过推算很快得出结果。上面的第一种解法其实就是贪心的思路，从起点开始，每次选择一条最短的路径走下去，这样带来的弊端就是可能后面的路径是更加糟糕的，容易因为短视而得不到最佳的结果。</p><p>总的来说，在遇到一些求最佳问题时，比如求最短路径，最大价值、最长公共子序列等问题时，就要考虑使用动态规划来求解，而有些时候，不妨先用贪心的思想来试试能否求得结果，这样也能明白不行的原因在哪里，也能加深对动态规划的应用场景理解。</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>很多时候看懂了不一定真的懂了，正如开头提到的知道题目是动态规划，但就是觉得无从下手，现在看还是要多做多理解，也许过段时间又有新的领悟。</p><p>对这个知识点的理解还有待加深，文章有什么不对之处，敬请指正，欢迎交流探讨。</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于大多数学习编程的人来说，动态规划一直是一个难突破的点，我自己在学习过程中也是很困惑，各种书籍资料，视频都看过不少，基本的思想也都能理解，&lt;strong&gt;但一碰到题目的时候还是觉得无从下手&lt;/strong&gt;。最近在做笔试题的时候突然有了一丢丢理解，这里记录下， 没准路过看
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[&#39;1&#39;, &#39;7&#39;, &#39;11&#39;].map(parseInt) 会输出什么</title>
    <link href="http://www.brightlam.top/2019/07/24/1-7-11-map-parseInt-%E4%BC%9A%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/"/>
    <id>http://www.brightlam.top/2019/07/24/1-7-11-map-parseInt-会输出什么/</id>
    <published>2019-07-24T06:46:52.000Z</published>
    <updated>2019-07-24T06:48:59.877Z</updated>
    
    <content type="html"><![CDATA[<p>js 真是门神奇的语言，有无数多的可能性，难怪现在大家都想去拥抱 typescript 了。相比 java ，c++ 等语言来说，js 语法略显宽松些，函数参数的类型可以有多种可能性，所以当我在网上看到下面这道题时，心里忍不住 mmp ，咱能不能整点正式的，少来这种妖魔鬼怪呀（逃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;7&apos;, &apos;11&apos;].map(parseInt)  //  结果输出 -&gt; [1, NaN, 3]</span><br></pre></td></tr></table></figure></p><p>相信你也一样，第一次看到结果的时候有些困惑，为什么输出会有 NaN ? 为什么把 <code>&#39;11&#39;</code> 转成整数会是 <code>3</code> ？</p><p>如果你早已知晓其中原因，可以直接拉到下方点个赞再走，否则的话我们一起来探索下其中缘由。</p><h4 id="关键的-map-函数"><a href="#关键的-map-函数" class="headerlink" title="关键的 map 函数"></a>关键的 map 函数</h4><p>我们想把数组里的字符串数字转换成整数，于是使用 map 函数来对数组的每一项作用，作用的函数是 <code>parseInt</code> 函数，所以预期的结果应该是 <code>[1,7,11]</code> ，然而人算不如浏览器算，最终浏览器的 JavaScript 引擎给出的答案是 <code>[1, NaN, 3]</code> 。从结果可以看到 1 是正常进行转化的，后面两个数则不是我们预期的结果。</p><p><strong>第一个猜想：会不会是传入的 parseInt 出现问题 ？</strong><br>现在我们把 parseInt 换掉，功能改为给每一个数乘 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;7&apos;, &apos;11&apos;].map(function(x)&#123;</span><br><span class="line">return x * 2;     // 结果 -&gt; [2, 14, 22]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>发现结果是正常的，x 代表从数组里拿到的每一个值，在依次去乘以 2 ，没问题。可是问题来了，除了 x ，会不会有其它参数，存不存在其它可以使用的参数。于是我们试验下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;7&apos;, &apos;11&apos;].map(function(x, i, j, k)&#123;</span><br><span class="line">console.log(x +&apos; &apos; + i + &apos; &apos; + j + &apos; &apos; + k);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在 Chrome 的控制台执行后发现结果出乎意料</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/12142481-c8f50a59c14eb2af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>也就是说，<strong>map 接受的这个函数，它存在三个参数，第一个是数组当前的值，第二个是当前值的索引，第三个数是当前传入的数组</strong> 。</p><p>到这里我们就明白了，当我们传入 parseInt 时，map 函数会把三个参数（数组当前元素，当前元素的索引，当前传入的数组）一并打包给 parseInt 。那么现在问题就集中在 parseInt 函数上面。从 MDN 文档查询后可以知道， <code>parseInt(string, radix)</code> 函数接受两个参数，第一个是需要转换的字符串，第二个是<strong>进制</strong>。于是结果呼之欲出，我把这个过程画成了图，方便看图理解，如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/12142481-51972a8beb11c36f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>可能有的人看完还是雾水，解释下：首先，parseInt 接受两个参数，因此第三个参数会被忽略。第一次执行， <code>parseInt(&#39;1&#39;, 0)</code> 会输出 1 ，因为 0 会转换成 false，而 false 会使它执行默认的进制 10 ，就是 parseInt 默认都是转换十进制；第二次执行，<code>parseInt(&#39;7&#39;, 1)</code> 因为没有所谓的 1 进制，所以无法转换，输出 NaN; 第三次执行<code>parseInt(&#39;11&#39;, 2)</code> 答案为 3 ，因为以 2 为进制转换，3 的二进制是 11 , 非常的巧妙。</p><p>所以最终的输出的结果就是 <code>[1, NaN, 3]</code> 啦，不怪浏览器，怪自己，哈哈。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>常言道人定胜天，在程序员的世界里大家都想人定胜机器（浏览器），然而事实通常与我们预期的不符，只有多掌握知识，多分析才能知晓其中原理，特别是要利用好文档材料，如 MDN， w3cschool 等等，只要一查，就能知道每个函数都有多个规定的参数，有些是必须，有些是可选的，当然，个人觉得不必死每个函数，需要的时候利用好 Internet 就行。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js 真是门神奇的语言，有无数多的可能性，难怪现在大家都想去拥抱 typescript 了。相比 java ，c++ 等语言来说，js 语法略显宽松些，函数参数的类型可以有多种可能性，所以当我在网上看到下面这道题时，心里忍不住 mmp ，咱能不能整点正式的，少来这种妖魔鬼怪
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原生 JS 实现滚动监听</title>
    <link href="http://www.brightlam.top/2019/05/15/%E5%8E%9F%E7%94%9F-JS-%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E7%9B%91%E5%90%AC/"/>
    <id>http://www.brightlam.top/2019/05/15/原生-JS-实现滚动监听/</id>
    <published>2019-05-15T10:50:48.000Z</published>
    <updated>2019-05-15T11:04:53.594Z</updated>
    
    <content type="html"><![CDATA[<p>本文的内容是 <strong>JS 滚动监听导航栏更新背景色标识</strong>。</p><p>之前在 bootstrap 文档上看到这样一个效果，如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/05/15/ETojNn.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>因为 bootstrap 是引用了 jQuery 库的，非常容易上手，也能方便地用在各个项目中，但不折腾的前端，跟咸鱼有什么区别。于是就想着不用这些库，自己用 JS 实现以下这个效果，所以就折腾了下。</p><h4 id="滚动监听原理"><a href="#滚动监听原理" class="headerlink" title="滚动监听原理"></a>滚动监听原理</h4><p>首先了解一下滚动监听的原理，当鼠标滚轮滚动或页面滚动条滑动时，每到一块内容区域，其上方对应的导航栏状态也将更新，那就需要知道每块内容区域相对于顶部的距离，将这个距离跟滚动条滑行的距离做比较，根据比较的结果来决定是否更新导航栏状态标。所以整个大致思路就是：监听页面的 scroll 事件，然后<strong>获取当前页面滚动条纵坐标的位置</strong>，假设为 posNav；在获取内容区域，这里假设分为内容1，内容2，内容3，获取这些内容块<strong>相对于视口顶部的距离</strong>，假设是 height ，随着滚动条的滑动，如果 posNav &gt; height1，那么第一个导航标签更新；如果 posNav &gt; height2 ，那么第二个导航更新，…，依次遍历直至底部，在这个过程中，还要注意当其中一个加上了背景色之后，跟它同级的所有元素都要移除掉这个背景色。</p><h4 id="瞄点定位"><a href="#瞄点定位" class="headerlink" title="瞄点定位"></a>瞄点定位</h4><p>除了根据内容区域滚动更新之外，这里还涉及到一个定位的问题，即点击导航栏，就定位到这个导航所对应的内容区域，这也是很多单页面常有的做法。实现这个最简单、粗暴的方法就是使用<strong>瞄点定位</strong>，给每个导航 a 标签的 href  属性写上 <strong>#id</strong> 的格式，然后给对应的内容区域加上 <strong>id名称</strong> ，由于 id 是唯一标识，因此点击导航就可直接定位，简单，无兼容问题，非常好的一个实现技巧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在开始写 js 之前，先准备一个简单的静态页面，默认给第一个导航加上 active 属性，也就是有背景色的效果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/05/15/ETX6w8.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>有了页面后，先获取所有导航 li 标签，存在数组里，等会用它更新导航栏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lis = [...document.querySelectorAll(&apos;.nav &gt; ul &gt; li&apos;)];</span><br></pre></td></tr></table></figure></p><p><strong>…</strong> 是一个展开运算符，<strong>querySelectorAll</strong> 选取<strong>所有</strong> class 为 nav 下面的 ul 的 li 标签元素的集合，展开运算符将它们都存在数组 lis 里。接着获取内容块区域相对于页面顶部的距离，同样将它们存在数组里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var divs = [...document.querySelectorAll(&apos;.mainPage&apos;)];</span><br></pre></td></tr></table></figure></p><p>获取到后，用一个 for 循环遍历获取每个 div 的距离顶部的值，使用 getBoundingClientRect() 方法，它返回元素的大小及其相对于视口的位置，我们主要使用 top 属性获取顶部距离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var divHeights = [];</span><br><span class="line">for (var i = 0; i &lt; divs.length; i++) &#123;         // 循环每个 div 的距离 top 的值存放至数组</span><br><span class="line">   divHeights.push(divs[i].getBoundingClientRect().top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在所有该有的元素及其数值都有了，可以开始写监听事件了。这里吐个槽，别看上面寥寥几句话就完成了这些属性及其元素的获取，真正在做的时候，我花了不少世间查询这些方法及属性，像 getBoundingClientRect() 、document.doucmentElement.scrollTop 等属性的用法，主要是一直使用现成的框架，导致太依赖框架的那些简便封装好的方法而忽视了原来方法，所以建议各位用框架久了记得回过来看看每个方法对应的作用以及在原生 js  的实现。<br>好了，监听页面滚动事件把它写在一个函数里，定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function updateNav() &#123;</span><br><span class="line">   var scop = document.documentElement.scrollTop;</span><br><span class="line">   var k;</span><br><span class="line">   for (var i = 0; i &lt; divHeights.length; i++) &#123;</span><br><span class="line">      if (scop &gt; divHeights[i] - 50) &#123;</span><br><span class="line">           k = i;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   lis[k].classList.add(&apos;current&apos;);</span><br><span class="line">   for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">       if (i == k) continue;</span><br><span class="line">       else lis[i].classList.remove(&apos;current&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后一句代码调用函数即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;scroll&apos;, updateNav);</span><br></pre></td></tr></table></figure></p><p>至此，所以代码都完成了，来看看最终浏览器的效果吧：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/05/15/ETxyex.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>感谢阅读，想要获取完整源代码，请点击 <a href="https://github.com/myLightLin/jsDemo/tree/master/%E6%BB%9A%E5%8A%A8%E7%9B%91%E5%90%AC" target="_blank" rel="noopener">这里</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的内容是 &lt;strong&gt;JS 滚动监听导航栏更新背景色标识&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;之前在 bootstrap 文档上看到这样一个效果，如下&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div cla
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习之路- JS 小测验</title>
    <link href="http://www.brightlam.top/2019/05/01/JavaScript-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-JS-%E5%B0%8F%E6%B5%8B%E9%AA%8C/"/>
    <id>http://www.brightlam.top/2019/05/01/JavaScript-学习之路-JS-小测验/</id>
    <published>2019-05-01T09:56:38.000Z</published>
    <updated>2019-05-01T09:58:23.055Z</updated>
    
    <content type="html"><![CDATA[<p>在学习 JS 的过程中，很多知识往往看一遍就过去了，然后自以为掌握了，其实再次碰到不一定能答得出来，看到一些有趣的东西还是要动手实践一下，而且时不时复习一下，非常有利于加深记忆。今天是五一，假日期间，好好休息玩耍，也别学什么新东西了，你可以看看以下这些问题以及相关知识点来看看自己掌握了多少，温故知新。</p><p>问题不多，耐心看完。最下方有答案，先别急着翻，自己先想想。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>JS 格式化，用逗号分隔千分位数字</li><li>运行 <code>[1, 2, 2].fill(3, 1, 3)</code> 会输出什么</li><li><code>~~3.5</code> 的结果是什么</li><li>如何判断一个数组的长度是奇数还是偶数</li><li>JSON.parse 和 JSON.stringify 的作用</li><li><code>typeof null</code>为什么等于 <code>&quot;object&quot;</code>，它的判断原理是什么</li><li>如何判断一个元素是否为数组</li><li><code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符</li><li>function add(){}   和  var add = function（）{} 解析时的区别</li><li>执行以下代码，输出是什么？为什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line">for(var i=0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    arr[i]=function()&#123;</span><br><span class="line">      alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[3]();</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h4><p>如有错误，请帮忙指正。</p><ol><li>JS 格式化，用逗号分隔千分位数字</li></ol><p>两种方法，一种是使用 tolocaleString()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1999;</span><br><span class="line">a.toLocaleString();     // &quot;1,999&quot;</span><br></pre></td></tr></table></figure></p><p>另外一种是正则表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var re = /(?!^)(?=(\d&#123;3&#125;)+$)/g;</span><br><span class="line">var a = &quot;12345678&quot;;</span><br><span class="line">a.replace(re, &apos;,&apos;);   // &quot;12,345,678&quot;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>运行 <code>[1, 2, 2].fill(3, 1, 3)</code> 会输出什么?  答案是 <code>[1,3,3]</code><blockquote><p>fill 方法接受三个参数：num，start，end 。num 是你要填充的数字，start 是填充的起始位置，end 是终止位置。fill(3,1,3) 表示从索引 1 开始到索引 3 之间的元素填充为 3</p></blockquote></li><li><code>~~3.5</code> 的结果是什么？答案是 <code>3</code><blockquote><p>对于非数字，~~ 的结果为0，有个例外是 ~~ true 结果为 1<br>对于大于 0 的数，~~ 相当于是Math.floor<br>对于小于 0 的数，~~ 相当于是Math.ceil</p></blockquote></li><li>如何判断一个数组的长度是奇数还是偶数？答案是<code>len &amp; 1，len 为数组长度，奇数结果为true</code><blockquote><p>只要 “&amp;&amp;” 前面是false，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 前面的值;<br>只要 “||” 前面为 false,不管 “||” 后面是 true 还是 false，都返回 “||” 后面的值。</p></blockquote></li><li>JSON.parse 和 JSON.stringify 的作用？<blockquote><p>JSON.parse 将一个 json 转化为 JavaScript Object string 类型<br>JSON.stringify 将一个 string 转化为 json 类型</p></blockquote></li><li><code>typeof null</code>为什么等于 <code>&quot;object&quot;</code>，它的判断原理是什么<blockquote><p>js 底层存储变量采用二进制，会在变量的机器码的低位 1-3 位存储其类型信息<br>000：对象<br>010：浮点数<br>100：字符串<br>110：布尔<br>1：整数<br>null：全0<br>undefined：-2^30<br>所以 typeof null 为显示为 object 对象。</p></blockquote></li><li>如何判断一个元素是否为数组？</li></ol><p>假设待判断对象为 arr ，有四种方法，一是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(arr) == &apos;[object Array]&apos;</span><br></pre></td></tr></table></figure></p><p>或者是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr instanceof Array</span><br></pre></td></tr></table></figure></p><p>又或是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(arr)</span><br></pre></td></tr></table></figure></p><p>第四种方法可以用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.__proto__.constructor == Array</span><br></pre></td></tr></table></figure></p><ol start="8"><li><code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符相关操作？<blockquote><p>左移 &lt;&lt; 将一个数的二进制表示向左移动 n 位，右边用0填充。<br>右移 &gt;&gt; 将一个数的二进制表示向右移 n  位，舍弃被移出的位。<br>简单点说，a &gt;&gt; n 相当于用 a 去除以 2 的 n 次方，所以 8 &gt;&gt; 1 结果为 4;<br>而 a &lt;&lt; n 相当于用 a 去乘以 2 的 n 次方，所以 2 &lt;&lt; 5 结果为 64</p></blockquote></li><li>function add() {}   和  var add = function (){} 解析时的区别<blockquote><p>前者是执行前就会被解析（执行前就会读取函数名），而后者是执行过程中解析。所以 function add() {} 在执行里面的代码前就会读取函数名 add , 而 var add = function (){} 则是执行时逐步解析。</p></blockquote></li><li>执行以下代码，输出是什么？为什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line">for(var i=0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    arr[i]=function()&#123;</span><br><span class="line">      alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[3]();</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>答案是输出 i 的值为 5 。这个是与闭包有关的经常看到的问题，不管运行函数时传入的 i 是什么，最终输出的都是 for 循环结束时的 i 的值，也就是数组的长度，因为匿名函数里的这句 <code>alert(i)</code> 执行的时候需要找到 i 变量，里面没有，那就只好去父级里找，而父级里的 i 在 for 循环，所以最终给到它的是循环的终止条件，也就是 i = 5 。<br><br>解决方法也很简单，要么把 for() 里面的 var 换成 let ，形成块级作用域；要么使用闭包，匿名函数里在返回一个匿名函数，并且传入 i 立刻执行。</p></blockquote><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习 JS 的过程中，很多知识往往看一遍就过去了，然后自以为掌握了，其实再次碰到不一定能答得出来，看到一些有趣的东西还是要动手实践一下，而且时不时复习一下，非常有利于加深记忆。今天是五一，假日期间，好好休息玩耍，也别学什么新东西了，你可以看看以下这些问题以及相关知识点来看
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载的几种方法</title>
    <link href="http://www.brightlam.top/2019/04/05/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://www.brightlam.top/2019/04/05/图片懒加载的几种方法/</id>
    <published>2019-04-05T04:03:17.000Z</published>
    <updated>2019-04-05T05:46:29.330Z</updated>
    
    <content type="html"><![CDATA[<p>在一些图片比较多的网站会用到 <em>图片懒加载</em> 技术，这项技术可以延迟加载图像，只当图片出现在我们看到的视图中才加载，它的好处是<strong>大大提高用户体验，节省不必要的资源浪费以及网站的性能提升等</strong>。下面介绍几种图片懒加载的方法，分别是监听 <code>scroll、resize</code> 事件，使用 <code>Intersection Observer</code> API 以及 Chrome70 自带的懒加载设置。任何技术都是为解决问题服务的。在开始之前，还是要了解清楚「是什么」以及「为什么」。</p><h4 id="什么是懒加载"><a href="#什么是懒加载" class="headerlink" title="什么是懒加载"></a>什么是懒加载</h4><p>当一个网站的图片数量较多时，直接加载可能会有很大的开销，不利于性能，这时可以将所有的图片换成轻量的占位图，不加载图片。而当用户真正滚动到图片出现时，再迅速将占位图片换成真正我们想展示的图片，这整个过程就是懒加载。</p><h4 id="为什么要懒加载"><a href="#为什么要懒加载" class="headerlink" title="为什么要懒加载"></a>为什么要懒加载</h4><p>当你打开一个网站时，浏览器会做许多工作，这其中包括下载各种可能用到的资源，然后渲染呈现在你面前，假设你的网站有大量的图片，那么加载的过程是很耗时的，尤其像那些新闻资讯类需要大量图片的网站，可想而知，网站的初始加载时间会很长，再加上网络等其它影响，用户体验会很差，相信你经常遇到过一个网站卡在某个地方，一直在加载，这种体验很不好。<strong>我们都希望一输入网址，页面立马就呈现在眼前。</strong></p><p>既然想要页面立马呈现在面前，那势必要减少浏览器的负荷，优化代码，减少一些不必要的请求和不必要资源的加载，因为你打开网站的时候，浏览器会把所有可能的资源都下载好，而实际上有些资源你并不需要用到，这就造成了浪费。<strong>所以有必要在一些资源上做下优化，提高网站加载速度。</strong></p><h4 id="滚动事件监听"><a href="#滚动事件监听" class="headerlink" title="滚动事件监听"></a>滚动事件监听</h4><p>前面说到要等图片出现在视口时才加载，那么肯定要监控浏览器的 scroll 事件，并且要计算图片与浏览器窗口的距离来选择替换图片的 src 地址。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/600&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/700&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/800&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/900&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 引入 lodash 库</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/lodash.js/4.17.12-pre/lodash.core.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CSS</span><br><span class="line">div &#123;</span><br><span class="line">  margin-top: 350px;</span><br><span class="line">&#125;</span><br><span class="line">.lazy-load &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">let lazyImages = [...document.querySelectorAll(&apos;.lazy-load&apos;)]</span><br><span class="line">let inAdvance = 300</span><br><span class="line">function lazyLoad() &#123;</span><br><span class="line">    lazyImages.forEach(image =&gt; &#123;</span><br><span class="line">        if (image.offsetTop &lt; window.innerHeight + window.pageYOffset + inAdvance) &#123;</span><br><span class="line">            image.src = image.dataset.src;   // 替换真实图片的  URL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">lazyLoad();</span><br><span class="line">window.addEventListener(&apos;scroll&apos;, _.throttle(lazyLoad, 50))</span><br><span class="line">window.addEventListener(&apos;resize&apos;, _.throttle(lazyLoad, 50))</span><br></pre></td></tr></table></figure><p>这其中有几个属性，首先是 <code>data-src</code>，它是自定义属性，可以在 js 里通过 <code>dataset</code> 获得它的属性值；还有 <code>offsetTop</code> ,<code>innerHeight</code> 以及 <code>pageYOffset</code> 属性，你可以通过 MDN 文档查询他们的定义和用法；最后是 <code>_.throttle</code> 函数，它是一个节流函数，引用自 <code>lodash</code> 库，因为监听 <code>scroll</code> 滚动以及 <code>resize</code> 窗口改变事件会不断地触发，过于频繁，所以使用节流函数让其每隔一段时间执行，节省开销。</p><h4 id="Intersection-Observer-API"><a href="#Intersection-Observer-API" class="headerlink" title="Intersection Observer API"></a>Intersection Observer API</h4><p>现在，有一个 <code>Intersection observer</code> 接口可以方便我们操作，它可以异步观察目标元素与祖先元素或顶层文件的交集变化。简单的说，以前我们需要自己去写滚动监听事件函数，现在，这个 API 可以帮助我们，我们只需要统一写一个 <strong>观察函数</strong> ，每当想观察的元素进入视口，也就是我们看见它时，就执行相应的操作。看看以下 js 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;   // css 部分</span><br><span class="line">  .lazy-load &#123;</span><br><span class="line">     width: 400px;</span><br><span class="line">     height: 300px;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/600&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/700&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/800&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;img class=&quot;lazy-load&quot; data-src=&quot;https://source.unsplash.com/random/900&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;</span><br><span class="line">    let lazyImages = [...document.querySelectorAll(&apos;.lazy-load&apos;)];</span><br><span class="line">    if (&quot;IntersectionObserver&quot; in window) &#123;</span><br><span class="line">        // 创建一个观察函数，以便待会调用   </span><br><span class="line">        let lazyImageObserver = new IntersectionObserver(function(entries, observer) &#123;</span><br><span class="line">            entries.forEach(function(entry) &#123;</span><br><span class="line">            if (entry.isIntersecting) &#123;</span><br><span class="line">               let lazyImage = entry.target;</span><br><span class="line">               lazyImage.src = lazyImage.dataset.src;   // 替换 src URL</span><br><span class="line">               lazyImageObserver.unobserve(lazyImage);  // 解除观察</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 对所有需要懒加载的图片进行 “暗中观察”</span><br><span class="line">        lazyImages.forEach(function(lazyImage) &#123;</span><br><span class="line">            lazyImageObserver.observe(lazyImage);</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">           alert(&apos;您的浏览器不支持 IntersectionObserver&apos;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，里面监听了 <code>DOMContentLoaded</code> 事件，当初始的 HTML 文档被完全加载和解析完成之后，这个事件就被触发，在页面初始之后获取到所有图片元素，然后进行观察。</p><p>那既然这个 API 这么好，又简便易用，有没什么缺点呢？相信你看了上面的代码就能知晓，对，<strong>浏览器兼容问题！！</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/04/05/ARakh8.jpg" alt="can I use" title="">                </div>                <div class="image-caption">can I use</div>            </figure><br>可以看到，还是有很多泛红，只有 Chrome 支持的最好，从 58 以上版本就完全支持了，Firefox 也不错。如果你的项目不需要考虑兼容的话，可以尝试使用下它，看看效果。</p><h4 id="Chrome-浏览器自带"><a href="#Chrome-浏览器自带" class="headerlink" title="Chrome 浏览器自带"></a>Chrome 浏览器自带</h4><p>这个方法厉害了，没有前面两种方法那么复杂，它是 Chrome 自带的原生 lazyload 属性，只需要一个开关。</p><blockquote><p>chrome://flags/#enable-lazy-image-loading</p></blockquote><p>复制它到 Chrome 浏览器的地址栏，然后找到如下选项，将其设置为「Enabled」。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/04/05/ARdQrd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后在 HTML 标签里开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://source.unsplash.com/random/600&quot; alt=&quot;&quot; lazyload=&quot;on&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>不需要多余的代码，不需要 JS ，简直强大。</p><h4 id="比较三者"><a href="#比较三者" class="headerlink" title="比较三者"></a>比较三者</h4><p>秉承着尝试捣鼓新技术的原则，应该优先使用 <code>Intersection Observer</code> ,随着越来越多的浏览器支持会更广泛地应用；但如果要考虑浏览器的兼容问题，那就要使用平常的 <code>scroll,resize</code> 事件监听了，配合 offsetTop 、innerHeight 以及 pageYOffset 几个属性实现。至于最简单粗暴的那个方法，很明显只能在特定的 Chrome 70 以上版本中使用，有很大的局限性，不过现在使用 Chrome 的人非常的多，所以也是有用处的。综合来看，应该将 <code>Intersection Observer</code> 和 <code>scroll,resize</code> 结合起来使用，这可能是最优也最兼容的方案。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] MDN 文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a><br>[2] 延迟加载图像和视频：<a href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/</a><br>[3] Lazy load images：<a href="https://medium.com/@filipvitas/lazy-load-images-with-zero-javascript-2c5bcb691274" target="_blank" rel="noopener">https://medium.com/@filipvitas/lazy-load-images-with-zero-javascript-2c5bcb691274</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一些图片比较多的网站会用到 &lt;em&gt;图片懒加载&lt;/em&gt; 技术，这项技术可以延迟加载图像，只当图片出现在我们看到的视图中才加载，它的好处是&lt;strong&gt;大大提高用户体验，节省不必要的资源浪费以及网站的性能提升等&lt;/strong&gt;。下面介绍几种图片懒加载的方法，分别是监听
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
      <category term="Chrome" scheme="http://www.brightlam.top/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习之路-原型和原型链</title>
    <link href="http://www.brightlam.top/2019/03/24/JavaScript-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://www.brightlam.top/2019/03/24/JavaScript-学习之路-原型和原型链/</id>
    <published>2019-03-24T10:28:30.000Z</published>
    <updated>2019-03-24T10:32:33.430Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象语言(Object-Oriented) 都有类的概念，通常用 <code>class</code> 关键字来定义。在最新的 ES6 标准里，也加入了类的使用，这意味着，js 也能像其它 OO 语言那样很方便地实现继承了。但是，js 的 <code>class</code> 其实只是个语法糖，它依然是通过<strong>原型链</strong>来实现继承的。</p><p>在理解原型链之前，首先要理解一句话，<strong>构造函数、原型和实例三者的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</strong></p><h4 id="理解-prototype、proto-和-constructor"><a href="#理解-prototype、proto-和-constructor" class="headerlink" title="理解 prototype、proto 和 constructor"></a>理解 prototype、<strong>proto</strong> 和 constructor</h4><p>上面这句话对应着几个属性：<code>prototype</code> ，<code>__proto__</code> 和 <code>constructor</code> 。</p><p>每个函数在被创建的时候，都会获得一个 <code>prototype</code> 属性，这个 <code>prototype</code> 属性会包含一个指针，叫做 <code>constrcuctor</code> ，这个 <code>constructor</code> 的值是构造函数的名称。所以对应了上面那句话：<strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针</strong> 。我们通过 Chrome 控制台来验证一下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/12142481-7c811701bf500caa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Chrome" title="">                </div>                <div class="image-caption">Chrome</div>            </figure></p><p>可以看到，我们定义了一个函数，函数名为 f ，f 的原型 prototype 里的 constructor 最终是等于它的构造函数名称的，那么这个 <code>constructor</code> 属性究竟是用来干嘛的？在查阅了网上相关资料后，我发现它是 JavaScript 语言设计的历史遗留物，它的值是可以手动变更的，但我们习惯于让它的值指向构造函数。</p><p>看上面的图仔细看会发现函数的 prototype 里还有一个 <code>__proto__</code> 属性。这个属性是每个对象都会有的隐式属性。那在 JS 这门语言里，万物皆对象。你在 console 里输入 <code>typeof f</code> 会输出 <code>function</code> ,但 <code>function</code> 也是对象。不信你在输入 <code>Function instanceof Object</code> 看看结果。这个 <code>__proto__</code> 对于实现继承有非常重要的作用，<strong>它始终指向对象的构造函数的原型。</strong> 这个属性对于我们理清两个对象之间的关系有很大的作用。</p><p>当我们 new 一个对象的时候，实际上就是生成了该对象的实例，这个实例对象会获得一个 <code>__proto__</code> 属性，链接到它的构造函数原型。这样下来就好理解了，前面我们定义的 <code>function f(){}</code> 实际上 <code>function</code> 只是一个语法糖，为了好看而已，它的内部是做了一个 <code>new Function()</code> 的实现，<code>Function</code> 可以理解为所有函数的老大，我们平常使用关键字定义的函数内部都是去 new Function 实现的。</p><p>那既然函数 f 是 Function 的实例，那它肯定会获得一个 <code>__proto__</code> 属性，这个属性是指向它的构造函数 Function 的原型 prototype 的。眼见为实，我们来验证下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/12142481-1df797f126628ee7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><p>对于开头提到的构造函数、原型和实例三者的关系，我想你应该有了概念了。为加深理解，我把它画成了图，如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/12142481-e123d38da7fcd50d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>在理解了原型之后，我们来看下原型链。让一个原型去继承另一个原型的属性和方法，就组成了原型链。就像前面的 finstance 是函数 f 的实例，f 又是 Function 的实例，… 就这样一层一层下来，就组成了原型链。我们来看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Dad()&#123;</span><br><span class="line">  this.name = &apos;xiaoming&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Dad.prototype.getName = function()&#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Son()&#123;</span><br><span class="line">  this.age = 18;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = new Dad();</span><br><span class="line">var baby = new Son();</span><br><span class="line">console.log(baby.getName());   // xiaoming</span><br></pre></td></tr></table></figure></p><p>上面这个就是继承的一种最简单的实现方式了，我们来看下它的原型链，首先 Dad 是父类，它有自己的属性 name，它的原型里定义了一个 getName 的方法。接着有一个子类 Son 继承 Dad ,它也有自己的属性 age，我们通过设置 <code>Son.prototype = new Dad();</code> 来实现原型继承，这样子类 Son 可以访问到父类 Dad 的属性和方法，所以子类的实例 baby 可以获取到 name 属性和 getName() 方法。</p><p>我们通过一张图来看下它的原型链：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/12142481-11f4c2fa5ac6b185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>__proto__</code> 属性通过将对象和原型之间联系起来来组成原型链；理解原型链，先要理解 prototype 、constructor 和 <strong>proto</strong> 这几个概念，理清构造函数、原型和实例三者的关系，结合实际效果来验证。JS 不像其它 OO 语言那样，它是通过<strong>原型链</strong>来实现继承的。这部分内容比较晦涩比较绕，耐心地多看多实践，不懂的网上查阅资料，也许就有所理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象语言(Object-Oriented) 都有类的概念，通常用 &lt;code&gt;class&lt;/code&gt; 关键字来定义。在最新的 ES6 标准里，也加入了类的使用，这意味着，js 也能像其它 OO 语言那样很方便地实现继承了。但是，js 的 &lt;code&gt;class&lt;/co
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS实现一个倒计时</title>
    <link href="http://www.brightlam.top/2019/03/16/JS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    <id>http://www.brightlam.top/2019/03/16/JS实现一个倒计时/</id>
    <published>2019-03-16T09:51:39.000Z</published>
    <updated>2019-03-16T09:52:44.360Z</updated>
    
    <content type="html"><![CDATA[<p>你看到这篇文章时，倒计时应该已经结束了。</p><p>又到了金三银四季节，每年这个时候大家都在拼命刷题准备各大公司的招聘，这个时候我们需要对一些常见的面试题有所了解，比如今天要说的就是我在网上看到的，要你<strong>手写一个 js 倒计时效果</strong>，手写代码是什么感觉？速度 70 迈，心情真是嗨，本想好好秀一下的，谁知刚落笔就 … … 告辞！不过，多写代码确实可以保持手感，虽然刚开始会一直支支吾吾写不出，不过越写越顺手，越能发现自己的知识盲点，查漏补缺。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>既然是倒计时，肯定是要涉及到时间日期的操作了。js 里可以用 <code>new Date()</code> 来创建各种格式的时间日期。要能够倒计时，我们需要设置一个起始时间以及一个终止时间，计算出这两段时间的差，然后通过循环调用，每隔 1 秒刷新一次就实现了。假设我们以当前电脑的时间作为起始时间，然后定死一个终止时间，由于起始时间一直在递增，而终止时间不变，那么通过递归后就是一个倒计时了。整体思路不难理解，不过真正实现其代码来还是有诸多需要注意的。</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>知道了大致实现思路后，你可以试着开始手写代码。我们定义一个函数，名为 <code>countDown</code> 。首先获取当前时间，现在是北京时间 <code>2019 年 3 月 16 日，16 时 57 分</code>，倒计时 1 小时，那么终止时间是 <code>2019 年 3 月 16 日，17 时 57 分</code> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function countDown()&#123;</span><br><span class="line">  var nowtime = new Date();</span><br><span class="line">  var endtime = new Date(&quot;2019/03/16,17:57:00&quot;);</span><br><span class="line">  var lefttime = parseInt((endtime.getTime() - nowtime.getTime()) / 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>lefttime</code> 保存着两个时间的差值，<code>getTime()</code> 方法获取到时间戳，由于它是以 <code>ms</code> 为单位的，我们需要精确到秒就可以，所以除以 1000 就是以 <code>s</code> 为单位。<br>接着，我们可以将这个时间分别计算为 <code>天，时，分，秒</code> 了。代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = parseInt(lefttime / (24*60*60))</span><br><span class="line">var h = parseInt(lefttime / (60 * 60) % 24);</span><br><span class="line">var m = parseInt(lefttime / 60 % 60);</span><br><span class="line">var s = parseInt(lefttime % 60);</span><br></pre></td></tr></table></figure></p><p>1 天 24 小时，1 小时 60 分钟，1 分钟 60 秒，稍微转换就能计算出上面几个变量的值。到了这里，<strong>有个小细节需要注意，如果是 10 以下的数我们要进行补零！</strong>。于是我们在写一个补零函数，名为 <code>addZero</code> .<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function addZero()&#123;</span><br><span class="line">  return i &lt; 10 ? &quot;0&quot; + i: i + &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，接下来对上面求得的 <code>d,h,m,s</code> 进行补零。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = addZero(d)</span><br><span class="line">h = addZero(h);</span><br><span class="line">m = addZero(m);</span><br><span class="line">s = addZero(s);</span><br></pre></td></tr></table></figure></p><p>最后我们只需要利用 <code>setTimeout</code> 循环调用，每隔 1 s 刷新就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(showtime, 1000);</span><br></pre></td></tr></table></figure></p><p>OK! 一个倒计时函数大功告成。为了把它显示到浏览器页面上，我们需要在加点 HTML 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">&lt;p class=&quot;count&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>然后在 js 里加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">document.querySelector(&quot;.count&quot;).innerHTML = `活动倒计时  $&#123;d&#125;天 $&#123;h&#125; 时 $&#123;m&#125; 分 $&#123;s&#125; 秒`;</span><br><span class="line">if (lefttime &lt;= 0) &#123;</span><br><span class="line">  document.querySelector(&quot;.count&quot;).innerHTML = &quot;活动已结束&quot;;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 if 判断当倒计时为 0 的时候，就显示 <code>活动已结束</code> , 并且把函数 <code>return</code> 掉。</p><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><p>由于上传 GIF 动图时出现了点小问题，你可以自己 run 下代码并到浏览器查看效果，这样记忆更深哦~</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p class=&quot;count&quot;&gt;&lt;/p&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">      window.onload = function () &#123;</span><br><span class="line">          countDown();</span><br><span class="line">          function addZero(i) &#123;</span><br><span class="line">              return i &lt; 10 ? &quot;0&quot; + i: i + &quot;&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">          function countDown() &#123;</span><br><span class="line">              var nowtime = new Date();</span><br><span class="line">              var endtime = new Date(&quot;2019/03/16,17:57:00&quot;);</span><br><span class="line">              var lefttime = parseInt((endtime.getTime() - nowtime.getTime()) / 1000);</span><br><span class="line">              var d = parseInt(lefttime / (24*60*60))</span><br><span class="line">              var h = parseInt(lefttime / (60 * 60) % 24);</span><br><span class="line">              var m = parseInt(lefttime / 60 % 60);</span><br><span class="line">              var s = parseInt(lefttime % 60);</span><br><span class="line">              d = addZero(d)</span><br><span class="line">              h = addZero(h);</span><br><span class="line">              m = addZero(m);</span><br><span class="line">              s = addZero(s);</span><br><span class="line">              document.querySelector(&quot;.count&quot;).innerHTML = `活动倒计时  $&#123;d&#125;天 $&#123;h&#125; 时 $&#123;m&#125; 分 $&#123;s&#125; 秒`;</span><br><span class="line">              if (lefttime &lt;= 0) &#123;</span><br><span class="line">                  document.querySelector(&quot;.count&quot;).innerHTML = &quot;活动已结束&quot;;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">              setTimeout(countDown, 1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>知识需要通过实践来验证，先学好必备的基础知识，然后找些 demo 来练习巩固，在练习的过程中也许会发现自己以前忽视的一些小问题，也就起到了查漏补缺的作用。在 coding 中寻找快乐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你看到这篇文章时，倒计时应该已经结束了。&lt;/p&gt;
&lt;p&gt;又到了金三银四季节，每年这个时候大家都在拼命刷题准备各大公司的招聘，这个时候我们需要对一些常见的面试题有所了解，比如今天要说的就是我在网上看到的，要你&lt;strong&gt;手写一个 js 倒计时效果&lt;/strong&gt;，手写代
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一个移动端 H5 项目总结</title>
    <link href="http://www.brightlam.top/2019/02/27/%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AF-H5-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://www.brightlam.top/2019/02/27/一个移动端-H5-项目总结/</id>
    <published>2019-02-27T13:30:50.000Z</published>
    <updated>2019-04-19T16:20:51.019Z</updated>
    
    <content type="html"><![CDATA[<p>两个月前做过几个移动端的 H5 页面，一些看似简单的东西一旦动手做起来总是会出现许多各式各样的问题，所以把这些问题记录下来，自己没事翻一翻，而且没准以后别人也遇到类似的问题，就可以供别人做参考，或者有个思路去解决。</p><h4 id="position-fixed-定位失效"><a href="#position-fixed-定位失效" class="headerlink" title="position: fixed 定位失效"></a>position: fixed 定位失效</h4><p>需求里要求把导航栏固定在顶部，这个也很简单，当然就是一个<code>position: fiexed</code> 的事，然而到 Chrome 上调成手机模式一看，emm , 手指一滑导航栏也跟着走了，可能很多程序员都有过这样的错觉，写代码写的美滋滋，一到浏览器一看，理想与现实的差距啊！出现这种情况，那说明 <code>position: fiexed</code> 没起到作用，首先检查了下是不是这行代码拼写出了问题，发现没有问题；接着进入浏览器控制台用光标指向了这个元素，查看它对应的 css 样式，发现并没有出现 <code>position: fiexed</code> ; 于是，去 google 了一下，看了许多关于这个问题的解释，发现这么一句话：<code>父级元素如果有transform属性，会导致子元素的fixed失效。解决是父元素去掉 transform 属性或者父元素加 display：inline;</code> 按照这个去修改了相应的代码，发现<strong>还是没效果！！！</strong>好吧，最后，把那一个模块的代码全删了重新写，并且按上面说的确保父元素没有 transform 之类的属性，终于有了导航栏固定顶部的效果。</p><p>几点启示：</p><ol><li>写代码要细心在细心，注意规范，否则写到后面很容易陷入混乱，一下子看不出哪里出了问题，又不知从哪调试起。</li><li>用好 google 或百度等搜索引擎</li><li>一个良好的心态有助于你在调试代码时更容易发现问题</li></ol><h4 id="手机端手指滑动轮播效果"><a href="#手机端手指滑动轮播效果" class="headerlink" title="手机端手指滑动轮播效果"></a>手机端手指滑动轮播效果</h4><p>简单的图片轮播用 js 或 jq 即可实现，需要注意的是在移动端，轮播图需要配合手指滑动，如何能让手指滑动的时候图片跟着切换？去网上 search 了一下，最终采用了一个叫做 <code>hammer.js</code> 的移动端手势插件，其在线 cdn 是 <code>https://cdn.bootcss.com/hammer.js/2.0.8/hammer.min.js</code> , 直接用<code>script</code> 标签在线引进项目文件即可。然后需要在你自己的 js 文件里做如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    var myElement= document.getElementById(&apos;轮播 div 的 id 名称&apos;);</span><br><span class="line">    // 实例化</span><br><span class="line">    var hm = new Hammer(myElement);</span><br><span class="line">    // 监听 swipeleft 和 swiperight 事件，使手指向左向右滑动切换</span><br><span class="line">    hm.on(&quot;swipeleft&quot;,function()&#123;</span><br><span class="line">        $(&apos;# id 名称&apos;).carousel(&apos;next&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">    hm.on(&quot;swiperight&quot;,function()&#123;</span><br><span class="line">        $(&apos;# id 名称&apos;).carousel(&apos;prev&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这样，在手机端你就可以通过手指滑动来实现图片轮播了。</p><h4 id="布局错位"><a href="#布局错位" class="headerlink" title="布局错位"></a>布局错位</h4><p>通常一个移动端的 H5 页面都有一些常见的布局，比如一行显示两个，连续几行铺排下去，又或是左边图片右边文字这样几行的布局。这些用 flex 布局或者用 bootstrap 的栅格布局一下子就搞定。问题出现在用了 bootstrap 的栅格布局后，刚开始挺好，等回过头看的时候发现布局乱了，原先一行显示两张图片，突然有一张被挤了下来。这无非就几种情况，要么某一个 div 的宽度过大撑起来，将旁边的挤了下来；要么就是 padding 或 margin 等边距问题，仔细排查下应该就能发现问题。再者，如果是电商，有分页功能，某一页出现了问题调好了，另外一页又变乱了，这时候就应该从全局去看整个模块的代码去分析了，在使用 bootstrap 的 UI 组件时可以读下相关的文字说明，结合实际情况分析改进，就可以避免一些冲突。</p><h4 id="label-标签模拟单选、复选框"><a href="#label-标签模拟单选、复选框" class="headerlink" title="label 标签模拟单选、复选框"></a>label 标签模拟单选、复选框</h4><p>为了让按钮看起来更美观，提升用户体验，现在通常不直接用 <code>input</code> 标签的单选、复选按钮，而是用 <code>label</code> 标签结合 <code>for</code> 属性来模拟。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTML代码</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;serach-moible&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;serach-moible&quot;&gt;苹果&lt;/label&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码</span><br><span class="line">.test input&#123; opacity: 0; &#125;</span><br><span class="line">label&#123;</span><br><span class="line">   display: block;</span><br><span class="line">   font-size: 14px;</span><br><span class="line">   line-height: 14px;</span><br><span class="line">&#125;</span><br><span class="line">input[type=checkbox]+label::before&#123;</span><br><span class="line">   content: &apos;&apos;;</span><br><span class="line">   background: transparent;</span><br><span class="line">   border: 1px solid #000;</span><br><span class="line">   box-shadow: inset 0 0 0 2px #fff;</span><br><span class="line">   cursor: pointer;</span><br><span class="line">   display: inline-block;</span><br><span class="line">   width: 12px;</span><br><span class="line">   height: 12px;</span><br><span class="line">   margin-right: 12px;</span><br><span class="line">   position: relative;</span><br><span class="line">   top: 2px;</span><br><span class="line">&#125;</span><br><span class="line">input[type=checkbox]:checked+label::before&#123;</span><br><span class="line">   background: #000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行起来是什么样子，你可以自己跑一下看看。模拟的过程就是先将原先的 <code>input</code> 标签隐藏，把按钮的样式添加在 <code>label</code> 标签上，当你点击 label 时，实际上就是选中了 input 单选按钮，为了这样，你必须要把 input 标签的 id 的值跟 label 标签的 for 属性值保持一致，这样就能通过操作 label 来操作按钮。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不管学什么知识，实践是检验效果的唯一标准，多动手多实践，哪怕在简单的东西也要亲自去敲一遍代码才能有所了解，养成良好的编码习惯，有问题借助搜索引擎，不要死盯在一个点上，保持好心态继续做下去，可能哪个瞬间就把问题解决了。</p><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两个月前做过几个移动端的 H5 页面，一些看似简单的东西一旦动手做起来总是会出现许多各式各样的问题，所以把这些问题记录下来，自己没事翻一翻，而且没准以后别人也遇到类似的问题，就可以供别人做参考，或者有个思路去解决。&lt;/p&gt;
&lt;h4 id=&quot;position-fixed-定位
      
    
    </summary>
    
    
      <category term="移动端" scheme="http://www.brightlam.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习之路-语法篇(下)</title>
    <link href="http://www.brightlam.top/2019/01/11/JavaScript-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95%E7%AF%87-%E4%B8%8B/"/>
    <id>http://www.brightlam.top/2019/01/11/JavaScript-学习之路-语法篇-下/</id>
    <published>2019-01-11T09:04:38.000Z</published>
    <updated>2019-01-11T09:05:26.556Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间一直在期末复习，这几天考完试末，轻松了许多，终于放假啦。</p><p>上篇文章（很久了）说的是 JavaScript 的操作符，有相等操作符、条件操作符、赋值操作符等等，这篇文章写的是语法篇的最后两个内容：<code>语句</code> 和 <code>函数</code> 。</p><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>语句由一个或多个词组成，可以完成某些任务和操作。</p><h6 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h6><p>最常用也很熟悉的语句了，它的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    block1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    block2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 condition 会被转换成一个布尔值来确定执行那一块代码，例如如果 condition 为 true，则执行 block1 的代码，否则执行 block2 。如果想要更省事一点，也可以直接用三目运算符来替代 if 语句，例如下面的代码跟上述的 if 语句是一样的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? block1 : block2 ;</span><br></pre></td></tr></table></figure></p><h6 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h6><p>一种循环语句，它会至少先执行循环体内的代码一次，然后在根据条件判断是否继续循环，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    code</span><br><span class="line">&#125; while (condition);</span><br></pre></td></tr></table></figure></p><h6 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h6><p>看看它的语法，比较下跟 do-while 的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (condition) &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，while 循环语句是上来就开始判断 condition 是否为 true ，是的话才会执行代码，否则不会执行；而前面的 do-while 循环是会至少执行一次代码再来判断条件，这就是区别。</p><h6 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h6><p>依然是循环语句，而且也是经常使用的循环语句。它的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( init; expression; loop-expression) &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>怎么使用它呢？下面的代码会输出 1 到 10 之间的数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i&lt;=10; i++) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实 while 循环能做到的，for 循环也同样能做到，上面的如果用 while 循环是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>既然这样，那还要 for 循环干嘛呢？for 循环可以做到根据已知条件来确定循环次数，比如你要打印某个数 10 次，那用 for 循环，中间 i &lt; 10 直接写就好了；但如果事先并不知道要循环多少次，条件也不是很清楚，那么用 while 循环先执行着也是不错，如果这段代码要先被执行一次，那就用 do-while 好了。</p><h6 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h6><p>是一种迭代语句，可以用来枚举对象的属性，非常实用的语句。语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var propName in window) &#123;</span><br><span class="line">    document.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行这段代码你将看到浏览器 window 对象的所有可枚举属性。</p><h6 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a>label 语句</h6><p>label 语句可以在代码中添加标签，以便将来使用，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelName: code</span><br></pre></td></tr></table></figure></p><p>通常会与 for 等循环语句配合使用，由 break 或 continue 语句来引用。</p><h6 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h6><p>break 语句可以让代码停止执行，用在 for 语句中会立即退出循环；而 continue 语句也是让代码停止执行，但它不会退出循环，而是从循环的顶部继续执行，也就是在执行下一次循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;=  10; i++) &#123;</span><br><span class="line">    if ( i % 5 == 0) &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码找出 10 以内能被 5 整除的数，找到了就输出，而且找到了就不找了，立刻停止退出循环，最后输出的结果是 <code>5</code> 。而如果使用 continue 替代 break 呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;=  10; i++) &#123;</span><br><span class="line">    if ( i % 5 == 0) &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>答案显而易见，会输出 <code>5</code> 以及 <code>10</code> 。因为找到了一个 5 之外，continue 的意思是不用再执行下面的代码了，从顶部开始下一次循环再找。</p><h6 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h6><p>with 语句可以简化代码量，以一个特定的对象来开头，减少重复书写它的次数，例如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var qs = location.search;</span><br><span class="line">var hostName = location.hostname;</span><br><span class="line">var url = location.href;</span><br></pre></td></tr></table></figure></p><p>每次都需要用到 location 这个对象，我们可以把它关联起来，用 with 语句改写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with (location) &#123;</span><br><span class="line">    var qs = search;</span><br><span class="line">    var hostName = hostname;</span><br><span class="line">    var url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就不必时刻写 location 字段了，需要注意的是，该语句在 <code>严格模式</code> 下是报错不能用的。</p><h6 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h6><p>最后一个是 switch 语句，它是为了解决 if 语句分支过多过长的问题，例如下面这段冗长的 if 语句代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if ( i == 100) &#123;</span><br><span class="line">    alert(&apos;恭喜你考了满分&apos;);</span><br><span class="line">&#125; else if ( i == 90) &#123;</span><br><span class="line">    alert(&apos;优秀&apos;);</span><br><span class="line">&#125; else if (i == 80) &#123;</span><br><span class="line">    alert(&apos;很不错&apos;);</span><br><span class="line">&#125; else if (i == 70) &#123;</span><br><span class="line">    alert(&apos;勉强还行&apos;);</span><br><span class="line">&#125; else if (i == 60) &#123;</span><br><span class="line">    alert(&apos;在挂科的边缘疯狂试探&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&apos;骚年，补考见&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>switch 语句为了优化上述代码，写成这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">switch (i) &#123;</span><br><span class="line">    case 100:</span><br><span class="line">        alert(&apos;恭喜你考了满分&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case 90:</span><br><span class="line">        alert(&apos;优秀&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case 80:</span><br><span class="line">        alert(&apos;很不错&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case 70:</span><br><span class="line">        alert(&apos;勉强还行&apos;);</span><br><span class="line">        break;</span><br><span class="line">    case 60:</span><br><span class="line">        alert(&apos;在挂科的边缘疯狂试探&apos;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        alert(&apos;骚年，补考见&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>switch 语句的好处是能根据条件 i 的值，来决定是到那一段 case 代码中去执行，并且执行完后就 break 掉，而不执行接下来的其它 case ，这样条例清晰、一一对应，而 default 就是上面所有 case 都不管用了，那就默认执行它里面的内容。</p><p>上面这九大语句，基本就是一门编程语言中常用到的语句了，基本上其它编程语句也都是这么几种，只不过语法稍微有所差别，写法不同而已，只要熟悉了上述这几种语句，在其他语言中同样适用，毕竟语言是互通的。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数也是每门编程语言都会有的语法概念。有没有相过，如果一个页面里面充斥着大量的语句，这些语句实现着各种功能，有些还经常是重复的，你其实多写了几遍。这时候，你可以考虑把这些<code>语句</code>集合起来，封装成一个<code>函数</code>。<code>函数</code>就是封装了任意多条语句，每次需要用的时候就调用它，通过什么标识来区别函数呢？函数名，js 中函数使用 <code>function</code> 关键字来声明，后面紧接的就是函数名，在接着就是圆括号，里面存放的是函数的参数，用 <code>，</code>隔开，最后就是函数的主体代码了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function funName(arg1,arg2,arg3) &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是 js 定义一个函数的格式。函数可以有一个 <code>return</code> 语句，表示该函数返回结果，如果使用了 return 语句，则后面的代码一概不会被执行，比如下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(a,b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">    console.log(&apos;hello world&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输入两个参数值 a 和 b 调用 sum 函数，可以计算 a + b 的结果，但后面那句 hello world 是不会被执行了，因为 return 语句就是最终语句了，函数遇到 return 后就会立即停止退出。另外，还有一个 <code>arguments</code> 类数组对象一直存放着函数的参数，使用 arguments 可以获取函数的参数信息，比如上面的 sum 函数，以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sum(a,b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">    console.log(&apos;hello world&apos;);</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你 <code>sum(10,20)</code> 调用函数后，最后那句代码会输出 <code>2</code>，因为你输入了 10、20 两个参数，长度为 2 ，前面说了，<code>arguments</code> 存放的是参数的信息，它是一个类似数组的东西，所以你可以用 <code>arguments[0]</code> 表示第一个参数，也就是 10；用 <code>arguments[1]</code> 表示第二个参数，也就是 20 。</p><p>由于 js 的函数参数实际上是一个数组，所以不传值或者少传多传都不会报错，这点可以说是非常宽松的，相比其他语言来说。你可以随意输入多个参数，只不过会显示 undefined 。</p><p>js 的函数没有<code>重载</code>这一概念，如果定义两个名字相同函数，则后者覆盖前者。但由于有 arguments 数组的存在，可以通过使用 if 语句判断传入的 arguments 参数来相应执行不同的代码，也算是模拟重载。</p><p>(全文完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这段时间一直在期末复习，这几天考完试末，轻松了许多，终于放假啦。&lt;/p&gt;
&lt;p&gt;上篇文章（很久了）说的是 JavaScript 的操作符，有相等操作符、条件操作符、赋值操作符等等，这篇文章写的是语法篇的最后两个内容：&lt;code&gt;语句&lt;/code&gt; 和 &lt;code&gt;函数&lt;/c
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>python 学习笔记(二)</title>
    <link href="http://www.brightlam.top/2019/01/08/python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>http://www.brightlam.top/2019/01/08/python-学习笔记-二/</id>
    <published>2019-01-08T09:30:40.000Z</published>
    <updated>2019-01-08T09:31:48.879Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>两点之间的距离公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">math.sqrt(f)</span><br><span class="line">f = (x1 - y1) ** 2 + (x2 - y2) ** 2</span><br></pre></td></tr></table></figure></li><li><p>两个字符串连接，用格式化 <code>&#39;%s%s&#39;%(a,b)</code></p></li><li><p>列表的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最大函数   max(list)</span><br><span class="line">最小函数   min(list)</span><br><span class="line">计数函数   count(list)</span><br></pre></td></tr></table></figure></li><li><p>判断一个整数是否回文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def isHuiWen(num):</span><br><span class="line">    a = reversed(list(num))</span><br><span class="line">    if(list(a) == list(num)):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></li><li><p>把一个列表中的数转换成字符串输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; &apos;.join(&apos;%s&apos; %id for id in arr)</span><br></pre></td></tr></table></figure></li><li><p>用列表表达式输入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [int(i) for i in input().split()]   // 此时可以在控制台输入一行以空格分割的整数</span><br></pre></td></tr></table></figure></li><li><p>列表切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = [1,5,8,7,9,8,7,6,2];</span><br><span class="line">l[:]   // 复制列表</span><br><span class="line">l[0:3]  // 取前三个数</span><br><span class="line">l[::3]  // 所有的数每 3 个取一个</span><br><span class="line">l[:6:2]  // 前 6 个数每 2 个取一个</span><br><span class="line">l[2:6]  // 取第 3 个到第 6 个之间的数(不包括 6)</span><br></pre></td></tr></table></figure></li><li><p>十进制转换为二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 10</span><br><span class="line">bin(x).replace(&apos;0b&apos;,&apos;&apos;)</span><br><span class="line">bin(x)[2:]</span><br></pre></td></tr></table></figure></li><li><p>二进制转换为十进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = 1100</span><br><span class="line">int(y,base=2)</span><br></pre></td></tr></table></figure></li><li><p>二进制补 0 操作（16位）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1,16):</span><br><span class="line">    if len(sx)&lt;16:</span><br><span class="line">        sx=str(0)+sx</span><br><span class="line">    if len(sy)&lt;16:</span><br><span class="line">        sy=str(0)+sy</span><br></pre></td></tr></table></figure></li><li><p>集合的差集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = list(set(A).difference(set(B))   // 属于 A 不属于 B 的元素</span><br><span class="line">x.sort(key = A.index)    // 按 A 集合的元素顺序</span><br><span class="line">intersection()   // 该方法返回集合的交集</span><br><span class="line">union()   // 该方法返回集合的并集</span><br></pre></td></tr></table></figure></li><li><p>大小写字母的 ASCII 符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print([chr(i) for i in range(65,91)])    // 输出 26 个大写字母</span><br><span class="line">print([chr(i) for i in range(97,123)])   // 输出 26 个小写字母</span><br><span class="line">ord(&apos;a&apos;)   // 输出 97，将字母转换为 ASCII 符</span><br><span class="line">chr(97)  // 输出 a ，将 ASCII 符转换为字母</span><br></pre></td></tr></table></figure></li><li><p>title(): 返回首字母大写的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;glad to meet you&apos;</span><br><span class="line">print(s.title())   // Glad To Meet You</span><br></pre></td></tr></table></figure></li><li><p>列表的元素删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,9,7,6]</span><br><span class="line">list.pop(2)    // 删除第 3 个数</span><br><span class="line">list.remove(6)  // 删除值为 6 的元素</span><br></pre></td></tr></table></figure></li><li><p>while k in arr 和 if k in arr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个会循环所有值为 k 的元素；后者只找到第一个值为 k 的元素</span><br></pre></td></tr></table></figure></li><li><p>sys 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    ...</span><br><span class="line">上述语句可以从 pycharm 控制台不断读取 input 输入，直到按 Ctrl + D 停止</span><br></pre></td></tr></table></figure></li><li><p>函数 zip() :将对象中对应的元素打包成元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = [4,5,6]</span><br><span class="line">zip(a,b)   // [(1,4),(2,5),(3,6)]</span><br></pre></td></tr></table></figure></li><li><p>遍历矩阵输出矩阵的每一个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s_mtx = []   // 这是一个矩阵</span><br><span class="line">// 按照顺序输出每一行中的每一个数</span><br><span class="line">for c in range(3):</span><br><span class="line">    print(s_mtx[0][c], s_mtx[1][c], s_mtx[2][c], end = &apos; &apos;)</span><br></pre></td></tr></table></figure></li><li><p>求绝对值函数 fabs() 和 abs()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fabs() 是在 math 模块中定义的，需要导入；而 abs() 函数是内置函数；</span><br><span class="line">fabs() 只适用于 float 和 integer 类型，而 abs() 也可以适用于复数</span><br></pre></td></tr></table></figure></li><li><p>EOFError 报错解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">   ...</span><br><span class="line">except EOFError:</span><br><span class="line">   break</span><br></pre></td></tr></table></figure></li><li><p>operator.itemgetter 模块：可以获取对象的某些维数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from operator import itemgetter</span><br><span class="line">a = [1,2,3]</span><br><span class="line">fetch = itemgetter(1)</span><br><span class="line">fetch(a)   // 取出第二个数，即为 2</span><br><span class="line">fetch2 = itemgetter(2,1)</span><br><span class="line">fetch2(a)   // 取出位置为 2 和 1 的数并交换位置，即为 3,2</span><br><span class="line">// 可以作为 key 传递给 sorted() 函数排序</span><br></pre></td></tr></table></figure></li><li><p>reverse() 和 reversed()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse() 方法用于列表，可以反转一个列表的顺序</span><br><span class="line">reversed() 方法是一个反转迭代器，其参数可以是列表、字符串或者 range</span><br></pre></td></tr></table></figure></li><li><p>读取一个文件, 假设文件名为 file.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;file.txt&apos;) as js:</span><br><span class="line">  for line in js:      // 对文件内容中的每一行进行操作</span><br><span class="line">    ...</span><br><span class="line">  // 也可以将所有内容读取出来，存放到 content 里</span><br><span class="line">  content = js.read()</span><br></pre></td></tr></table></figure></li><li><p>将结果写入一个文件，假设文件名为 result.txt，结果是一个列表 arr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;result.txt&apos;,&apos;w&apos;) as jg:</span><br><span class="line">  for r in arr:</span><br><span class="line">    jg.write(r)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;两点之间的距离公式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="python" scheme="http://www.brightlam.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习之路-语法篇(中)</title>
    <link href="http://www.brightlam.top/2018/12/08/JavaScript-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95%E7%AF%87-%E4%B8%AD/"/>
    <id>http://www.brightlam.top/2018/12/08/JavaScript-学习之路-语法篇-中/</id>
    <published>2018-12-08T08:16:46.000Z</published>
    <updated>2018-12-08T08:17:46.446Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章分享了 JavaScript 的基本语法、严格模式的启用，还有变量、五大基本数据类型以及所定义的一些关键字保留字等。在这篇文章里，你可以了解到 JavaScript 中的各类操作符，这些操作符有些很熟悉，一直在用，有些可能平时不太注意，但也会多少用到。</p><h4 id="花式操作符"><a href="#花式操作符" class="headerlink" title="花式操作符"></a>花式操作符</h4><p>操作符，顾名思义，就是对数据进行操作。JavaScript 能参与运算的操作符很多，有一元操作符、位操作符、乘性操作符等等，接下来一一介绍下这些操作符，很多都是挺熟悉经常在用的。</p><h6 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h6><p>最基本的就是一元操作符，意思是只能操作一个数值。我们最常见到的就是 <code>++</code> 和 <code>--</code> 了，它可以对一个数进行递增或递减。看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 1;</span><br><span class="line">++num;   // 2</span><br></pre></td></tr></table></figure></p><p>也可写成 <code>num = num + 1</code> 是一样的效果，相应地，<code>--</code> 操作符就是 <code>--num</code> 或 <code>num = num - 1</code> 。这里特别要注意的是两个操作符的放置位置：<strong>如果在变量前面，则先自增/自减再去执行语句操作，而如果在后面，则先执行语句，完了在自增/自减。</strong>来看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = 2;</span><br><span class="line">var c = --a + b   //  11，a 先减去1在加 b</span><br><span class="line">var d = a-- + b   // 11, 由于上条语句 --a 使得 a 变成 9 ，在加 b 等于 11</span><br><span class="line">console.log(a)   // 此时 a 已经是 8</span><br></pre></td></tr></table></figure></p><p>仔细体会下上面语句的执行结果，就能明白 <code>++</code> 和 <code>--</code> 在变量的不同位置其效果是不一样的。</p><p>除此之外，还有一元操作符 <code>+</code> 和 <code>-</code> ,普通的加减都知道的了。这里需要注意的是这两个符号可以用来<strong>转换数据类型</strong>。看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = false;</span><br><span class="line">var b = 1;</span><br><span class="line">var c = &#123;</span><br><span class="line">   valueOf: function() &#123;</span><br><span class="line">      return -1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">+a   // 0</span><br><span class="line">+b  // 1</span><br><span class="line">-b  // -1</span><br><span class="line">+c  // -1</span><br><span class="line">-c  // 1</span><br></pre></td></tr></table></figure></p><p>这种隐式转换在写代码时经常用到。</p><h6 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h6><p><code>~</code> 表示按位非，它会对一个数的二进制进行操作，返回它的反码，最终得到的结果就是原数值的负值减 1。所以 <code>~25</code> 的结果就是 <code>-26</code>，那为什么不直接对 25 取负值然后在减 1 不就好了？也是可以的，但是用 <code>~</code> 操作符是在计算机底层进行二进制操作，所以速度更快，追求性能的话首选。</p><p><code>&amp;</code> 表示按位与，同样是二进制操作。<strong>只有当两个数位同时为 1 时才返回 1，其余都都返回 0 。</strong>例如求 <code>25 &amp; 3</code>，先把 25 和 3 分别以二进制表示，我们知道二进制只有 0 和 1 两个表示，将它们对应的位进行运算，同时为 1 则返回 1，否则都是 0 ，最后将得到的二进制数重新翻译成十进制就得到结果了。</p><p><code>|</code> 表示按位或，与 <code>&amp;</code> 类似的二进制操作，不过这次是<strong>只有当两个位数同时为 0 才返回 0，其余都会返回 1。</strong>所以求 <code>25 | 3</code>，你不妨写几句代码，运行下看看是什么结果，上次说了，用 <code>toString(n)</code> 方法可以返回一个数的 n 进制表示。</p><p><code>^</code> 按位异或，与 <code>|</code> 的不同在于，<strong>只有当两个数位同时为 1 或 同时为 0 时会返回 0，其余都返回 1 。</strong></p><p><code>&lt;&lt;</code> 左移操作符，将一个数向左移动得到的结果，移动后的空位会以 0 来填充。例如求 <code>2 &lt;&lt; 5</code> ，2 的二进制是 <code>10</code>，向左移动 5 为，就相当于在后面补 5 个 0，得到 <code>10 00000</code> 转换成十进制就是 64，所以 <code>2 &lt;&lt; 5</code> 就是 64。</p><p><code>&gt;&gt;</code> 右移运算符，将一个数向右移动得到的结果，移动后的空位会以<strong>符号位</strong>来填充。例如将上面的 <code>64 &gt;&gt; 5</code> 就相当于让 <code>10 00000</code> 向右移动五位，就是 <code>10</code> ，左边空出来的位以符号位 0 填充，可以忽略，所以得到的结果是 2 。</p><p><code>&gt;&gt;&gt;</code> 无符号右移，跟 <code>&gt;&gt;</code> 一样，只不过它移动后的空位会以<strong>0</strong>来填充，所以右移后的数值会非常大，具体可以自己去用代码验证下。</p><h6 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h6><p>布尔符应该很熟悉了，有 3 个，分别是非<code>!</code>，逻辑与<code>&amp;&amp;</code> 和逻辑或<code>||</code>。</p><p><code>!</code> 取反符，将一个数值转换为布尔值，在取反。所以<code>!true</code> 等于 false，<code>!0</code> 等于 true 等等。这个符号经常用在 if 等语句中。</p><p><code>&amp;&amp;</code> 逻辑与，当且仅当两个值都为 true 时才返回 true，其余都返回 false 。经常用在 if 语句的条件判断中，也就是两个条件都要满足时才予以执行。它是短路操作符，也就是说，如果第一个值是 false 了，那么第二个值无论是什么，都不会再去求它，结果已经是返回 false 了。</p><p><code>||</code> 逻辑或，也是短路操作符，当且仅当两个值都为 false 时才返回 false，其余情况都会返回 true。这个操作符大有用处，在定义变量的时候，经常会用到下面这条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str = result || &apos;&apos;;</span><br></pre></td></tr></table></figure></p><p>这条语句的意思是优先把这个 result 的值赋给 str，如果找不到它，那就默认赋个空字符串给它，这样就避免了值为 undefined 或 null，从而避免遇到执行错误。</p><h6 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h6><p>这个同样很熟悉，三个乘性操作符分别为 <code>*</code>，<code>/</code> 以及 <code>%</code> 。关于乘和除，平常用的够多了，就跟数学的乘除一样，需要注意的就是一些特殊情况，如 NaN 值，infinity 值以及非数值如字符串，这些参与乘除运算会出现什么样的结果，你可以动手去试下，印象会更深。</p><p><code>%</code> 对一个数进行求模。举个例子，<code>21 % 5</code> 会得到 1，为什么呢？21 除以 5 不能整除，只能得到商 4，最后余数为 1，所以记住 <code>%</code> 操作符就是去取余数。那请问 <code>2 % 5</code> 会得到多少？你可以去试下。</p><h6 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h6><p>就两个符号，<code>+</code> 和 <code>-</code> 。跟数学的加减一样，但比较有意思的是涉及到非数值类型，如字符串，看看下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result = 5 + &apos;5&apos;;</span><br><span class="line">console.log(result);   // &apos;55&apos;</span><br></pre></td></tr></table></figure></p><p>是的，你没看错，5 去加字符串的 5 ，最终得到的是 55 ，这个 55 是字符串的 55 ，也就是说，解释器先将第一个数值转换成了字符串，然后在与第二个字符串想 <code>+</code>，最终得到的是一个拼接的字符串，所以是 <code>&#39;55&#39;</code> 。</p><p>而对于减法符号 <code>-</code>，就不一样了，前面提到的将数值转换成字符串在进行加，而如果一个数值去跟一个字符串数值相减，结果不会是字符串，而是一个正常的数值，例如 <code>5 - &#39;5&#39;</code> 会得到 0，解释器将后面的字符串转成了数值，然后进行相减。<strong>所以，<code>-</code> 操作符用处很大，它可以进行隐式转换，即将一个字符串转成数值，不必去调用方法，只需一个符合就行。</strong></p><h6 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h6><p>关系操作符有 <code>&lt;</code> 和 <code>&gt;</code> 以及 <code>&gt;=</code> ，<code>&lt;=</code> 。它们的用处是比较两个字符串或数字之间的大小，对于字符串而言，比较是按照字符串编码值来，所以会出现 <code>&quot;Brick&quot; &lt; &quot;apple&quot;</code>，为什么会这样呢？因为 ASCII 编码中大写字母 A 是从数字 65 开始计的，而小写字母 a 从 91 开始，因为「B」的编码数值小于「a」，所以<code>&quot;Brick&quot; &lt; &quot;apple&quot;</code>，解决方法是使用 <code>toLowerCase()</code> 转换大小写在比较；对于数值而言，同样会出现如 <code>&quot;23&quot; &lt; &quot;3&quot;</code> 这样子，因为 <code>2 &lt; 3</code> 而导致的，解决方法是转换为基本数据类型中的 Number 类型进行比较。</p><h6 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h6><p>分为相等 <code>==</code> 和全等 <code>===</code> 两个操作符。前者会自动转换数据类型进行比较，例如 <code>&quot;5&quot; == 5</code> 返回结果为 true，因为字符串会被转换为数值然后参与比较；而如果是 <code>&quot;5&quot; === 5</code> 就是 false 了，<code>===</code> 不会进行类型的转换，该怎么比较就怎么比较，这也是我们想要的结果，所以比较推荐使用全等符。</p><h6 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h6><p><code>compare? result1:result2;</code>俗称三目运算符，意思是执行这个 compare 语句，如果为 true 的话返回 result1 ，否则返回 result2。相信你已经猜到了，它可以适时替代掉 if - else 语句，有相同的效果。</p><h6 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h6><p>分别是 <code>=</code> 和 <code>+=</code> ，用来赋值的符号，后者 <code>+=</code> 在用的时候例如 <code>x += 1</code>，与 <code>x = x + 1</code> 是一样的，设计这个符号就是为了简化操作，没什么特别的地方。</p><h6 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h6><p>逗号操作符可以用来声明多个变量，比如连续声明四五个变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 0,</span><br><span class="line">    y = 0,</span><br><span class="line">    z = 0,</span><br><span class="line">    num = 0,</span><br><span class="line">    count = 0;</span><br></pre></td></tr></table></figure></p><p>很方便地声明变量而不用写多条语句。特别注意的是，假如你同时给一个变量赋了多个值，最终保留最后一个，所以 <code>var num = (5,4,2,3,0)</code> ,最终 num 的值就是 0 。</p><p>未完待续… …</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><blockquote><p>《JavaScript 高级程序设计》     [美] Nicholas C.Zakas 著</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章分享了 JavaScript 的基本语法、严格模式的启用，还有变量、五大基本数据类型以及所定义的一些关键字保留字等。在这篇文章里，你可以了解到 JavaScript 中的各类操作符，这些操作符有些很熟悉，一直在用，有些可能平时不太注意，但也会多少用到。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习之路-语法篇(上)</title>
    <link href="http://www.brightlam.top/2018/12/01/JavaScript-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%AF%AD%E6%B3%95%E7%AF%87-%E4%B8%8A/"/>
    <id>http://www.brightlam.top/2018/12/01/JavaScript-学习之路-语法篇-上/</id>
    <published>2018-12-01T09:44:00.000Z</published>
    <updated>2018-12-01T09:44:58.824Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了 JavaScript 的基本概念和发展概况，这篇文章将开始讲 JavaScript 的一些基本语法概念。</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>学一门编程语言，首先无非就是了解它的基本语法，例如变量、标识符、关键字、数据类型以及函数等等，然后应用这些东西去写出你相要的程序，当然程序也分很多种，就像只输出一句<code>hello world</code>也是一个程序对吧。那么这些在 JavaScript 里是如何规定和体现的呢？</p><h4 id="语法-不基于-ES6"><a href="#语法-不基于-ES6" class="headerlink" title="语法(不基于 ES6)"></a>语法(不基于 ES6)</h4><p>JavaScript 是区分大小写的，所以 <code>May</code> 和 <code>may</code> 是两个不同的变量名称。当使用变量时，一般驼峰式的命名写法，例如定义一个打招呼的变量是这样 <code>var sayHello = &#39;hello world;&#39;</code> ，当然并没有强制规定要这样写。这里的 <code>sayHello</code> 称作 <code>标识符</code> ，<strong>标识符的第一个字符必须是字母、下划线或者 $</strong> ,这意味着你不能命名一个变量诸如 <code>12say</code> 或者 <code>^hello</code> 等等，另外也不能用一些关键字作为标识符，否则都会报错。所以，养成一个良好的命名习惯很有必要，多用一些英文字符命名，实在不会英文可以用拼音代替，并且尽量避开一些关键字和保留字。关于关键字和保留字下面会提到。</p><p>当你写了 <code>var sayHello = &quot;hello world&quot;;</code> 时，实际上就写了一条<code>语句</code> 。语句是我们能看懂的编程代码，它会被编译成计算机能识别的二进制代码，浏览器去解释执行这些代码就会有效果出来，比如上面那句在加上一条打印输出语句<code>console.log(sayHello);</code> 就能在控制台输出你经常看到的 <code>hello world</code> 了。当你想注释掉语句怎么办？JS 里的注释跟大多语言类似，单行注释采用 <code>//</code>，多行注释用 <code>/* 这里是需要注释的内容 */</code> 就可以实现。</p><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ES5 新引入了<code>严格模式</code>这一概念，在严格模式里，很多内容都作出了完整规范的限制，比如你像前面一样声明一个 <code>sayHello</code> 变量时，如果前面没有 <code>var</code> 关键字，那运行就会报错，为何这样呢？因为浏览器不懂它到底是干嘛的，你在前面加上 <code>var</code> ，浏览器会明白它是一个变量，加上 <code>const</code> 关键字，浏览器会懂它是一个不可变的常量，所以你什么都不说，让别人去猜，它肯定就不鸟你了，这解释纯属瞎猜瞎扯，可以听听，切莫当真。想要启用<code>严格模式</code>，只需在你的 js 文件里加上下面这句代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br></pre></td></tr></table></figure></p><p>浏览器就能严格的目光来看待所有内容了，这个模式是被建议采用的，这样可以避免一些不必要的错误发生，可以先了解下。</p><h4 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h4><p>这类单词通常具有某种用途，比如前面说到的 var 和 const 分别是用来定义变量和常量的，所以不能用他们做标识符，以免不必要的冲突。常用的关键字有以下这些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">break    do      instanceof    typeof    case    else    new    var</span><br><span class="line">catch    finally   return      void    continue   for   switch   while</span><br><span class="line">debugger function   this       with    default    if    throw    delete</span><br><span class="line">in       try</span><br></pre></td></tr></table></figure></p><p>而保留字，顾名思义，就是保留着，将来可能也会被用作关键字，因此最好也不要用它们。ECMA-262 第 3 版定义的保留字有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract  enum    int     short   boolean   export   interface     static   byte</span><br><span class="line">extends   long    super   char    final     native   synchronized  class    float  </span><br><span class="line">package   throws  const   goto    private   transient  debugger    implements protected</span><br><span class="line">volatile  double  import  public</span><br></pre></td></tr></table></figure></p><p>这些关键字和保留字不用时时刻刻去记住它，多熟悉下，用到的时候去查查其实也不浪费多少时间，像这些就肯定不能用作变量名称来命名了，看着都别扭。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>JavaScript 的变量相比 java，c 等语言来说是相对轻松的。你可以随意定义变量的内容和类型，不用像 java 那般去区别是整型还是浮点型还是字符串类型等。像声明一个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,&apos;hello&apos;,undefined,&apos;15&apos;,8];</span><br><span class="line">console.log(arr);   //  [1, &quot;hello&quot;, undefined, &quot;15&quot;, 8]</span><br><span class="line"></span><br><span class="line">var str = &quot;hello world&quot;;</span><br><span class="line">str = 100;</span><br><span class="line">console.log(str);   // 100</span><br></pre></td></tr></table></figure></p><p>是可以的，简直就是大杂烩啊有没有，各种类型都可以放上去，可以说语法是很松散的。第二个例子中先是给 str 赋了一个字符串型，然后又把它改成了数字类型，仍然正常输出了。</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>上面提到的「字符串」、「数字」等就是所谓的 <code>数据类型</code> 。像 java 有八大基本数据类型，在 JavaScript 里，有五大基本数据类型：<code>undefined</code>，<code>null</code>，<code>Boolean</code>，<code>Number</code> ，<code>String</code> .这些基本数据类型可以用 <code>typeof</code> 操作符来检测。下面看看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof &apos;hello world&apos;  // string</span><br><span class="line">typeof 20   // number</span><br><span class="line">typeof null  // object</span><br><span class="line">typeof &quot;hello&quot;  // string</span><br><span class="line">typeof true    // boolean</span><br><span class="line">typeof 2.3   // number</span><br><span class="line">typeof undefined   // undefined</span><br></pre></td></tr></table></figure></p><p>从上面的测试中我们可以总结出，<strong>JavaScript 字符串不分单双引号；数字不分浮点型或者整型，全部为 number 型；对 null 检测类型为 object 对象；对 undefined 检测为 undefined 。</strong></p><p><code>undefined</code> 通常是一个变量声明了但没有赋值，那么它的值就是 undefined，所以你对代码 <code>var str</code> 进行 typeof 就会得到 undefined 。</p><p><code>null</code> 跟 undefined 有着千丝万缕的关系，比较奇妙的就是运行 <code>undefined == null</code> 时会返回 true 。通常认为他们两个是相等的，但如果是全等符 <code>===</code> 就会返回 false 了。前面为什么对 null 应用 typeof 会返回 object 呢？因为 JavaScript 解释器认为 null 是一个空的对象的引用，觉得它是个对象，只是被置为空了。</p><p><code>Boolean</code> 应该很熟悉了，有两个值 true 或 false ，这两个值是区分大小写的，所以你不能把 true 写成 True ，这是隔壁 python 的写法。很多基本类型都可以转换成布尔值，例如非空字符串会转成 true，非零数字会转 true，而空字符串和 0、NaN 等都等同于 false 。除此之外，还有对象 object 也会转 true ，相应的 null 对象则是 false 。</p><p><code>Number</code> 类型应用广泛，有整数和浮点数等等。需要特别记住的是 JavaScript 中浮点数的最高精度是 17 位小数，但在进行算术运算时往往精度会不如预期，所以你会看到 <code>0.1 + 0.2 == 0.3</code> 是 false ，这也是面试中经常会问到的点，0.1 和 0.2 相加是不等于 0.3 的！另外值得注意的是 NaN，它表示的是应该返回数值但却没有返回，通常在其他语言中发生这样都会直接报错，导致程序停止运行，而 JS 不会，它会返回 NaN，让程序继续运行。比如你弄数值弄着弄着搞出个字符串类型，这不是搞笑么，所以返回个 NaN，你自己体会。</p><p><code>String</code> 类型同样经常遇到，声明字符串可以单引号也可以双引号，它采用的是 Unicode 字符编码。字符串有个 <code>length</code> 属性，可以返回长度。还有想要连接两个字符串的话，可以用 <code>+</code> 连接。例如下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line">console.log(s + &apos; world&apos;);   // hello world</span><br></pre></td></tr></table></figure></p><p>它还有个常用的 toString() 方法，可以将其他值转换为字符串，这里典型应用就是可以输出数值的二进制表示等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">console.log(num.toString());   // &quot;10&quot;</span><br><span class="line">console.log(num.toString(2));  // 1010</span><br><span class="line">console.log(num.toString(16));  // a</span><br></pre></td></tr></table></figure></p><p>可以看到，在 toString() 传入一个相应的数字就能转换成几进制的值。默认是转换成十进制的。</p><p>未完待续… …</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章介绍了 JavaScript 的基本概念和发展概况，这篇文章将开始讲 JavaScript 的一些基本语法概念。&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;学一
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 学习之路-起步</title>
    <link href="http://www.brightlam.top/2018/11/25/JavaScript-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E8%B5%B7%E6%AD%A5/"/>
    <id>http://www.brightlam.top/2018/11/25/JavaScript-学习之路-起步/</id>
    <published>2018-11-25T10:18:01.000Z</published>
    <updated>2018-11-25T11:55:23.938Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇讲 JavaScript 基础的文章，接下来会更新这个系列文章。</p><p>JavaScript 诞生于 1995 年，至今已经有 20 几年了，在最新的 <a href="https://2018.stateofjs.com" target="_blank" rel="noopener">JavaScript 2018 年度报告</a> 中，许多人依旧认为这门语言正在朝着好的方向去发展，从最开始的默默无闻到如今的未来可期，JavaScript 作为前端开发者的一门学习语言，一定会被更多爱好编程的人喜欢。如果想了解和学习 JavaScript，请往下看。</p><h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h4><p>在了解 JavaScript 前，首先要了解 ECMAScript ，它是由 ECMA-262 定义的一门语言。它规定了一些基本的语法、变量、语句、操作符以及对象等等内容，<strong>而 JavaScript 去实现了它</strong>，也就是说，JavaScript 去实现了 ECMAScript，我们经常说 JS 的新版本，实际上是 ECMAScript 的新版本，最被人经常用的是第五个版本(ES5) 还有ES6，它包含了许多新知识新特性。简而言之，JavaScript 的概念更广，它包含了 ECMAScript ，除此之外还有文档对象模型 (DOM) 和浏览器对象模型 (BOM) 。</p><h4 id="两种使用方式"><a href="#两种使用方式" class="headerlink" title="两种使用方式"></a>两种使用方式</h4><p>不同于其它编程语言，JavaScript 内嵌于浏览器中，许多主流浏览器都支持 JavaScript。打开 Chrome 浏览器，按 F12 或鼠标右键选择审查元素，就可以看到控制台，在控制台上就可以书写 JS 代码，例如你可以在控制台输入<code>console.log(&#39;hello world!&#39;);</code>就可以看到下方出现了一句熟悉<code>hello world!</code>。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/0076KlMqgy1fxkfe4vfmmj30ow04z3yv.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这是写 JS 代码最快速便捷的方式，但一般我们都是在编辑器中完整地完成整个项目，关于编辑器各人有各人的爱好，稍后会列出常用的几个编写 JS 代码的编辑器。</p><p>来到了编辑器中，我们新建一个后缀名为 .html 的文件，在里面写有关 JS 的代码，如果你连 HTML 都不认识，可以到 w3school 去在线学习基础的 HTML 知识。不出所料，一个基本的 html 文件的头应该是下面这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 这里是内容代码 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>JavaScript 使用 <script> 标签来嵌套代码，所有的 JS 相关的代码都放在里面，而 <script> 标签可以放在 <head></head> 中，也可放在 <body></body> 中，最好放在后者，因为浏览器解析时是从上至下解析这段代码，放在 <head> 中很容易因为解析慢而导致下方 <body> 中的内容未渲染出来，从而影响用户体验。</p><p><script> 有几个常用的属性，最常看到的就是 type 和 src 了，type 属性顾名思义，指定了属性含义，常用值是<code>text/javascript</code>，让人知道这里面写的都是 JavaScript 类型的标签代码；src 属性也是经常看见的，指定了一个外部的 href 链接，<strong>JavaScript 有两种引入方式，一种是直接在 <script></script> 标签里面写代码，另外一种就是创建一个后缀名为 .js 的文件，然后通过 src 链接进来使用。</p><p><script> 标签有一个 defer 属性，这个属性的作用是告诉浏览器等所有内容都解析完后再来执行这个脚本，也就是起到一个<strong>延迟执行脚本</strong>的作用。</p><p><script> 标签还有一个 async 属性，适用于外部引入的 .js 文件，作用是告诉浏览器不比等它执行，可以异步先去加载其它内容。</p><p>以上几个属性的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;××.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; async src=&quot;××.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 这里是内容代码 --&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h4 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h4><p> IE5.5 开始引入了文档模式这个概念，它会影响 css 内容的呈现，也会一定程度上影响到 JavaScript 的执行。文档模式只需要记住有混杂模式和标准模式两个，在混杂模式下，不同浏览器下执行的会有很大差异，因此不被人所推荐，一般都是用的标准模式，这个标准模式我们也很熟悉了，就是在 html 文件经常看到的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure></p><h4 id="标签"><a href="#标签" class="headerlink" title=" 标签"></a><noscript> 标签</h4><p>当遇到浏览器不支持 JavaScript 脚本或者脚本被禁用了怎么办？这时候可以用到 <noscript> 标签，它会在浏览器不支持 JS 脚本时候显示，而其他情况下不会有什么影响，所以为了用户体验，可以在代码里加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 这里是内容代码 --&gt;</span><br><span class="line">  &lt;noscript&gt;</span><br><span class="line">    &lt;p&gt;您的浏览器不支持 JavaScript ，请升级。&lt;/p&gt;</span><br><span class="line">  &lt;/noscript&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>这样，当遇到不支持 JS 时，这段文字就会显示出来，提醒用户升级或更换浏览器。</p><h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><p>最后，有许多可以编写 JavaScript 代码的软件。就我知道的有以下这些：</p><ul><li>WebStorm</li><li>PhpStorm</li><li>Sublime Text</li><li>VS code</li><li>Dreamweaver</li><li>HBuilder</li></ul><p>以上这几个软件基本都用过，现在在用 PhpStorm ，它跟 WebStorm 差不多，只不过多了对 php 文件的支持，很多人都是用的 WebStorm ，它代码提示等做得很好，页面看起来也还行，缺点应该是打开的时候挺慢，最重要的是，时不时地就过期需要去找注册码，当然，有条件的话还是付费支持正版的好，听说学生去申请可以有授权使用，不过太麻烦了懒得去弄。</p><p>欢迎批评指正！</p></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇讲 JavaScript 基础的文章，接下来会更新这个系列文章。&lt;/p&gt;
&lt;p&gt;JavaScript 诞生于 1995 年，至今已经有 20 几年了，在最新的 &lt;a href=&quot;https://2018.stateofjs.com&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.brightlam.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>你可能不知道的两个CSS属性</title>
    <link href="http://www.brightlam.top/2018/11/11/%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%A4%E4%B8%AACSS%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.brightlam.top/2018/11/11/你可能不知道的两个CSS属性/</id>
    <published>2018-11-11T09:48:43.000Z</published>
    <updated>2018-11-11T12:24:18.795Z</updated>
    
    <content type="html"><![CDATA[<p>今天是双十一，不知道各位剁手了没有，每年的狂欢节全民都在烧钱，在这里也温馨提醒大家：赶紧准备好土，该吃土了！话说自从知道马云和他的淘宝后，我拥有了一辆车——购物车，也终于认识到自己最大的不足——余额不足，所以这个双十一什么都没有买，听说今年仅 2 分 05 秒交易额就破百亿，一不小心错失参与一个百亿大项目，真是遗憾啊！</p><p>言归正传，这次要介绍的两个属性就是 css 中改变水平流向的<code>direction</code>属性和改变文本流的<code>writing-mode</code>属性，如果你没听过这两个属性，那正好学习下，没准以后会遇到它们。</p><h4 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h4><p>这个属性的兼容性特别好，所有浏览器包括 IE 都支持它，w3school 对该属性的介绍是<strong><em>规定文本的方向 / 书写方向。</em></strong>简单讲就是让文字从左向右还是从右向左显示，所以它有以下两个属性值</p><blockquote><p>direction: ltr | rtl ;</p></blockquote><p>默认值是 ltr，也就是 left-to-right，表示文字从左至右显示，很形象好记。它可以让图片或者按钮不按原本顺序显示，例如下面的例子<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-11-11/99451299.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div dir=&quot;rtl&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;elephant.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;boy.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>本来正常大象的图片 img 标签在男孩之前，但是因为我们设置了<code>dir=&quot;rtl&quot;</code>这是写在元素标签的缩写方法，也可以在 css 中写成<code>direction: rtl</code>，所以水平流向的顺序改变了，现在是从右往左，所以上面的图片显示男孩在大象图片的左边。通过这个例子现在知道 direction 的用处了，但是如果你把 div 里的内容换成文字，此时这个属性就不起作用了，你看不到什么反转的效果，这就需要介绍接下来的这个<code>unicode-bidi</code>属性</p><blockquote><p>unicode-bidi: bidi-override;</p></blockquote><p><code>direction: rtl</code>只能作用于图片或者按钮标签，而上面这个属性的作用就是对文字起作用的，多说无益，来看下实现效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div dir=&quot;rtl&quot;&gt;</span><br><span class="line">   我是 Light Lin，欢迎来到我的公众号</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>在浏览器的效果是这样<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-11-11/82537621.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>我们现在修改下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">           unicode-bidi: bidi-override;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;div dir=&quot;rtl&quot;&gt;</span><br><span class="line">   我是 Light Lin，欢迎来到我的公众号</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>运行出来后是这个效果<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-11-11/79925051.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>可以看到，有了<code>unicode-bidi: bidi-override;</code> 的作用，现在文字已经能改变水平流向了，关于该属性的更多详细信息可以去网上查阅。</p><h4 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h4><p>这个属性同样兼容性非常好，浏览器都支持它。MDN文档说它<strong><em>定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</em></strong>它的主要取值有以下几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 关键字</span><br><span class="line">writing-mode: horizontal-tb;</span><br><span class="line">writing-mode: vertical-rl;</span><br><span class="line">writing-mode: vertical-lr;</span><br><span class="line"></span><br><span class="line">// 全局属性值</span><br><span class="line">writing-mode: inherit;</span><br><span class="line">writing-mode: initial;</span><br><span class="line">writing-mode: unset;</span><br></pre></td></tr></table></figure></p><p><code>horizontal-tb</code> 默认值，表示了文本是水平方向（horizontal）的，从上至下堆叠（top-bottom）。<br><code>vertical-rl</code> 表示了文本是垂直方向的，从右往左堆叠。<br><code>vertical-lr</code> 表示了文本是垂直方向的，从左往右堆叠。<br>看看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;writing-mode: horizontal-tb&quot;&gt;</span><br><span class="line">   我是 Light Lin，欢迎&lt;br&gt;来到我的公众号和博客,&lt;br&gt;现在是默认显示</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>运行截图如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-11-11/4202854.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在改改代码，换下 css 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;writing-mode: vertical-rl&quot;&gt;</span><br><span class="line">    我是 Light Lin，欢迎&lt;br&gt;来到我的公众号和博客,&lt;br&gt;现在是从右往左显示</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>效果变成了下面这样<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-11-11/9494993.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在改下代码，看看又变了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;writing-mode: vertical-lr&quot;&gt;</span><br><span class="line">    我是 Light Lin，欢迎&lt;br&gt;来到我的公众号和博客,&lt;br&gt;现在是从左往右显示</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-11-11/36787191.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过上面这三个效果演示，应该就能理解<code>writing-mode</code>以及它的三个属性值的作用效果了，有没发现第二种从右往左实际上就是古诗词的排版方式？<br>值得注意的是，在 IE 浏览器里有另外的一套写法，如下</p><blockquote><p>writing-mode: lr-tb;        // 相当于默认值 horizontal-tb<br>writing-mode: tb-rl;      // 相当于 vertical-rl</p></blockquote><p>IE 浏览器里支持的不止上面这两个，多达 11 个，感兴趣的可以上网去查阅更多。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>css 有很多很多属性值，<code>writing-mode</code> 和 <code>direction</code> 平常可能比较少见，但是我们学习东西就是要广泛涉猎，虽然现在对它们的实际应用知道得较少，但说不定以后的某天就用到并解决问题了呢，所以先好好认识下他们吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是双十一，不知道各位剁手了没有，每年的狂欢节全民都在烧钱，在这里也温馨提醒大家：赶紧准备好土，该吃土了！话说自从知道马云和他的淘宝后，我拥有了一辆车——购物车，也终于认识到自己最大的不足——余额不足，所以这个双十一什么都没有买，听说今年仅 2 分 05 秒交易额就破百亿
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://www.brightlam.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS @font face 的使用</title>
    <link href="http://www.brightlam.top/2018/11/04/CSS-font-face-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.brightlam.top/2018/11/04/CSS-font-face-的使用/</id>
    <published>2018-11-04T11:15:17.000Z</published>
    <updated>2018-11-04T11:16:01.315Z</updated>
    
    <content type="html"><![CDATA[<p>在网页开发中，可以在 CSS 中设置<code>font-family</code>来指定对应的字体，通常我们都是用微软雅黑。有时，如果对电脑上有的字体都不满意怎么办？我们可以通过自定义字体，自己引入字体文件，来使用它。<code>@font face</code>就是做这种工作的，它可以让你在<code>font-family</code>的值上输入自己定义的字体名称，你甚至还能将「微软雅黑」这个名称替换成别的字体。</p><h4 id="CSS字体家族"><a href="#CSS字体家族" class="headerlink" title="CSS字体家族"></a>CSS字体家族</h4><p>在开始之前，简单介绍下 css 的字体家族，只要涉及到文字都离不开它们，它们分别是<code>fonr-family</code>，<code>font-size</code>，<code>font-weight</code>，<code>font-style</code>，<code>font-variant</code>以及<code>font</code>。</p><ol><li><p><code>font-family</code> 应该很熟悉，定义文字使用什么字体，常见的是微软雅黑，宋体以及英文字体 Arial。字体又分为衬线字体和无衬线字体，区别是两种字体的装饰和粗细不同，微软雅黑属于无衬线字体。为了各个浏览器的兼容性，尽量写成英文名称比较好，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font-family: &apos;Microsoft Yahei&apos;，sans-serif;</span><br><span class="line">font-family: &apos;simsun&apos;;  // 宋体</span><br><span class="line">font-family: &apos;Arial&apos;;</span><br></pre></td></tr></table></figure></li><li><p><code>font-weight</code>  定义文字的粗细程度，也就是字重。支持的属性值有很多，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fonr-weight: normal;</span><br><span class="line">font-weight: bold;   // 粗体</span><br><span class="line">font-weight: lighter;   // 相对父级而言</span><br><span class="line">font-weight: bolder;   // 相对父级而言</span><br><span class="line">/* font-weight 还支持数值，分为三档 */</span><br><span class="line">font-weight: 400    // 等同于 normal，在 400 之前的数值很轻，数值越小越轻越细</span><br><span class="line">font-weight: 700    // 等同 bold，500 和 600 两个数值介于之间</span><br><span class="line">font-weight: 900    // 最大值，字体最粗</span><br></pre></td></tr></table></figure></li></ol><p>这里有个很值得我们注意的点，就是<strong>我们经常在使用中发现无论设置 100、200、400 都没什么效果，好像只有 normal 和 bold 两个值有用，那是因为我们平常使用的字体通常是微软雅黑，它只有<code>normal</code>和<code>bold</code>两个值，所以你设置其它的数值没什么效果，实际上它是有用的。</strong></p><ol start="3"><li><code>font-size</code> 这个很熟悉了，定义字体的大小，你想设置多少 px 都行，或者使用其它单位 em，rem，vh 等。</li><li><p><code>font-style</code> 定义文字的样式。有如下属性值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font-style: normal;   </span><br><span class="line">font-style: italic;    // 文字使用其 font-family 对应的倾斜字体</span><br><span class="line">font-style: oblique;  // 单纯地让文字倾斜</span><br></pre></td></tr></table></figure></li><li><p><code>font-variant</code> 一个用处不大的属性，有两个值<code>normal</code>和<code>small-caps</code>,设置<code>font-variant: small-caps</code>可以让字符跟小写字母一样大小，但样式是大写字母</p></li><li><code>font</code> 上面这些样式的缩写，例如可以让文字大小和行高缩写为<code>font: 24px/32px &#39;Microsoft Yahei&#39;</code><h4 id="font-face-语法"><a href="#font-face-语法" class="headerlink" title="@font face 语法"></a>@font face 语法</h4>实际上，@font face 这个名称已经很类似 css 的变量了，根据 MDN 文档，@font face 有以下几个主要属性：</li></ol><ul><li><code>font-family</code>: 引入字体文件的取值名称，可以是 ‘$’ 或空格，该名字将被用于 font 或 font-family 属性。</li><li><code>src</code>: 字体文件地址，用 <code>local()</code> 表示当前系统内的字体，用 <code>url()</code> 表示外链的字体，通常后者用得较多</li><li><code>font-weight</code>: 字重，这个属性的用处在于，比如你引入了同一个字体，但是设置了不同的 <code>font-weight</code> ，可以在不同的情况采用不同的字重</li><li><code>font-style</code>: 和 <code>font-weight</code> 一样，当设置了不同的值，就可以决定在这个字体下是采用正常样式还是倾斜字体，因为 <code>font-style: italic</code> 让字体变斜体</li><li><code>unicode-range</code>: 使用特定的 unicode 字体范围</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>HTML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;normal&quot;&gt;正常的微软雅黑文本&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;test&quot;&gt;这是一段自定义字体文本&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &quot;myfont&quot;;</span><br><span class="line">  src: url(&quot;http://developer.mozilla.org/@api/deki/files/2934/=VeraSeBd.ttf&quot;);</span><br><span class="line">&#125;</span><br><span class="line">.test&#123;</span><br><span class="line">  font-family: &quot;myfont&quot;,serif;</span><br><span class="line">&#125;</span><br><span class="line">.normal&#123;</span><br><span class="line">  font-family: &quot;Microsoft YaHei&quot;,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以自己运行看看效果，两段文字的字体是不同的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>css 有关文字这块有许多属性，除上面提到的一些基本属性外，其实还有很多，例如<code>letter-spacing</code>控制字间距，<code>white-space</code>定义文字遇到空格如何换行，还有<code>word-break</code>，<code>text-indent</code>等等，这些属性平常见得不多，但是在一些情况下很有用。最后还有对<code>@font face</code>的认识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在网页开发中，可以在 CSS 中设置&lt;code&gt;font-family&lt;/code&gt;来指定对应的字体，通常我们都是用微软雅黑。有时，如果对电脑上有的字体都不满意怎么办？我们可以通过自定义字体，自己引入字体文件，来使用它。&lt;code&gt;@font face&lt;/code&gt;就是做这
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://www.brightlam.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css 实现元素水平垂直居中的几种方法</title>
    <link href="http://www.brightlam.top/2018/10/28/css-%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://www.brightlam.top/2018/10/28/css-实现元素水平垂直居中的几种方法/</id>
    <published>2018-10-28T09:38:56.000Z</published>
    <updated>2018-10-28T09:40:18.774Z</updated>
    
    <content type="html"><![CDATA[<p>在做网页的时候经常会需要让某一个元素水平垂直居中，而要实现水平垂直居中有很多种方法，不知道你们有没遇到这种情况：方法倒是知道，甚至还知道许多种，可一到真正用到的时候，却突然在努力地回想，这或许就是人们经常说的「脑子短路」，所以，这篇文章和大家一起来温故而知新，梳理一下常见的几种元素水平垂直居中的方法，以后突然短路了，就翻出来看一看，而且万一以后面试就问到了，那就更好不过了。</p><h4 id="div-元素的水平垂直居中"><a href="#div-元素的水平垂直居中" class="headerlink" title="div 元素的水平垂直居中"></a>div 元素的水平垂直居中</h4><p>让一个 div 元素水平垂直居中，有很多种方法。</p><ol><li>最先想到的就是使用<strong>绝对定位 + margin: auto</strong>的实现方式，这也是最靠谱的一种实现方式，兼容性还不错。为什么说它靠谱呢？因为它利用了 css 流体的特性，即页面的默认文档流是自上而下，自左向右。我们先来看下它的实现代码：<h6 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><h6 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.dialog&#123;</span><br><span class="line">   width: 500px;</span><br><span class="line">   height: 500px;</span><br><span class="line">   background-color: #cccccc;</span><br><span class="line">   position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">   width: 200px;</span><br><span class="line">   height: 200px;</span><br><span class="line">   background-color: #e8491d;</span><br><span class="line">   position: absolute;</span><br><span class="line">   left: 0;</span><br><span class="line">   top: 0;</span><br><span class="line">   right: 0;</span><br><span class="line">   bottom: 0;</span><br><span class="line">   margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-28/96507186.jpg" alt="中间的色块已居中" title="">                </div>                <div class="image-caption">中间的色块已居中</div>            </figure><p>此方法对父元素使用相对定位，然后子元素使用绝对定位，这样子元素将相对父元素进行定位，接着设置各个方向的 left/top/right/bottom 为 0，再设置 margin: auto ，然后就非常巧妙了：<strong>把它的各个定位值置为 0 后，剩下的空间交由 margin 去自动分配，由于流特性，它将均匀评分剩下的空间，于是便水平垂直地居中了。</strong></p><p>上面这种方法推荐使用，除此之外还有其它方法，相信很多人也经常看到，这里也列举下，有些都差不多，只是属性的不同使用。</p><ol start="2"><li><strong>第二种是已知宽度，margin 负值的方法</strong>，代码如下：<h6 id="HTML代码-1"><a href="#HTML代码-1" class="headerlink" title="HTML代码"></a>HTML代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><h6 id="CSS代码-1"><a href="#CSS代码-1" class="headerlink" title="CSS代码"></a>CSS代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.dialog&#123;</span><br><span class="line">   width: 500px;</span><br><span class="line">   height: 500px;</span><br><span class="line">   background-color: #cccccc;</span><br><span class="line">   position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">   width: 200px;</span><br><span class="line">   height: 200px;</span><br><span class="line">   background-color: #e8491d;</span><br><span class="line">   position: absolute;</span><br><span class="line">   left: 50%;</span><br><span class="line">   top: 50%;</span><br><span class="line">   margin-left: -100px;</span><br><span class="line">   margin-top: -100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果跟上面的是一样的，有种像把人往右和往下拽，然后有拉回来对准的感觉，可以试试。</p><ol start="3"><li><strong>第三种跟第一种差不多，只不过把 margin 换成了 transform 属性</strong>，代码如下：<h6 id="HTML代码-2"><a href="#HTML代码-2" class="headerlink" title="HTML代码"></a>HTML代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><h6 id="CSS代码-2"><a href="#CSS代码-2" class="headerlink" title="CSS代码"></a>CSS代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.dialog&#123;</span><br><span class="line">   width: 500px;</span><br><span class="line">   height: 500px;</span><br><span class="line">   background-color: #cccccc;</span><br><span class="line">   position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">   width: 200px;</span><br><span class="line">   height: 200px;</span><br><span class="line">   background-color: #e8491d;</span><br><span class="line">   position: absolute;</span><br><span class="line">   left: 50%;</span><br><span class="line">   top: 50%;</span><br><span class="line">   transform: translate(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果依旧是一样的。有没发现代码很相似，只改了一句<code>transform: translate(-50%,-50%);</code>实际上这样就不用去知道已知元素的宽度了，直接用 transform 的 translate 来移动。</p><ol start="4"><li><strong>第四种是 flex 布局</strong>，关于 flex 布局之前的博客文章也有做过简单的介绍，这里就不再赘述，忘记了的戳这篇 <a href="https://www.brightlam.top/2018/05/27/CSS%E5%B8%83%E5%B1%80%E4%B9%8B-flex-%E5%B8%83%E5%B1%80/">CSS布局之 flex 布局</a> ，如何实现呢，代码如下：<h6 id="HTML代码-3"><a href="#HTML代码-3" class="headerlink" title="HTML代码"></a>HTML代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><h6 id="CSS代码-3"><a href="#CSS代码-3" class="headerlink" title="CSS代码"></a>CSS代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.dialog&#123;</span><br><span class="line">   width: 500px;</span><br><span class="line">   height: 500px;</span><br><span class="line">   background-color: #cccccc;</span><br><span class="line">   display: flex;</span><br><span class="line">   justify-content: center;</span><br><span class="line">   align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">   width: 200px;</span><br><span class="line">   height: 200px;</span><br><span class="line">   background-color: #e8491d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果同见最上面的那张图，这次的代码不一样了，不一样在哪里呢？flex 布局针对的是父元素，可以看到，在父元素的 div 中写的居中代码，子元素不需要写什么，躺着居中就可以了，不过个人觉得 flex 布局真正用到的时候不止是实现这么简单的布局，它可以实现用更简洁的代码实现更多常见的布局。</p><ol start="5"><li><strong>第五种是使用 table 布局，这种不推荐使用</strong>，主要上面有那么多种方法，没必要用到这种，具体原理是给父元素设置<code>display:table</code>，子元素设置<code>display:table-cell</code>，table-cell 相当于表格中的 <td> ，再结合<code>vertical-align: middle</code> 即可。<h6 id="HTML代码-4"><a href="#HTML代码-4" class="headerlink" title="HTML代码"></a>HTML代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;text&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></td></li></ol><h6 id="CSS代码-4"><a href="#CSS代码-4" class="headerlink" title="CSS代码"></a>CSS代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.dialog&#123;</span><br><span class="line">   width: 500px;</span><br><span class="line">   height: 500px;</span><br><span class="line">   background-color: #cccccc;</span><br><span class="line">   display: table;</span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">   background-color: #e8491d;</span><br><span class="line">   display: table-cell;</span><br><span class="line">   text-align: center;</span><br><span class="line">   vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.son&#123;</span><br><span class="line">   background-color: #d0d6d9;</span><br><span class="line">   display: inline-block;</span><br><span class="line">   width: 200px;</span><br><span class="line">   height: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，这个效果跟上面那张有些许不一样，仔细瞧瞧代码跟背景色。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-28/85289493.jpg" alt="如图" title="">                </div>                <div class="image-caption">如图</div>            </figure></p><h4 id="内联文字的水平垂直居中"><a href="#内联文字的水平垂直居中" class="headerlink" title="内联文字的水平垂直居中"></a>内联文字的水平垂直居中</h4><p>上面介绍的几种方法大多更偏向布局之类的水平垂直居中，接下来介绍一种让文字水平居中的方法。我们都知道，让文字水平居中，只需要一行 <code>text-align: center</code> 就可以搞定，那垂直居中呢？我从网上找到了解决方法，可以试试下面这样。</p><h6 id="HTML代码-5"><a href="#HTML代码-5" class="headerlink" title="HTML代码"></a>HTML代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        这个公众号是一个值得关注的号，不定期会分享一些有关前端类的文章，推荐大家关注，同时点赞转发分享到朋友圈，让更多的人看到。</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h6 id="CSS代码-5"><a href="#CSS代码-5" class="headerlink" title="CSS代码"></a>CSS代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">   width: 300px;</span><br><span class="line">   line-height: 220px;</span><br><span class="line">   background-color: #f4f4f4;</span><br><span class="line">   margin: auto;</span><br><span class="line">   font-family: &apos;Microsoft YaHei&apos;,sans-serif;</span><br><span class="line">   font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">   display: inline-block;</span><br><span class="line">   ine-height: 20px;</span><br><span class="line">   margin: 0 20px;</span><br><span class="line">   text-align: center;</span><br><span class="line">   vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="效果如下-1"><a href="#效果如下-1" class="headerlink" title="效果如下"></a>效果如下</h6><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-28/24489030.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>实现垂直居中的方法有很多，每一种都有各自的实现路径，但是兼容性却是各不相同，感兴趣的可以自己去测试下兼容。如果你有耐心从头看到这里，已经是很不错了，不过，看完可以敲一遍代码过一遍，可能记忆会来得更深刻些，希望这篇文章对你有帮助！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在做网页的时候经常会需要让某一个元素水平垂直居中，而要实现水平垂直居中有很多种方法，不知道你们有没遇到这种情况：方法倒是知道，甚至还知道许多种，可一到真正用到的时候，却突然在努力地回想，这或许就是人们经常说的「脑子短路」，所以，这篇文章和大家一起来温故而知新，梳理一下常见的
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://www.brightlam.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>一些有趣的 CSS demo</title>
    <link href="http://www.brightlam.top/2018/10/21/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84-CSS-demo/"/>
    <id>http://www.brightlam.top/2018/10/21/一些有趣的-CSS-demo/</id>
    <published>2018-10-21T07:43:57.000Z</published>
    <updated>2018-10-21T07:44:50.684Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 世界博大精深，写过 css 的都知道，很多时候总是出现一些莫民奇妙的状况，你写的代码最后实现出来跟你预想的完全不同，特别是有时在那里悲催地找原因找了一下午，最后才发现是某个变量某个字符写错而导致，真 skr 惨。今天介绍几个有趣的 css 效果，是从书上看来的，有些可能你以前都没想到这么实现过，可以学习下作者的思路，对你以后写出更好的 css 代码会有帮助。</p><ol><li><strong>显示/收缩效果</strong><br>这个效果比较常用到，具体效果如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-21/76874491.jpg" alt="gif动图" title="">                </div>                <div class="image-caption">gif动图</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* HTML 代码 */</span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; id=&quot;check&quot; style=&quot;display:none&quot;&gt;</span><br><span class="line">  &lt;p&gt;HTC 计划在 10 月 22 日推出区块链智能手机&lt;/p&gt;</span><br><span class="line">  &lt;div class=&quot;element&quot;&gt;</span><br><span class="line">    &lt;p&gt;该公司一个有趣的发展方向就是决定推出名为 Exodus 的区块链智能手机 ... 该手机制造商在照片分享应用 Instagram 上为这个即将推出的区块链智能手机建造了一个新的页面&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;label for=&quot;check&quot; class=&quot;check-in&quot;&gt;更多↓&lt;/label&gt;</span><br><span class="line">  &lt;label for=&quot;check&quot; class=&quot;check-out&quot;&gt;收起↑&lt;/label&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* CSS 代码 */</span><br><span class="line">.demo&#123;width: 200px;padding-left:100px;padding-top: 10px;&#125;</span><br><span class="line">.element&#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  padding-top: 15px;</span><br><span class="line">  max-height: 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  transition: max-height .25s;</span><br><span class="line">&#125;</span><br><span class="line">:checked ~ .element&#123;</span><br><span class="line">  max-height: 666px;</span><br><span class="line">&#125;</span><br><span class="line">:checked ~ .check-out&#123;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br><span class="line">:checked ~ .check-in&#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">.check-in,.check-out&#123;</span><br><span class="line">  color: blue;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  margin-top: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.check-out&#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>正在加载中动画</strong><br>在加载网页时经常会用到这个动画，为了缓解图片文字资源未加载时用来过渡，极大地增强了用户体验，效果大致如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-21/45529891.jpg" alt="正在加载中" title="">                </div>                <div class="image-caption">正在加载中</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* HTML 代码 */</span><br><span class="line">正在加载中&lt;dot&gt;...&lt;/dot&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* CSS 代码 */</span><br><span class="line">dot&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  height: 1em;</span><br><span class="line">  line-height: 1;</span><br><span class="line">  text-align: left;</span><br><span class="line">  vertical-align: -.25em;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">dot::before&#123;</span><br><span class="line">  display: block;</span><br><span class="line">  content: &apos;...\A..\A.&apos;;</span><br><span class="line">  white-space: pre-wrap;</span><br><span class="line">  animation: dot 2s infinite step-start both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes dot&#123;</span><br><span class="line">  33% &#123;</span><br><span class="line">    transform: translateY(-2em);</span><br><span class="line">  &#125;</span><br><span class="line">  66% &#123;</span><br><span class="line">    transform: translateY(-1em);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>css 自行实现小图标</strong><br>在日常开发的过程中经常会用到小图标，除了可以去 <a href="http://www.iconfont.cn/" target="_blank" rel="noopener">阿里图标</a> 下载之外，一些较简单的图标可以自己用 css 实现，方法是利用 border 和 background 属性，效果如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-21/99543278.jpg" alt="宽高扩大了 10 倍显示" title="">                </div>                <div class="image-caption">宽高扩大了 10 倍显示</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* HTML 代码 */</span><br><span class="line">&lt;i class=&quot;icon-menu&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=&quot;icon-dot&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* CSS 代码 */</span><br><span class="line">.icon-menu&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 140px; height: 10px;</span><br><span class="line">  padding: 35px 0;</span><br><span class="line">  border-top: 10px solid;</span><br><span class="line">  border-bottom: 10px solid;</span><br><span class="line">  background-color: currentColor;</span><br><span class="line">  background-clip: content-box;</span><br><span class="line">  margin: 50px 0 0 100px;</span><br><span class="line">&#125;</span><br><span class="line">.icon-dot&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 100px; height: 100px;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  border: 10px solid;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  background-color: currentColor;</span><br><span class="line">  background-clip: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>border 实现边框</strong><br>很多时候会遇到需要有一个上传按钮，点击按钮后上传文件，如下面这样的效果：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-21/17392425.jpg" alt="按钮" title="">                </div>                <div class="image-caption">按钮</div>            </figure>此时可以用 a 标签来承载，在通过 border 属性来定义虚线框，利用伪元素来定位，使中间的 + 号能水平垂直居中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* HTML 代码 */</span><br><span class="line">&lt;a href class=&quot;add&quot; title=&quot;继续上传&quot;&gt;添加图片&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* css 代码 */</span><br><span class="line">.add&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 76px; height: 76px;</span><br><span class="line">  color: #ccc;</span><br><span class="line">  border: 2px dashed;</span><br><span class="line">  text-indent: -12em;</span><br><span class="line">  transition: color .25s;</span><br><span class="line">  position: relative;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  margin: 50px 100px;</span><br><span class="line">&#125;</span><br><span class="line">.add:before, .add:after&#123;</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">&#125;</span><br><span class="line">.add:hover&#123;</span><br><span class="line">  color: #34538b;</span><br><span class="line">&#125;</span><br><span class="line">.add::before&#123;</span><br><span class="line">  width: 20px;</span><br><span class="line">  border-top: 4px solid;</span><br><span class="line">  margin: -2px 0 0 -10px;</span><br><span class="line">&#125;</span><br><span class="line">.add::after&#123;</span><br><span class="line">  height: 20px;</span><br><span class="line">  border-left: 4px solid;</span><br><span class="line">  margin: -10px 0 0 -2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>纯 css 实现自适应的弹框</strong><br>弹框，也就是 dialog ，经常也是在网页中看到，例如有些网页点击登录注册时就会跳出一个弹框来显示登录注册页面，而下面的效果是使用 css 完成的，并且可以自适应，无论窗口的大小，始终能保持水平垂直居中，很好的一个实现方法。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-10-21/80794477.jpg" alt="水平垂直居中弹框" title="">                </div>                <div class="image-caption">水平垂直居中弹框</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* HTML 代码 */</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">           我是内容</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* css 代码 */</span><br><span class="line">.container&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top:0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    background: rgba(0,0,0,.5);</span><br><span class="line">    text-align: center;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    z-index: 99;</span><br><span class="line">&#125;</span><br><span class="line">.container:after&#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    height: 100%;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.dialog&#123;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    border-radius: 6px;</span><br><span class="line">    text-align: left;</span><br><span class="line">    white-space: normal;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 250px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料<br>张鑫旭——《 css 世界》</p></blockquote><p>PS：最近 Chrome 70 正式发布了，不得不说，谷歌这波更新的真快，不过我下载体验了一下，整体跟 69 版本没什么大的变化，至于新增的那些画中画、拖拽 API 什么的目前也没用得上什么，感兴趣的直接去 <a href="https://www.google.com/intl/zh-CN_ALL/chrome/" target="_blank" rel="noopener">官网</a> 下载最新的版本就好，目前只有桌面版，移动端版本的还要等些时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS 世界博大精深，写过 css 的都知道，很多时候总是出现一些莫民奇妙的状况，你写的代码最后实现出来跟你预想的完全不同，特别是有时在那里悲催地找原因找了一下午，最后才发现是某个变量某个字符写错而导致，真 skr 惨。今天介绍几个有趣的 css 效果，是从书上看来的，有些
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://www.brightlam.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>python 学习笔记（一）</title>
    <link href="http://www.brightlam.top/2018/10/10/python-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.brightlam.top/2018/10/10/python-学习笔记（一）/</id>
    <published>2018-10-10T09:38:11.000Z</published>
    <updated>2018-10-10T09:38:59.306Z</updated>
    
    <content type="html"><![CDATA[<p>这学期的课程有需要学到 python，国庆利用几天时间刷了一下题，在刷的过程中遇到许多问题，都是一些零零碎碎的知识点，记录一下。</p><ol><li><p>如何在控制台接收一个输入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = input()</span><br><span class="line">x = int(input())   // 输入的数必须为整数，同理还有 str()，float()</span><br><span class="line">x,y = map(int,input().split())   // 同时输入两个整数，用空格隔开</span><br></pre></td></tr></table></figure></li><li><p>如何计算长度? 用 <code>len()</code> 函数，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;string&apos;,5,1,&apos;hello&apos;]</span><br><span class="line">print(len(a))    // 4</span><br></pre></td></tr></table></figure></li><li><p>三角函数，引入 <code>math</code> 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">C = math.acos((a**2 + b**2 - c**2)/(2*a*b))*180/math.pi   // 利用 acos 函数求三角形一边的对角</span><br></pre></td></tr></table></figure></li><li><p>字符串打印输出格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;%.2f&apos;%a)  // 输出的 a 保留两位小数</span><br></pre></td></tr></table></figure></li><li><p>for 循环书写格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = [1,2,3,4,5,6,7]</span><br><span class="line">for i in arr</span><br><span class="line">  print(i,end=&quot;&quot;)    // 1234567, end=&quot;&quot; 表示不换行</span><br></pre></td></tr></table></figure></li><li><p>range 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个整数列表，一般用在 for 循环中</span><br><span class="line"># 在 python 中，用 ‘#’ 注释</span><br><span class="line">range(0,5)    # 0,1,2,3,4</span><br><span class="line">range(0,10,2) # 0,2,4,6,8  间隔为 2</span><br></pre></td></tr></table></figure></li><li><p>打印一个右对齐直角三角形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    *</span><br><span class="line">  ***</span><br><span class="line">*****</span><br><span class="line">*/</span><br><span class="line">for i in range(0,5,2):</span><br><span class="line">    for j in range(0,4-i):</span><br><span class="line">        print(&quot; &quot;,end=&quot;&quot;)</span><br><span class="line">    for k in range(0,1+i):</span><br><span class="line">        print(&quot;*&quot;,end=&quot;&quot;)</span><br><span class="line">    print(&quot;&quot;)</span><br></pre></td></tr></table></figure></li><li><p>查找某个数，find() 和 index()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.index(&apos;a&apos;) # 查找字符串 str 是否存在 a,查到返回位置，否则抛出异常</span><br><span class="line">str.find(&apos;a&apos;)   # 与 index 一样,不过查不到返回的是 -1</span><br></pre></td></tr></table></figure></li><li><p>判断字母是大写，用 <code>isupper()</code>;判断是否小写，用 <code>islower()</code></p></li><li><p>求绝对值、自然对数以及平方根</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">abs(x)   # 求 x 的绝对值</span><br><span class="line">math.sqrt(x) # 对 x 进行开平方根</span><br><span class="line">math.log(4,2)  # 以 2 为底 4 的对数，第二个参数为空则默认以 e 为底，返回的是浮点数</span><br></pre></td></tr></table></figure></li><li><p>转义字符 \</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Please write letter &apos;A&apos;.&quot;)   # Please write letter &apos;A&apos;.</span><br><span class="line">print(&quot;The path is \&quot;D:\study\computer\\\&quot;.&quot;)   # The path is &quot;D:\study\computer\&quot;.</span><br></pre></td></tr></table></figure></li><li><p>用 <code>strip()</code> 去字符串空格，用 <code>isalpha()</code> 判断是否由字母组成，用 <code>isdigit()</code> 判断字符串是否都是数字</p></li><li><p>列表(相当于其它语言的数组)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [5,8,7,2,4]   # 定义列表 arr</span><br><span class="line">list() # 将一组数转换为列表</span><br><span class="line">del l[2]  # 删除列表中第三个数</span><br><span class="line">&apos; &apos;.join(列表名称)  # 去除列表的 [] ,转为空格隔开的字符串</span><br><span class="line">append()   # 在列表后添加元素</span><br><span class="line">arr = [x for x in arr if x != 2]   # 把列表值等于 2 的删除</span><br></pre></td></tr></table></figure></li><li><p>如果一个列表包含数字，不能直接转换为字符串，需要用 <code>&#39;%s&#39;</code> 格式转为字符串</p></li><li><p>列表的排序函数 sort()  和 sorted()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = [5,1,3,8,7,6]</span><br><span class="line">sorted(arr)</span><br><span class="line">arr.sort()</span><br><span class="line">print(arr)</span><br><span class="line"># [1, 3, 5, 6, 7, 8],区别：sort 是在原位排序列表，而 sorted 是产生一个新列表</span><br></pre></td></tr></table></figure></li><li><p>算术运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ - * /  // 分别代表加、减、乘、除</span><br><span class="line">% 取模  // 例如 361 % 10 结果为 1</span><br><span class="line">// 整除,向下取整   例如 9 // 2 结果为 4,  302 // 100 为 3</span><br><span class="line">**  n 次方  // 例如 a ** 2 表示 a 的平方</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这学期的课程有需要学到 python，国庆利用几天时间刷了一下题，在刷的过程中遇到许多问题，都是一些零零碎碎的知识点，记录一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何在控制台接收一个输入数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="python" scheme="http://www.brightlam.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度、空间复杂度以及分析方法</title>
    <link href="http://www.brightlam.top/2018/10/02/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <id>http://www.brightlam.top/2018/10/02/时间复杂度、空间复杂度以及分析方法/</id>
    <published>2018-10-02T09:40:18.000Z</published>
    <updated>2018-10-02T09:41:15.803Z</updated>
    
    <content type="html"><![CDATA[<p>在学习数据结构与算法的时候，总不免提到时间复杂度以及空间复杂度这两个概念，以及每次对所写代码进行的复杂度分析等，最近这段时间学习数据结构与算法时对这两个概念的理解比之前好些了，这篇文章记录下最基础的概念以及常见的时间/空间复杂度。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>先说下时间复杂度：<strong>描述一个算法执行时间与数据规模的增长关系</strong>，通常用 T(n) = O(f(n)) 来表示，这里的 n 表示数据的规模，f(n) 每行代码执行的次数总和。这里重点在于<strong>增长关系</strong>这几个字，一个算法的时间复杂度，通常只需要考虑 n 的增长规模，这里的 n 指的是每段代码的执行次数，所以时间复杂度大多都只看循环、递归来分析，而与那些常数、系数等无关。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function calc(n)&#123;</span><br><span class="line">  var sum = 0;</span><br><span class="line">  var i = 1;</span><br><span class="line">  for (; i &lt; n; i++ )&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码可以累加从 0 到 n 的和，我们这样对它进行分析：第 2、3 行代码需要执行一次，第 4、5 行需要执行 n 次，总的就是 2n 次，所以它的时间复杂度为 O(2n + 2)，但是因为系数、常数这些对 n 的增长规模没有影响，不需要考虑，可以忽略，如果是 n² 那就有影响了，都已经到平方阶了。所以这样看其时间复杂度为 O(n) 。<br>类似于这样的代码不用分析，时间复杂度都是常量级的 O(1)，因为它并没有体现出 n 的增长规模关系，就算代码在多时间复杂度也是一样的，换句话说，一段代码里没有循环啊、递归等语句，通常时间复杂度都是 O(1) 。再下面在看下这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function(n)&#123;</span><br><span class="line">  var sum = 0;</span><br><span class="line">  for(var i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">    for(var j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">      sum += i*j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像这种嵌套了两层 for 循环的代码，两行代码分别执行了 n 遍，并且是嵌套，时间复杂度就是 O(n²)。</p><h4 id="分析小技巧"><a href="#分析小技巧" class="headerlink" title="分析小技巧"></a>分析小技巧</h4><ol><li>如果没有循环或递归，都是常量级的代码，时间复杂度就是 O(1)</li><li>只关注循环次数最多的一段代码，它的量级就可作为整段代码的时间复杂度</li><li>如果是 for 循环嵌套的代码，采用乘法计算其内外复杂度；如果是一个函数里有多段代码，则分析出每一段代码的时间复杂度，在将它们相加，最后去掉系数以及常数，取最大量级的作为整段代码的时间复杂度。例如，O(2n²+n+2) 则简化为 O(n²)<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>类比时间复杂度，空间复杂度的概念在几个字上不一样，完整表述为:<strong>描述一个算法占用空间与数据规模的增长关系</strong>。如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function print(n)&#123;</span><br><span class="line">  var i = 0;</span><br><span class="line">  var arr = new Array(n);</span><br><span class="line">  for(i;i&lt;n;i++)&#123;</span><br><span class="line">    arr[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>同样的，第二行代码申请了存储空间 i，但它是常量阶的，跟数据的增长规模没有关系，所以不用理；第三行代码申请了一个容量为 n 的数组，剩下的代码都没有涉及到占用空间了，所以整段代码的空间复杂度为 O(n) 。常见的空间复杂度不多，就 O(1)、O(n)、O(n²) 这几个，其余对数阶的那些一般很少应用到。</p><h4 id="常见的复杂度"><a href="#常见的复杂度" class="headerlink" title="常见的复杂度"></a>常见的复杂度</h4><p>常见的复杂度从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n²)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习数据结构与算法的时候，总不免提到时间复杂度以及空间复杂度这两个概念，以及每次对所写代码进行的复杂度分析等，最近这段时间学习数据结构与算法时对这两个概念的理解比之前好些了，这篇文章记录下最基础的概念以及常见的时间/空间复杂度。&lt;/p&gt;
&lt;h4 id=&quot;时间复杂度&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.brightlam.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法系列之插入排序</title>
    <link href="http://www.brightlam.top/2018/09/25/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.brightlam.top/2018/09/25/算法系列之插入排序/</id>
    <published>2018-09-25T02:33:14.000Z</published>
    <updated>2018-09-25T02:34:24.097Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个程序员，一些基本的排序算法是必须要掌握的。以前人们总觉得算法是后端程序员去学的，前端只需要专注于网页的美观以及 JS 的基本逻辑交互就行，然而，近几年随着前端行业的发展，前端越来越注重逻辑交互，如果你还像很久之前那样只知道用 HTML + CSS 去构建网页，那就落伍了。如今，前端程序员也需要对算法有一定的了解，不说别的，多掌握点东西总是好的。今天的文章介绍的是排序算法中的<strong>插入排序</strong>。</p><h4 id="什么是排序"><a href="#什么是排序" class="headerlink" title="什么是排序"></a>什么是排序</h4><p>维基百科中这样说明：一种能将一串数据依照特定排序方式进行排列的一种算法。生活中也有很多排序的例子：超市购物排队，学生成绩排序，班级座位排序等。排序可以分为内部排序还有外部排序。内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列；外部排序能够处理极大量数据的排序算法，通常需要结合外存储器（硬盘）使用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p81yl6eww.bkt.clouddn.com/18-9-10/64285389.jpg" alt="各种排序归类" title="">                </div>                <div class="image-caption">各种排序归类</div>            </figure></p><h4 id="什么是插入排序"><a href="#什么是插入排序" class="headerlink" title="什么是插入排序"></a>什么是插入排序</h4><p>插入排序的原理跟扑克牌差不多，打过扑克牌的都知道，我们拿到一副牌，会按照大小将这些牌进行排列，每拿一张牌，就将它与前面的牌进行比较，比那张牌大又比那张牌小，那么就在这个位置将其插入，然后继续拿其它的牌排列，将它们都插入到符合它们顺序的位置上，这就是插入排序的原理：<strong>每次将待排序的元素抽出来，与前面的元素进行比较，如果小于则交换位置，直到大于某个元素则排在这个元素之后，插入排序每次都需要由后向前对元素进行一一比较</strong>。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>以下是插入排序的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function insertSort(arr)&#123;</span><br><span class="line">   if(Object.prototype.toString.call(arr).slice(8,-1)</span><br><span class="line">     === &apos;Array&apos;)&#123;</span><br><span class="line">     console.time(&apos;插入排序耗时: &apos;);</span><br><span class="line">     for(var i=1;i&lt;arr.length;i++)&#123;</span><br><span class="line">       var key = arr[i];</span><br><span class="line">       var j = i - 1;</span><br><span class="line">       while(j&gt;=0 &amp;&amp; arr[j] &gt; key)&#123;</span><br><span class="line">         arr[j + 1] = arr[j];</span><br><span class="line">         j--;</span><br><span class="line">       &#125;</span><br><span class="line">       arr[j + 1] = key;</span><br><span class="line">     &#125;</span><br><span class="line">     console.timeEnd(&apos;插入排序耗时: &apos;);</span><br><span class="line">     return arr;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     return &apos;this is not an Array&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];</span><br><span class="line">console.log(insertSort(arr));</span><br><span class="line">// 插入排序耗时: : 0.255126953125ms</span><br><span class="line">// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span><br></pre></td></tr></table></figure></p><p>第一行中的<code>Object.prototype.toString.call(arr)</code>返回的是<code>[object Array]</code>，然后我们通过 JS 中的<code>slice()</code>方法就可以判断传入的是不是一个数组，如果不是，则返回提示文字。代码中使用了一个临时变量 key 来存储需要比较的元素，通过后一个元素不断地与前一个元素进行比较，如果大了，就赋值交换，然后坐标 j– ；最后将 key 里存储的值放到正确的位置上。</p><h4 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h4><p>最好的情况：T(n) = O(n)<br>最坏的情况：T(n) = O(n²)<br>平均时间复杂度是：T(n) = O(n²)<br>空间复杂度为：O(1)</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote><p>维基百科： <a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/</a><br>代码出处： <a href="https://blog.csdn.net/jizhen_tan/article/details/52555639" target="_blank" rel="noopener">https://blog.csdn.net/jizhen_tan/article/details/52555639</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个程序员，一些基本的排序算法是必须要掌握的。以前人们总觉得算法是后端程序员去学的，前端只需要专注于网页的美观以及 JS 的基本逻辑交互就行，然而，近几年随着前端行业的发展，前端越来越注重逻辑交互，如果你还像很久之前那样只知道用 HTML + CSS 去构建网页，那就落
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.brightlam.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
